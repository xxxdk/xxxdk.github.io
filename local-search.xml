<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>sensor遮黑闪烁问题记录</title>
    <link href="/xxx/2024/06/sensor%E9%81%AE%E9%BB%91%E9%97%AA%E7%83%81%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/xxx/2024/06/sensor%E9%81%AE%E9%BB%91%E9%97%AA%E7%83%81%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>最近项目遇到遮黑失败，画面闪烁还偏红的问题，特此记录。</p><p>这里就不附上闪烁的视频了，以下面这张图为例，进行想象吧？！</p><p>具体操作是对画面进行zoom in，缩放到一定倍率后，会切换setting，sensor从binning mode切换进入full size crop mode，进而实现在保持sensor输出分辨率不变化的情况下，对画面进行了2倍放大的操作。属于数码变焦的一种，一般叫in sensor zoom，又叫片上数码变焦。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sensor</tag>
      
      <tag>AE闪烁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COVID-19 首阳记录</title>
    <link href="/xxx/2024/06/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95/"/>
    <url>/xxx/2024/06/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>19年底渐起的巨浪，在24年5月中下旬终于拍在我身上，威力没有预期的大，小号流感的感觉。</p><p>从一开始在微信群里视频看到街道上突然倒下的人，到新闻报道非典next；从年前戴着口罩战战兢兢的坐着高铁回家，到年后推迟一周上班；从因为室友自机场回来，早上五点多被防疫人员做了鼻咽试子两联的酸爽，到对做核酸的习以为常；从公司安排的第一针北京生物，看到了豪华的F区通道，到跨越整个广州城区打上了威斯克的第五针。还有很多很多，直到我寻思打第六针的时候，给我来了个自然免疫，还有一个可能的原因是清明后我就不戴口罩了，之前好好的戴了近四年半的口罩。</p><h5 id="5月14号"><a href="#5月14号" class="headerlink" title="5月14号"></a>5月14号</h5><p>现在回想起来，这天大概开始有症状，而这段时间也刚好有一个波峰。主要特点是早上起来洗漱感觉鼻子的分泌物有点多，其他感觉没有。</p><h5 id="5月15号"><a href="#5月15号" class="headerlink" title="5月15号"></a>5月15号</h5><p>早上起床维持鼻子分泌物增多的情况，下午开始感到喉咙有点不舒服，晚饭后基本就说不出话了。</p><h5 id="5月16号"><a href="#5月16号" class="headerlink" title="5月16号"></a>5月16号</h5><p>早上起床感觉自己发烧了，有点怕冷。坐到工位后开始用毯子裹着，被领导发现后火速送到公司医院挂号看病。做了抗原发现的确阳了，医生详细询问了挺多信息（公司自有医院就是好，细心也耐心），抽了两管血，然后就被送回宿舍休息了。下午检测报告出来，和医生在企微上面沟通结果，可能是前段时间有健身，肌肉轻微撕裂的缘故，心肌酶4项指标有点炸裂，特别是肌酸激酶去到了6000+，当然淋巴细胞相关也崩了。医生担心我心肌损伤，让我后天再来复查。</p><p>回到宿舍后，我买了宝矿力+大支怡宝，把之前为新冠准备的维生素找了出来，没错是两年前的，都快过期了。吃了白加黑、连花清瘟、维生素D、维生素C、维生素B和葡萄糖酸锌后，我开始了睡觉。期间爬起来喝了几次水，从11点熬到了2点多，才出门吃了个饭。等家人回来，我拿到了体温计和七号电池，公司之前发血氧仪也终于能用了。血氧掉得不是很夸张，心跳和手表测试的基本一致。</p><p>体温最高去到了38.5度，早上在医院是37.6度。发烧感觉持续了一整天，晚上也一直在烧。体温38.5度的时候我打算直接吃退烧药的，看了下成份，散利痛的对乙酰氨基酚的含量一片只有250毫克，白加黑一片有500毫克。我感到了自闭，我大概买的是止疼药吧，只能继续吃白加黑退烧了。</p><p>这天我的手表提醒了我5次心率过高（心跳超过120次10分钟以上），最高的时候去到了160，在1点20多时维持在130到140之间半个小时，我想这个时候应该是提问最高的时候吧。不过医生有说过，这个发烧的时候心跳是会上升的。</p><h5 id="5月17号-20号"><a href="#5月17号-20号" class="headerlink" title="5月17号 - 20号"></a>5月17号 - 20号</h5><p>星期五一觉起来，体温正常了。挺好的至少睡觉可以好好睡了，不过脑子思考还是无力，这可能就是脑雾？咳嗽倒是开始出来了，白加黑我是停止吃了，继续维生素+宝矿力灌水。</p><p>周六复诊，指标改善很多，和医生沟通了下，还是继续好好吃药。目前症状就是咳嗽和脑子不灵光。</p><p>周日，症状不变，测了下抗原，还没转阴。。。</p><p>周一，考虑我的工作进度和身体状态，还是到公司上班去了，乖乖的戴着口罩，后面发现一起上下班的同事还是中招了。脑雾开始有点改善了。</p><h5 id="5月24号"><a href="#5月24号" class="headerlink" title="5月24号"></a>5月24号</h5><p>第二次复诊，换了个医生，开了一些止咳的进口药，指标增加了维生素C的确认。虽然治疗费会有部分走部门经费，但自费部门还是达到了264块，公司医院对平常人的过度医疗这点特性有出现了，不过对财务自由的人来说，公司医院的操作是十分好的。</p><h5 id="6月10号"><a href="#6月10号" class="headerlink" title="6月10号"></a>6月10号</h5><p>端午假期结束，感觉自己的咳嗽好了很多，虽然还是有点零星咳嗽，但至少不会咳得很厉害了。脑雾持续了大概一周，咳嗽目前持续了一个月还没完全好。听说身边有人咳了两个月，这样看，我算挺好的了。</p><p>和很多一阳比起来，我的症状是很轻微的了，他们有全身刺痛、完全无法睡觉、身体状态也迷迷糊糊的，发烧的持续时间两三天的。我怀疑我是在疫苗的帮助下，一阳无症状，现在这次可能是二阳或者三阳。不过也有同事二阳比一阳严重，这个就看我后面的情况了，但至少我后面不太担心远行的时候阳，陷入孤身一身，无人响应的窘境。最后说下，公司一阳是放假七天，我就放了两天，还是间断居家办公的两天。还有个新冠体检，也没有享受到，这个好像会仔细的去看是否有肺结节。</p><p>下面放些COVID-19时期的图片，仅此纪念这个特殊的时期，让很多事物发生了改变，有机会再记录吧。</p><p><img src="http://pic.xxxdk.xyz/2024/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95_1.jpg"></p><p><img src="http://pic.xxxdk.xyz/2024/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95_2.jpg"></p><p><img src="http://pic.xxxdk.xyz/2024/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95_3.jpg"></p><p><img src="http://pic.xxxdk.xyz/2024/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95_4.jpg"></p><p><img src="http://pic.xxxdk.xyz/2024/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95_5.jpg"></p><p><img src="http://pic.xxxdk.xyz/2024/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95_6.jpg"></p><p><img src="http://pic.xxxdk.xyz/2024/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95_7.jpg"></p><p><img src="http://pic.xxxdk.xyz/2024/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95_8.jpg"></p><p><img src="http://pic.xxxdk.xyz/2024/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95_9.jpg"></p><p><img src="http://pic.xxxdk.xyz/2024/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95_10.jpg"></p><p><img src="http://pic.xxxdk.xyz/2024/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95_11.jpg"></p><p><img src="http://pic.xxxdk.xyz/2024/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95_12.jpg"></p><p><img src="http://pic.xxxdk.xyz/2024/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95_13.jpg"></p><p><img src="http://pic.xxxdk.xyz/2024/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95/COVID-19_%E9%A6%96%E9%98%B3%E8%AE%B0%E5%BD%95_14.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绣球养护简略版</title>
    <link href="/xxx/2024/06/%E7%BB%A3%E7%90%83%E5%85%BB%E6%8A%A4%E7%AE%80%E7%95%A5%E7%89%88/"/>
    <url>/xxx/2024/06/%E7%BB%A3%E7%90%83%E5%85%BB%E6%8A%A4%E7%AE%80%E7%95%A5%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>几年前给家里的天台买了几株多年绣球，希望可以在夏天的时候体验绣球盛开的快乐。但现在总结经验来看，还是不要买多年的比较好，根茎处的枯木有点多而实际的枝丫可能不多，导致需要大盆而植株不大，可能买一到两年的比较合适吧。</p><p>绣球基本都是老爸在打理，他之前没好好打理，剪枝基本和割韭菜一样，导致老枝基本没有，而有几株绣球是老枝开花的。为了避免后续出现这样的情况，我就写下了这篇文档，因为不是我实操，所以也只能做参考，和实际可能差异挺大的，还有就是比较适合两广地区吧。下面就正式开始吧！</p><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>1、喜欢散射光或半阴环境，夏、秋季半日照环境，其余全日照，半日照即10点17点使用遮阳网；在露天种植的话，还要考虑夏天的西斜，绣球暴晒之后特别容易蔫。当前我的种植环境在夏天可以去到35度左右，约摸从6月一直到10月吧。现在是放在完全挡住西斜，上方用比较疏的遮阳网的位置，阳光基本是早上直射，剩余散射光；</p><p>2、应放置在通风良好处，此处有两点：一个是摆放不要太密集，另一个是选择的盆要比较透气。</p><h4 id="肥料"><a href="#肥料" class="headerlink" title="肥料"></a>肥料</h4><p>1、春季绣球嫩叶时期开始施肥，氮磷钾比例是 1 : 1 : 1；</p><p>2、出现明显花苞时更换比例，氮磷钾比例是 1 : 3 : 2，一般 7-10天1次；</p><p>3、花苞期，施肥灌根 1 : 1000，一星期1次，叶面肥 1 : 1500，一星期3次；</p><p>4、花苞快开时停肥，直到花开完，修剪后进行追肥；</p><p>5、秋季，不开花的绣球开始适量的停肥，冬季在土壤中埋缓释肥；</p><p>6、雨天，盆土太湿不好浇肥时，喷叶面肥；</p><p>7、绣球不耐肥，薄肥勤施；</p><p>8、看到花苞时就要开始调蓝了，主要靠硫酸亚铁和硫酸铝，调蓝属于个人喜好，操作方法有很多。</p><h4 id="土壤"><a href="#土壤" class="headerlink" title="土壤"></a>土壤</h4><p>1、建议选择泥炭土、珍珠岩等大颗粒介质混合后种植。当前我使用园土、松鳞、椰糠、谷壳和羊粪蛋，后续几种多点也无所谓的；</p><p>2、两广地区，每年大雪到冬至期间换一次盆，每次大一圈，不换盆则刨掉上层5厘米土壤，放入新土混入缓释肥；</p><h4 id="修剪"><a href="#修剪" class="headerlink" title="修剪"></a>修剪</h4><h5 id="1、老枝开花绣球修剪方法"><a href="#1、老枝开花绣球修剪方法" class="headerlink" title="1、老枝开花绣球修剪方法"></a>1、老枝开花绣球修剪方法</h5><p>1.1、绣球8-10月在当年新枝形成花芽，在第二年夏季开花；</p><p>1.2、花后在花球下面第二对叶片（有芽点）上面一厘米处修剪，剪掉过高或过长的当年生枝条，去除枯枝和老枝，8-9月前完成修剪（主要看温度），秋季修剪会导致明年不开花或者花量减少；</p><p><img src="http://pic.xxxdk.xyz/2024/%E7%BB%A3%E7%90%83%E5%85%BB%E6%8A%A4%E7%AE%80%E7%95%A5%E7%89%88_1.jpg" alt="修剪"></p><h5 id="2、新枝开花绣球修剪方法"><a href="#2、新枝开花绣球修剪方法" class="headerlink" title="2、新枝开花绣球修剪方法"></a>2、新枝开花绣球修剪方法</h5><p>2.1、绣球在当年生的新枝上开花，花芽在开花前一二个月于当年生的新梢上形成，修剪可在花开后第二次花芽形成前的任意时间；</p><p>3、秋天不建议修剪绣球；</p><p>4、两广地区，冬季最冷的时候（立春前）将叶子全部撸掉，只留花苞即可，但不能修剪枝条；</p><p>5、原则是去弱留强；</p><p>6、通过留下老枝，可以让绣球长成自己目标的高度和大小。</p><h4 id="花期"><a href="#花期" class="headerlink" title="花期"></a>花期</h4><p>1、延长花期需要遮阳避雨，绣球花苞淋雨可能会烂苞。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>1、这份文章参考了很多地方，有B站各位up主，有淘宝店的教程，下面是一些参考的网址：</p><p><a href="https://item.taobao.com/item.htm?id=521409072598">https://item.taobao.com/item.htm?id=521409072598</a></p><p><a href="https://www.bilibili.com/video/BV1Ds421A7w3">https://www.bilibili.com/video/BV1Ds421A7w3</a></p><p><a href="https://space.bilibili.com/327835274">https://space.bilibili.com/327835274</a></p><p>放张今年雨后的绣球照片吧！</p><p><img src="http://pic.xxxdk.xyz/2024/%E7%BB%A3%E7%90%83%E5%85%BB%E6%8A%A4%E7%AE%80%E7%95%A5%E7%89%88_2.jpg" alt="雨后"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>植物</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024年2月4日</title>
    <link href="/xxx/2024/04/2024%E5%B9%B42%E6%9C%884%E6%97%A5/"/>
    <url>/xxx/2024/04/2024%E5%B9%B42%E6%9C%884%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>距离上次在博客活跃已经过去了两年半，在这一坤年的时间里面经历了很多事情，也积累了很多要写的记录，后面都慢慢的补回来吧。先列出来，免得后面忘记，包括但不限于CMDQ的初始化流程、HC died问题解析、CMDQ 异常案例分析、绣球养护、建兰养护、桂林游记、sensor知识点、MS OS2.0 descriptor与注册表、UVC metadata、USB速率统计等。</p><p>两年半的时间，换了一份工作，从原厂到客户侧；换了一个城市，从深圳回到广州；换了好几个住处，最后房间都是10平米。这篇文章标题现在的标题是《2024年2月4日》，估计后面会改吧，刚开始写这个博文的时候，并没有想好标题，也没有实际写上内容，只有一个标题而已。</p><p>两年半，有好好的成长吗？在技术上面可能有一部分吧，但技术很多情况需要慢慢的积累。做新的方向是可以成长，但成长的深度几何，或者说我可以接触到的深度。现在不在原厂了，我需要转换思维吧。现在我遇到的困扰大概是原厂的技术支持可以好好支持，我将十分感激，想想以前自己一天打四五个电话去沟通问题，他们是不是也觉得我很nice呢，真是个奇妙的循环。</p><p>必经的人生低谷会有几个呢，既然选择回到广州，那就好好的向前看吧，以往的一切都不去思考，break就好了，当初没好好放在心上的事务，现在就好好成长，然后让一切随风。</p><p>生活有很多无奈吧，保持初心，前行。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无尽的夏天</title>
    <link href="/xxx/2024/04/%E6%97%A0%E5%B0%BD%E7%9A%84%E5%A4%8F%E5%A4%A9/"/>
    <url>/xxx/2024/04/%E6%97%A0%E5%B0%BD%E7%9A%84%E5%A4%8F%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="caa647dbacf143a56549ffeafe89891b6c8d1afcd5d212d80594f3c441332864">16c4a5cd16abe2138be58f52f480a78560d7fc91099a57b2f11ea94482b5d313225b561e7460949ff63204e6ca18136583a5515d9a3f600da0e9cd7f029d3ce769cdc43f6897f6c23983a391bf5516f9e77cbd2000577c6d96c5827413ffaa89bb53120d1edd57bddcaf74ccb93df2ce7be066126bdf860ee5b228138445f710924a1689b3eb77948968f7a2fd7b0f3e2e1f580f1e82351898ffb01af6a22f10cc4571a0b7950823e9ed55d9f97a1794cb7dfbe5f653674322c7f52b484fed5b9d2c57631871744839ab227a939b5a03098bb96c99268482956c389863c8ad7d16f565c44bd678b3a94cddc9141dc7f77dbebd8dd1229dd936c05f63d093b7fa7e81f45ec4e0fe10b9798f6d47096b04047bcc93fa9c08d9905a905c3584b6b373042a857634c4892c12085e409e958439311a194d44594a61fa0954dd43882b2f47359633a17f592f711fe079ed6fab26542846170816c1e787deabd4131ee4943b720d700048c66d6a81ec1bf91c2c8caf030fdca2cf8608af1a3d2126b3b871de699ff89c0912a8b5d3490b45622a2d6f6b80a8d7b6d3ad4b71585f3f0cacf9c184e10b696076386f0ab69855d389890e57182e500cc4cfc838f0dc15e17b21aa4698836f4ad505b84f85735232f3ecd5b7c51922afd5ae0fb2a7ff91ae953be3345c29589e148509605873dc08b7b5a72abcbb5d075dce9be9210f844888b9c5775e913be1257fd9b2bae9bd8d8e5cad97b5603fc72d05bae5907f05b0581d61143f645c8b126d963e6eca0cbf1811b69fed145326b3a7bdcac268ba377358c64aab8b2856f9d83e09e73a681922fbc4ad2274b3febb6d9e2b383055a95de6d22c43482f7eed851cc4ea38245400a8f60f1a655b099bdfd3cbda6d43838f5cbe80bda97957d8cbca216fc1c897eae2e918cc09839f75f84420883a3e7cc2e591a5d1f4f82b04e9d5097fcb9048e6113e058888065ae710b58192a18915e5991ea63cdacfd9275e91c3e418a382b775b828b261517a172d106268343afe8b1afb396def245dabfb8e621d851ab6f35629b73b48a5f81cdc1414e96f63258df8b572009a3ba55cd503e82984dce1298ded4544ba27d0b80c2b7e3f09d0164008e0352adecea7808a1f87ab0acf73dc40c8a33997230ad957e513fb121fdda5150c28b33d3047d0c370075331da2a011fc27e3cd00cbe73c9e091878cb68c821c209ebc0c1a9b7de6e26cbc69c8aacad3e0ca73b79b032c4f95dc2c02ceeedf1deee8585e6a1a1120b4c569a3482128df07c78e0b905d3801b8d152017f4ac1933e8a28249a4293f891459bc245c98b0ea90088ef6ed4497d0422632cb1403d6e5337995018f498a33496f9ba3c190ba578d6f416d6100c4e183f143a017e6ae0e3d1d83070747919306fe5f5636b57ef6ae7de51fb7555209983878fde554f8b60f30f3a13ad9a3d73bdc985da3c2b9b76298458792f525b1f1c3e14e8a850b1c3c1027d4dfde11426772515587abd42b1ccfd8e38edea7d502c1a41e9e5b489694c5c5941d1f2aa9836b64acb4ad56fcab9fce32bde61e62acb06cfd5eab7bce4bdfa39be773fa6b2b472eecbc45cd2b8e4ef4fd03d81573c105e5f82d1863f1ec77476f13f8d7bfbf234f42e6816e86781af05af303091b055bfa1519ef41a6e94b4a649fb69174e390d543629edd98698a3ea4e311a9d5e586fcf06d846fe9440d8519bf3e09684ff7baab02e5c4561a710e98312b837b862f49d6b3bfb13ef24bbd630aa6123abc0cc48b7b181cad5770422cd5c16d568eb6fcd5f9142507a3de4cf6f8aeeaf980362e11e00162037bff04f968e654cb9d5524ebacfbd83b928b0cee079861af19568e2f90759225c87780ddd6b6e118382df7f45f579ea8feab3f0060f5879c14d7aca41da9f5b5ba87722f4282413f1cb1bbb7d28e453971dd48efc800207c42977ae95e08221e0f97e88b5de1d5547d90ac137f90740d7920208c3df78d54cd861de5fbf88b012da199320bfeaa77a9b0d503dca6c25ab8878c33eb3a20c94d7eb83ed884ed459a9f4898069c8182cd559e384a2a4ecbd47dabec4bed7de3356334710f40ab00fa7720c0b88b1ca21c95c6620cd002dbb64341173e4e359032e3d1d9a6ae4e20a4bdf7fc250756c2aed62379e5095fc3e8e217d9407b93e5a30cf4f2ef23fe566d8231239be8249787b562c810c971b0df31beabc584c3e37a16c323d48c836bb20ff32c4425e843194501401353ef79fa8e2f166ab864ac41e1de024f9e8e1b15654547effb44f85c436cf8e17a35e868ecc19fd9e56a17a196f1bc263c60aba0829ebd9c0454fc3539f2fa1a33c1946ef51a8a2390a0ae8edd7410583d9d93f31b6c40071fcb81d3e0bb5b9cd366c3725d6b9268cf4d22da370916b2b53061c414c9317b1bd7af617a291c51a4e21359c3538096109f1f03ed245fb6b4b2739d19f9e573398e617b031efbabd1f328ba0014ecd53323c31a21747153a40cca44dae3d8f6f9a1a9c0d0ffd10a2460a7bc3bd2c94ad8c8914435cf831e34bd123ff8fa776d1523a2549fece81ccac6b945239dd9796cd67ed2bedc125e4b89b49ccfba1ba8509d36bc586a7d59f265c4a6ab65df5518c52f6f9e5e325752df2166284f290a50cd607513b9fed548b93875c1b7762c37896bc07d243b49e4a114bd45033e9c2fc605f099f72b1107e348f4fc01abeab49ed2bd66e021ab0a7edd327b9c93c9af93e749155208f4feec78ae11bfac2689f175e87e37db30983633e545afbadec5c6dca887a8b8a5c9aaef0724813b254507d12a3f5038e5dbb6caa8a3243a1f4248beacb46ed51de081076717e7799abb4af67db74a2838b59538780a2c68e21f2a11ca5fa1d538cf3f7a6ed4eacaf940e4d0b4a9772e1102f7ab7f9b6e15b376d69eb418c3e815b0c79370e889fd1b8929312932b91d0628417a72337371cbb2d3eab54d699d863cb4c55f8ed536a276fdd7cd704d5777480cd545315eb59a72492e475aff86669676ad1e1da798ed290aad9a4b0e0c13528c660b7c1e5bcca76c8bf31833d34e0198b65689e1ead600f411a2a61676ef9cabbb8cd6701e7407591d179bb09f180a7bbbcda34d6a284d412013bc3d7baef1026132a925b6b974c64ac935465ac09bf8d63f24f70a40f291a5c2302984512373e3c9c66b598944b23d06a9952bc21245a2b1daac80daffea51ab7645a45715a9023e6d4a6f6b891b470b8f45a052a73494eb2b87025da07682ca54ba34db32beeb9bcb04936e9b0881d130b2864513ecd272eaa08dd0dc4879e2350c420f00dc2724943d5ae8aaf79d6ead315d1635c0af312fe26cd4c76d25536fe4d91b9f8f8f36ab2d5ee35106248628ae40cd7d5db3236852dfe060b50829e8ecd80c34c98da3bd64ef14e37dd9f4d1ea1b179e7402239eef6caee7cd3c8268542f12aa3ea0a9a03ee7633638e405c3e64e38ed3399090a49fa1dc40f3dab98ac3ecb66d80b9249ab7b337a8b2dff37d438e9d27f8b0f0427d0f93c4c40df43f0720572441e1b31313ee7a1621d66fd1a171cf9269f3fea5971e9ca3d82d04ed04a97b790563ca6fac5e25bbfa160c5ce7f98cdd670af55008cb765d662d1d49453f4b43b5087133f4287ea8471ac2c8f5ae0ef209f8015791055ca0cdbfb246da8090babf444440346f19ce1377fb889434d9d74da866a9d7a8390352f9278e52e27d27c38f0758d5f7c844255d3670ef65c56b5d47bde8fa8e46fa8fc6c01e7167e005d18a2df99014e24b68f3d5cf0f7f0ae9a0bbb84de32aa545c7e033f2de97b1dfb4dd7b07fd04a6f9af1007189898059c8b8658245db79961b1a7207a8e6370462573c9b39d8873fa4b9f832c870e181d5082e7007a972fe423dbc3b5aed012cf2ebfe227ba539ca29cb247694f725b646df02492c1388ea09fe7761428347d945b4188d63a15fb62018d5a6892da2ccff283579602e2e1fee9e7170039ff3c76bd6fdd644682d1abbef543bd5ac33a21404079958570a2d62296d018a72d784c81f781166bf9c1460c91b046ca4c2503b401231b5a086b9d6d2e6f573d70604dccb85c2d0612251342283850a34a2be35987a9b78770ef94975377bfab7acca3cd9bddb9b1826f6e066168b21d25445983405faaff8b18217b56a3ef40793195022674c8b1937cc1c9c67b59eee0bb937c4a077b4e78ddba6ece284ba4405aef0878b7624e0194a237abd90d9f3cab86ce37e61ed7b3c395ee6a16e0b62bd471f03be32d7ca87184ba649d3c77506796202257f73016e0bde590f2e87a473711a25a285192f0855070a2587ba9a8309bbd6bdb6b9a013f72f04cac8b94c0fc92c0aa4dff71bb1debafcf1b9b4728df9a442b8cf1b3dd7c20ca239e93e2e3b59b3110f81702347875e4c23715c33f204d258bbd0e29a1977f4206b11c94d748e24efe27523bfd753062d8095556a34255ea441d9b69915b616baca08ac3923158f333fd2b9e757e077dbb8bae2e67809cf4463afce2e4e14fdfcbd88a1536879d47f608dfbdc3b450a808e4e96aff77c764d4268da7e54114bc31f785ba20ff3f5f4ef9ac063437ac051d21f5251dde04</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>穿越东西涌</title>
    <link href="/xxx/2021/10/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C/"/>
    <url>/xxx/2021/10/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C/</url>
    
    <content type="html"><![CDATA[<p>2021年的国庆过得忙碌而充实呀！2号回到顺德吃到了金榜双皮奶，去到容桂参加了同事的婚礼，顺德婚礼真是复杂啊，可惜没有完全体验，我主要帮忙男方到女方做翻译，但是感觉也不是很尽责（摸鱼🐟）。婚礼当天和三水哥一起陪女方喝早茶，没想到还喝上了酱香型科技。酱香型科技打开那刻，整个房间都充满了一种异香。一开始我是拒绝的，除了小时候偷酒喝，长那么大还没喝过白酒。在印象中，白酒不好喝，但是酱香型科技没让人失望！在婚宴上吃到了很多顺德特色菜，之前在这里待三年也没吃上🤣，但最让我难忘的还是那白切鸡，色香味俱全！嫩、滑、香、骨不带血，可惜只吃到了一块。当然也有帮忙拍拍照，发现人像多年没拍，水平也没啥退步的，有种自己失业了也可以去影楼谋份差事的错觉。顺德变化是真的大，南国东路快速路、华侨城的欢乐海岸、还有JRI变SRI加党校，但顺峰山还是那样清凉、舒适。</p><p>10月4日，回到深圳休息了半天，10月5日，正式开启了穿越东西涌之行。</p><p>东西涌穿越有正穿（东涌–&gt;西涌），反穿（西涌–&gt;东涌），中穿（东涌–&gt;深圳天文馆），原本计划是正穿的，但计划赶不上变化，最后走了中穿，但感觉也没差多少了。资料，地处深圳市大鹏湾以南的东西涌海岸线，全长四公里，山路占据一半的路程，而且由于海岸线的依山傍海、迂回蜿蜒、沟壑纵横的缘故，实际上要穿越徒步的路程有8-10公里左右，耗时约5-8小时。</p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-0.jpg"></p><p>出发时间是9点08分，摩拜16分钟骑到了坂田地铁站，9点30分到10点12分，42分钟到达莲塘站，10点31分在莲塘公交站坐上E11，11点50分到达南澳月亮湾站，下车到斜对面的沙县小吃解决了午饭，12点14分在南澳月亮湾站坐上大鹏假日接驳专线3，约40分钟到达了东涌社区工作站。在接驳专线上，看行头基本上都是去穿越的，下车后取穿越的人也是陆陆续续的，基本不担心找不到入口。</p><p>13点10分开始穿越，当然正式穿越前应该先做足准备工作，冰袖、防晒霜和帽子和随身携带的水。可能是国庆人多的原因，穿越路上卖水的点还是比较多的，0.5L升怡宝5元，小瓶宝矿力8块，贵不贵这个只能是见仁见智了，总的来说不需要太担心水的问题。在入山口上还需要填写信息，激活紧急救援定位用的小程序。</p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-1.jpg"></p><p>可能是刚刚维修翻新完成，陡峭的山路上的锁链都是新的，只要看到锁链上下山问题都不大，让人烦恼的反而是海边的石滩。都是大石头，没有小碎石路段，走快了容易崴到脚，应该是我鞋的问题。</p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-2.jpg"></p><p>这次穿越是和大学同学一起的，但是他只和我走完了大约一半的路程就坐上快艇前往终点了，时间大概是16点45分，后续我只能一个人趁着天色未黑加紧赶路了，幸好路上人多，山路最危险那段也过去了，不太担心出了问题没有救援。大约18点15分，来到了天文台与西涌沙滩的分叉口，此时天色泛黑，看到海边船家打着手电信号接应上船直奔西涌沙滩的人。想想海边礁石不好走，路程也不算短，赶路太快还容易扭伤脚，决定还是往人多的天文台去了。10月的天还是黑得快，大概20分钟，还未完全到顶，天已经全黑了，此时不过18点40分。</p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-3.jpg"></p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-4.jpg"></p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-5.jpg"></p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-6.jpg"></p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-7.jpg"></p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-8.jpg"></p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-11.jpg"></p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-9.jpg"></p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-10.jpg"></p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-12.jpg"></p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-13.jpg"></p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-14.jpg"></p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-15.jpg"></p><p>上到天文台，有天文台班车可以下山，在排队途中算了下队伍长度与班车时间，还是决定走下山，此时全身发粘，双腿已经精疲力尽。下山路没有灯，峨眉残月🌘下只能依稀看出路的方向，看向海边能看到西涌沙滩和集装箱船的光。让人意外的是有个约小学四五年级的小妹妹，被我追上后就一直跟着我速度，算是一起下山了，毕竟我一成年人都觉得路上有什么危险也很难被察觉。</p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-16.jpg"></p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-17.jpg"></p><p>下到山脚，已经是18点58分，在小卖部买了瓶马蹄爽🧃，安顿好小妹妹就继续往民宿走去了，看地图又是一条漫长的路，一路没有任何交通工具，裂开🙀。</p><p><img src="http://pic.xxxdk.xyz/%E7%A9%BF%E8%B6%8A%E4%B8%9C%E8%A5%BF%E6%B6%8C-18.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游记</tag>
      
      <tag>深圳东西涌</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDIO常见问题指南</title>
    <link href="/xxx/2021/06/SDIO%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%8C%87%E5%8D%97/"/>
    <url>/xxx/2021/06/SDIO%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>搞 mmc驱动就没办法只搞 eMMC或者是 SD Card这单一驱动，除非你是在 Intel、MTK或者是big Hisilicon吧。原因主要是两点，第一点，eMMC、SD Card和SDIO都是在 MMC Card基础演进，技术点上有很多相同之处；第二点，IP核大部分公司用的都是 Synospsys的 DesignWare IP（dw/dwc），这个可以在 Linux代码中略窥一二，主要是看文件名和寄存器的 bit偏移。毕竟自研 IP是个系统性的工程，需要投入大量的人力，而且功能和兼容性还需要时间的积累、迭代，还是直接用买到的轻松。不过在当前这个大环境，自研 IP是一个让人血液沸腾，十分有意义的事情😆。</p><p>扯完了，下面开始正题吧。</p><p>eMMC、SD、SDIO三者虽然同源，但是问题爆发的时间点却是不一样的。eMMC作为关键路径，问题基本在样片阶段就被发现、解决完了，它追求的不是能用，而是稳定；SD卡问题多出现客户侧或是用户侧，主要原因是市场上什么牛鬼蛇神都可以生产 SD卡，可想而知它们的质量与兼容性是个让人头疼的事情；SDIO的问题则多出现在与 SDIO设备对接的研发阶段，不管是在原厂还是客户研发侧，而且目前还没有见过 SDIO自身的问题，dwc和 Linux真是稳。</p><p>SDIO问题基本集中在识别类上，主要有以下几种情况：</p><p>1、对接的 SDIO WiFi模组没有给电或是没使能。</p><p>处理的第一个客户问题就是这个，RTL8189不识别，当时接手 mmc模块没两个月，客户凶的厉害，让我这个 USB老司机怂得不敢和客户电话沟通😶。软件 check了一圈没啥毛病，看 log是 device没有对 host的命令返回 Response。客户不愿意把环境给到我定位，刚切换产品线的我，协调内部资源也是懵逼，最后在 AE帮助下总算搭好公板环境。公板也复现了客户问题，难道是漏出的缺陷？那事情就有点大了。后面找硬件确认 VCC、EN管脚和信号管脚等才发现，使能管脚一直为低，模块没使能怎么工作嘛，同步让客户修改，问题解决。</p><p>后续针对这个问题，还开了个回溯小会，分析问题漏出原因，后面根因涉及另外一个部门也就不了了之。会后感慨这个产品线的风格真棒，这就是为什么可以做到业界第一，把 TI打的满地找牙的原因之一吧。</p><p>针对 RTL819这个模块，有两种解法，第一种是硬件直接拉高 EN管脚，第二种软件控制拉高 EN管脚。其他模块可能要用第二种比较稳妥，当然这个问题也可以归类为上电时序。</p><p>2、SDIO WiFi模组或 SOC的 SDIO管脚虚焊。</p><p>这类问题，kernel log上看到的情况和第一个问题是一样的，但是在硬件排查时会发现相关信号管脚没有电平输出，或者信号比较奇怪。出现问题的阶段基本是在工厂产测时候发现的，工厂这时候就会说我要停产啦，这种停产问题就又急又严重，最高优先级的事项了。情况多是在一个批次中有一定数量的问题产品，客户做更换 SOC实验发现跟 SOC走，然后说你 SOC有问题😨，要赔偿了。这时候要冷静，客户的实验结果未经分析都不可信，首先要好好和客户确认实验数据，每个步骤的细节，总是能发现矛盾或者纰漏点的，这时候不能怼客户，因为他也急呀。秉持你们是一根绳上的蚂蚱，以及你是这块专家的心态，重新安排实验（可以提前想好要做的实验），尽可能的将软件相关问题排除完，下来拉通硬件、逻辑、芯片量产的人看看还有什么追加实验。如果是虚焊的问题，基本重新焊接问题就不复现了（实在不行换到公板上），抓住这个重点的实验现象，让硬件重点 check，让 FAE拉通客户侧资源 check，问题基本到这里就是客户自行解决了。据我了解，虚焊可以通过 X-ray检测，不知道是不是常规手段。</p><p>3、对接的 SDIO WiFi模组上电时序不对。</p><p>这类问题遇到蛮多的，基本都是 WL_REG_ON这类使能管脚没有拉高，或者拉高太早或太晚了，或者是万用表测量是高电平，实际上没有用上拉电阻，导致电平不稳定。在 kernel log上看到的情况和第一个问题是一样的。也有某厂家的模组（利益相关，不说是谁了），上电时序要求及其严格，模组供电、管脚使能、模组时钟的供给都要十分精确，只能放到它自己的驱动代码里实现了。</p><p>4、host对 SDIO的管脚复用配置错误。</p><p>这类问题多在系统迭代升级遇到，在 kernel log上看到的情况和第一个问题是一样的，硬件的检测也没啥问题，只能依靠经验在 u-boot阶段或是 sdio rescan阶段把 CMD、DATA和 CLK管脚的管脚复用寄存器打印出来，确认和配置值是否一致。是在 u-boot还是 sdio rescan阶段还要看整体方案设计的管脚复用是在哪个阶段配置的，如果是在 sdio驱动代码中配置，则要在 Linux终端上确认是否被别人改动了。</p><p>5、host没有给 SDIO逻辑提供运行时钟。</p><p>这类问题是有点搞笑的，只遇到一次，某些 SE（System Engineer）以为自己知道系统全貌，就开始瞎搞，人为的为他人制造问题，浪费项目人力，正常操作是不懂就要拉通对应 CBB问，确认🤨。</p><p>这个问题出现的场景可能是，前几天还能识别的 SDIO WiFi，今天突然就不识别了，这段时间我也没上代码到库上呀，奇怪。Kernel log上会出现 “Hardware doesn’t specify base clock frequency”，再读下 host控制器的 SDHCI_CAPABILITIES（0x40），发现是 0x0，那这个问题就是逻辑没有运行时钟了。</p><p>6、host对 SDIO的 dts节点配置错误。</p><p>这个问题要根据具体的硬件环境配置和软件方案排查，如果 VCC是恒供电，SDIO WiFi模组也是焊接在 PCB上的，那 dtsi就不应该有 “full-pwr-cycle”，同时还要有 “non-removable”，见到有 “cap-mmc-hw-reset”这些没半毛钱关系的节点也要去掉，还可以加入 “no-sd”，“no-mmc”这些描述告诉协议栈不用发多余的命令去 check device具体是什么设备。</p><p>问题排查流程总结：</p><p>1、硬件确认 VCC、EN、信号管脚，确认上电时序是否符合模组手册要求；</p><p>2、客户硬件设计特殊，让硬件 check电路设计，是否符合设计约束；</p><p>3、软件确认客户是否有私有修改，dtsi是否正确描述；</p><p>4、根据 kernel log分析，不充分就合入 debug patch，查看 CMD和 Response；</p><p>5、device不响应 CMD，需要考虑硬件问题或是管脚复用等；</p><p>6、不响应特定 CMD，则跟随协议与 kernel代码流程，确认是否 device原因；</p><p>7、读取控制器关键寄存器，确认控制器状态（SDHCI_HOST_CONTROL 0x28、SDHCI_CAPABILITIES 0x40等）和交互状态（SDHCI_PRESENT_STATE 0x24、SDHCI_INT_STATUS 0x30）；</p><p>8、先进行软件还是硬件排查这个是不确定的，软件最快速的排查方法是合入 debug patch，查看 CMD和 Response以及熟悉协议流程，这个很重要。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mmc</tag>
      
      <tag>SDIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>换驾照的折腾</title>
    <link href="/xxx/2021/06/%E6%8D%A2%E9%A9%BE%E7%85%A7%E7%9A%84%E6%8A%98%E8%85%BE/"/>
    <url>/xxx/2021/06/%E6%8D%A2%E9%A9%BE%E7%85%A7%E7%9A%84%E6%8A%98%E8%85%BE/</url>
    
    <content type="html"><![CDATA[<p>最近驾照过期了，虽然有一年的的时间去更换，但秉持早处理早轻松的心态，还是在最后期限的三个星期前开始查资料，做准备。</p><h4 id="第一个星期"><a href="#第一个星期" class="headerlink" title="第一个星期"></a>第一个星期</h4><p>询问同组的同事A和同事B，A表示直接去就好了，里面能拍照，不用体检（后面发现他就是个天坑），B表示他之前去也是不用体检，描述和A一模一样。</p><p>于是去了最近的福田大队，刷身份证进到办证自助机前，发现不管是驾驶证期满换证还是驾驶证转入，自助办理都要联网医院的电子体检单，这大晚上的业务应该都结束了，不过30块的自助拍照机还是在的，证件照问题不大，于是又回去了😅。</p><h4 id="第二个星期"><a href="#第二个星期" class="headerlink" title="第二个星期"></a>第二个星期</h4><p>这次好好查了下驾照体检的信息，驾照体检分为联网医院体检和自助体检机两种，联网医院基本都要工作日才能做驾照体检，而且也比较远，没有地铁直达。自助体检机就没啥限制了，同一个地方还有办证自助机，nice！于是决定周日去南山车管所一次性弄完。为什么不是周六？因为周六要加班🤣。</p><p>尴尬的是去到车管所发现还是办不了，因为自助体检机所在自助大厅因为办理业务的人员太多了，需要预约才能进去。大写的无奈，只能回去下个星期再来了。</p><h4 id="第三个星期"><a href="#第三个星期" class="headerlink" title="第三个星期"></a>第三个星期</h4><p>折腾了两个星期，这个星期是终于换上了驾照。星期一回到工位，同事A突然问我驾照换好了吗？流程是啥？大哥原来你没有换过！感觉之前你都在忽悠我了😒。</p><p>下面是经验总结，记录下这坑爹的历程😐。</p><p>1、我所在的城市是深圳，干电池之都，资本家的乐园。</p><p>2、驾照挂在哪个城市的交警大队，都没啥关系的，异地处理违章都很方便了，如果不是到期了，就没必要转入了。</p><p>3、本地宝或者网上查到的自助办证机都是有的，但是自助体检机只在南山车管所有，要用自助体检机需要预约自助大厅，流程如下：深圳交警微信公众号–&gt;星级用户–&gt;更多业务/业务中心–&gt;驾驶证业务(更多业务)–&gt;自助大厅预约。建议提前一个星期预约，特别是预约周六日。</p><p>4、如果实在预约不上，早点出门，自助大厅外面的左边也有一台自助体检机，排队的人一般也没有自助大厅的人多，不过自助大厅的机器多。夏天在室外排队应该也是蛮痛苦的，还是自助大厅比较香，我也是弄完才知道的，尴尬。</p><p>5、预约好后，到点直接刷脸或者身份证就可以进去排队了，有啥不懂都可以问里面的工作人员，深圳的公务员还是蛮nice的。</p><p>6、我是期满换证，同时驾照挂在广州，在这样的条件下，很容易让人觉得我应该选驾照转入，但实际情况是选择期满换证，在自助体检机里面，选择期满换证，非本市就好了。</p><p>7、自助体检机可以免费把驾照的证件照拍了，所以就没必要提前拍好照片了，如果当天穿的衣服不合适，那就找工作人员借一件深圳义工的衣服穿穿吧。</p><p>8、根据观察，体检和拍照完是没必要把相关单据打印出来的，直接去自助办证机换证就好了，当然旧驾照如果想留着，也可以不上交的，相关的界面直接点确认就好了。</p><p>换驾照真是一件折腾的事情，说到底，还是信息收集能力不行啊！</p><p><img src="http://pic.xxxdk.xyz/%E6%8D%A2%E9%A9%BE%E7%85%A7%E7%9A%84%E6%8A%98%E8%85%BE-1.jpg" alt="1"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eMMC Command Queuing简介-Command和 Register</title>
    <link href="/xxx/2021/05/eMMC-Command-Queuing%E7%AE%80%E4%BB%8B-Command%E5%92%8C-Register/"/>
    <url>/xxx/2021/05/eMMC-Command-Queuing%E7%AE%80%E4%BB%8B-Command%E5%92%8C-Register/</url>
    
    <content type="html"><![CDATA[<p>原本是想着一次性把 Command Queuing（CMDQ）介绍完的，后面翻译 register发现不对头，这 register又长又臭，于是就拆分出来了。下面一开始是惯例的超简单介绍：</p><p>Command Queuing（CQ）的介绍主要来自 JESD84-B51的 6.6.39 Command Queuing和 Annex B (Normative) Host Controller Interface for Command Queuing，想了解一手资料还是要看协议。Command Queuing是在 5.1规范引入的，host 软件通过任务队列形式，提前准备数据，在逻辑侧完成对任务的命令级交互，降低对CPU调度的依赖，从而实现提高性能和降低损耗的目的。</p><h4 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h4><table><thead><tr><th>CMD index</th><th>type</th><th>argument</th><th>resp</th><th>abbr.</th><th>description</th></tr></thead><tbody><tr><td>CMD13</td><td>ac</td><td>[31:16] RCA<br/>[15] SQS<br/>[14:1] stuff bits<br/>[0] HPI</td><td>R1</td><td>SEND_QUEUE_STATUS（SQS）</td><td>SQS bit=1：表示这是一个 QSR查询。device应发送 QSR寄存器给 host。这种情况下，HPI必须为 0</td></tr><tr><td>CMD44</td><td>ac</td><td>[31] Reliable Write Request<br/>[30] DD: “1” read / “0” write<br/>[29] Tag request<br/>[28:25] Context ID<br/>[24]: Forced Programming<br/>[23] Priority: “0” simple / “1” high<br/>[22:21] reserved<br/>[20:16] Task ID<br/>[15:0] Number of Blocks</td><td>R1</td><td>QUEUED_TASK_PARAMS</td><td>bit [31] 可靠写请求，bit [30] 定义操作的方向，’1’ 读取 / ‘0’ 写入，bit [23] 优先级，bit [20:16] 任务 ID，bit [15:0] 任务队列的块计数</td></tr><tr><td>CMD45</td><td>ac</td><td>[31:0] Start block address</td><td>R1</td><td>QUEUED_TASK_ADDRESS</td><td>定义任务队列的起始块地址</td></tr><tr><td>CMD46</td><td>adtc</td><td>[31:21] reserved<br/>[20:16] Task ID<br/>[15:0] reserved</td><td></td><td>EXECUTE_READ_TASK</td><td>device执行对应任务 ID的读操作</td></tr><tr><td>CMD47</td><td>adtc</td><td>[31:21] reserved<br/>[20:16] Task ID<br/>[15:0] reserved</td><td>R1</td><td>EXECUTE_WRITE_TASK</td><td>device执行对应任务 ID的写操作</td></tr><tr><td>CMD48</td><td>ac</td><td>[31:21] reserved<br/>[20:16]: TaskID<br/>[15:4]: reserved<br/>[3:0] TM op-code (Table 5)</td><td>R1b</td><td>CMDQ_TASK_MGMT</td><td>device 丢弃特定任务或者整个队列<br/>当 bit [3:0] TM op-code = 0x2时，bit [20:16]表示 task id，当 TM op-code = 0x1时，bit [20:16]为保留，无意义。</td></tr></tbody></table><p>当 CQ使能时，数据传输仅支持 class 11命令集，CQ关闭时，数据传输不可用 class 11命令集，但可以使用 CMD18/CMD17和 CMD24/CMD25。不过 CQ使能时，还可以通过 Direct Command (DCMD)发送非数据传输命令，如：CMD0、CMD12、CMD13。</p><p>详细介绍可以看 6.6.39.2到 6.6.39.7和 6.6.39.9 Supported Commands或者参考 <a href="http://xxxdk.xyz/xxx/2020/11/eMMC%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/">eMMC命令简介</a>。</p><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><p>详见 B.4. CQE Registers</p><table><thead><tr><th></th><th>Symbol</th><th>Offset</th><th>descriptor</th></tr></thead><tbody><tr><td>CFG and CAP</td><td>CQVER</td><td>0x00</td><td>Command Queuing Version，RO，CQ版本寄存器，提供了eMMC CQ的版本信息，当前版本为 5.1，bit [11:8]=0x5，bit [7:4]=0x1，即 0x0510。</td></tr><tr><td></td><td>CQCAP</td><td>0x04</td><td>Command Queuing Capabilities，RO，CQ能力寄存器，描述 eMMC CQ的能力。<br/>Internal Timer Clock Frequency Multiplier（ITCFMUL） bit [15:12]，ITCFMUL与 ITCFVAL一起用于中断聚合的定时器和确定 SQS（CMD13）轮询周期的时钟频率。0x0 = 0.001 MHz、0x1 = 0.01 MHz、0x2 = 0.1 MHz、0x3 = 1 MHz、0x4 = 10 MHz。<br/>Internal Timer Clock Frequency Value（ITCFVAL） bit [9:0]，ITCFMUL与 ITCFVAL一起用于中断聚合的定时器和确定 SQS（CMD13）轮询周期的时钟频率。时钟频率计算方式为 ITCFMUL * ITCFVAL，例如 ITCFVAL = 0xc0（192 dec.），ITCFMUL = 0x2（0.1MHz），则时钟频率 f = 192 * 0.1 = 192.MHz。</td></tr><tr><td></td><td>CQCFG</td><td>0x08</td><td>Command Queuing Configuration，RW，CQ配置寄存器，用于使能 CQ、DCMD和配置任务描述符长度 64bits或是 128bits。<br/>Direct Command （DCMD） Enable bit [12]，用于告知 CQE，TDL的 slot 31的任务描述符是数据传输任务描述符（0x0）还是 Direct CMD任务描述符（0x1）；<br/>Task Descriptor Size bit [8]，描述任务描述符长度是 128bits（0x1）还是 64bits（0x0）；<br/>Command Queuing Enable bit [0]，软件将该 bit写 1则使能 CQE，软件写 1前应该确保 host控制器处于空闲状态，软件要退出 CQ，将 bit清零前也要确保清除所有任务。</td></tr><tr><td></td><td>CQCTL</td><td>0x0c</td><td>Command Queuing Control，CQ控制寄存器，软件用于 halt CQE取得总线控制权，或是在 recovery流程中清除所有 task。<br/>Clear All Tasks bit [8]，RWAC，当软件要清除发送到 device上的所有任务时，应将该 bit置位，且只有 CQE处于 halt状态（CQCTL.bit [0] = 1）时，才能写入该 bit。软件置位后，CQE会重置所有未完成任务的 CQTDBR和其他上下文信息，然后 CQE会清零该 bit。同时软件负责发送 CMDQ_TASK_MGMT（CMD48）命令 device丢弃队列中的任务，软件应该同时通知 device和 CQE但没有明确的顺序关系，只要 CQE处于 halt状态。如果软件需要恢复 CQE，只有该 bit为 0时，才可以清零 CQCTL.bit [0]，让 CQE恢复正常操作。<br/>Halt bit [0]，R/W，软件想获取总线控制权并禁止 CQE在总线上发出命令时，应将该 bit写 1。例如，当软件写 1 halt CQE后发出 CMDQ_TASK_MGMT（CMD48）命令，如果任务正在进行，CQE应该完成正在进行的任务。一旦任务完成且 CQE处于空闲状态，CQE不得发出新的命令，且 CQE应设置该 bit为 1。软件可以轮询该 bit，等待 CQE将该 bit置位，表明 CQE释放了总线。软件将该 bit写 0则 CQE退出 halt状态，bit已为 0时，写 0无效。</td></tr><tr><td>Interrupt Control</td><td>CQIS</td><td>0x10</td><td>Command Queuing Interrupt Status，RW1C，CQ中断状态寄存器，描述触发中断的事件，当前只有bit [3:0]，且需要 CQISTE也配置对应的 bit才有效。<br/>Task Cleared（TCL） bit [3]，当清除单个或全部任务完成时置位；<br/>Response Error Detected Interrupt（RED） bit [2]，当 response中 device status设置了错误位时置位，软件可以配置 CQRMEM来使能哪些 device status bit可以触发中断；<br/>Task Complete Interrupt（TCC） bit [1]，当一个任务完成或是聚合中断触发时置位；<br/>Halt Complete Interrupt（HAC） bit [0]，当 CQ进入 halt状态时置位。</td></tr><tr><td></td><td>CQISTE</td><td>0x14</td><td>Command Queuing Interrupt Status Enable，RW，CQ中断状态使能寄存器，该寄存器用于使能或者禁用向软件上报 CQIS的中断事件，每个 bit都与 CQIS的 bits匹配。</td></tr><tr><td></td><td>CQISGE</td><td>0x18</td><td>Command Queuing Interrupt Signal Enable，RW，CQ中断信号使能寄存器，该寄存器用于使能或者禁用 CQIS的中断事件产生，每个 bit都与 CQIS的 bits匹配。</td></tr><tr><td></td><td>CQIC</td><td>0x1c</td><td>Command Queuing Interrupt Coalescing，CQ中断聚合寄存器，该寄存器用于控制中断聚合。<br/>Interrupt Coalescing Enable/Disable bit [31]，RW，软件设置该 bit为 0时，命令响应不计数与不定时，中断继续由任务描述符中 INT=1的任务完成后触发，设置为 1时，使能中断聚合，并生成聚合中断；<br/>Interrupt Coalescing Status Bit（ICSB） bit [20]，RO，当 INT=0的任务完成并计数到中断聚合，即 IC count &gt; 0时置位；<br/>Counter and Timer Reset（ICCTR） bit [16]，WO，软件把该 bit写 1时，中断聚合定时器和计数器复位；<br/>Interrupt Coalescing Counter Threshold Write Enable（ICCTHWEN） bit [15]，WO，该 bit软件写 1时，可以更新 ICCTH的值，只有任务队列为空时才可写 1；<br/>Interrupt Coalescing Counter Threshold（ICCTH） bit [12:8]，RW，软件配置该字段用于设置产生中断所需的任务（INT=0）完成数，最大为 31，CQE负责计数，到达配置值后停止计数，软件负责计数器（ICCTR）复位，该字段为 0时，CQE不计数；<br/>Interrupt Coalescing Timeout Value Write Enable （ICTOVALWEN） bit [7]，WO，该 bit软件写 1时，才可以更新 ICTOVAL的值，只有任务队列为空时才可写 1；<br/>Interrupt Coalescing Timeout Value（ICTOVAL） bit [6:0]，软件设置此字段来配置完成总线上的任务到生成中断允许的最长时间，软件负责定时器的（ICCTR）复位，复位定时器后，当数据传输任务（INT=0）完成时开始定时，到达配置值后停止定时并生成中断，定时器单位是 CQCAP描述的频率的时钟的 1024个时钟周期，最小值 0x01（1*1024时钟周期），最大值 0x7f（127*1024时钟周期），具体计算方法见协议，该字段为 0时，定时器不运行。</td></tr><tr><td>Task Submission</td><td>CQTDLBA</td><td>0x20</td><td>Command Queuing Task Descriptor List Base Address，RW，CQ任务描述符列表（TDL）基址寄存器，该寄存器储存任务描述符列表头（TDL）的低 32位地址，且分配的内存地址应该 1k对齐，即低 10 bits软件应该设置为 0，且 CQE应该忽略低 10bits数值，而TDL的大小为 32 *（任务描述符大小 + 传输描述符大小）。</td></tr><tr><td></td><td>CQTDLBAU</td><td>0x24</td><td>Command Queuing Task Descriptor List Base Address Upper 32 bits，RW，CQ任务描述符列表（TDL）基址寄存器，该寄存器储存任务描述符列表头（TDL）的高 32位地址，使用 32位寻址模式时，该寄存器为保留不用。</td></tr><tr><td></td><td>CQTDBR</td><td>0x28</td><td>Command Queuing Task Doorbell，RW1S，CQ任务门铃寄存器，该寄存器用于软件触发 CQE处理对应的任务，这个动作一般叫敲门铃，当然软件应该先配置 TDLBA和 TDLBAU并在 CQCFG中使能 CQE。<br/>软件将 1写入该寄存器 bit n会触发 CQE处理 TDL中对应的 slot n任务，软件可以同时对多个 bit写 1，实现批量提交，CQE处理批量提交时，会从最小的 task id（slot n）开始。如果有一个或多个任务 QBR置位，则处理顺序应该按照 QBR流程，详见 B.2.6. Queue-Barrier (QBR) Tasks。<br/>软件写 0对 CQE不会有任何影响，也不会改变寄存器的值。<br/>CQE被触发后会读取任务描述符，并向 device发送 QUEUED_TASK_PARAMS（CMD44）和QUEUED_TASK_ADDRESS（CMD45）<br/>如果是 DCMD任务（ slot 31使能），CQE会根据任务描述符中的 CMD index和参数生成命令并在 CMD line发出。<br/>以下事件中，CQE会将相应 bit清 0：1、任务完成，不管成功或错误；2、使用 CQTCLR清除任务；3、使用 CQCTL清除所有任务；4、CQCFG中禁用了 CQE。</td></tr><tr><td></td><td>CQTCN</td><td>0x2c</td><td>Command Queuing Task Completion Notification，RW1C，CQ任务完成通知寄存器，当任务（task id=n）完成（成功或错误），CQE会置位该寄存器 bit n并清零 CQTDBR bit n。软件收到任务完成中断后，读取该寄存器以确定哪些任务已经完成，软件负责将已经完成的任务对应的 bit写 1清零。</td></tr><tr><td>Task Management</td><td>CQDQS</td><td>0x30</td><td>Command Queuing Device Queue Status，RO，device队列状态寄存器，该寄存器储存着 device队列状态最新值，host通过 CMD13获取 device的 QSR后，都会用 QSR的值更新到本寄存器，如果 DCMD使能，则由 CQE负责更新本寄存器。</td></tr><tr><td></td><td>CQDPT</td><td>0x34</td><td>Command Queuing Device Pending Tasks，RO，CQ任务挂起寄存器，该寄存器表示哪些任务在 device中排队等待执行。当 CQE为任务（task id=n）发送了QUEUED_TASK_PARAMS（CMD44）和QUEUED_TASK_ADDRESS（CMD45）且收到了 CMD45的成功响应但未发送 EXECUTE_WRITE_TASK（CMD47）或 CMDQ_TASK_MGMT（CMD48）执行任务时，CQE会置位该寄存器的 bit n，CQE在任务（task id=n）执行完成后会清除对应的 bit n。<br/>当 CQE halt住时，软件需要在任务丢弃过程中读取该寄存器，以确定是否有任务在 device中排队，如果有则软件应该发送 CMDQ_TASK_MGMT（CMD48）让 device放弃任务，同时软件会清除 CQE中的任务。只有这样才能在软件恢复 CQE的时候，将CQCTL.halt（bit [0]）写 0。</td></tr><tr><td></td><td>CQTCLR</td><td>0x38</td><td>Command Queuing Task Clear，RW，CQ单任务清除寄存器，该寄存器用于清除 CQE中单个未完成的任务。只有 CQE处于 halt状态才可使用。当软件置位该寄存器的 bit n时，CQE会将该 bit n置为 1（CQE才有权限实际更新该寄存器值），并开始清除对应任务的相关数据结构，清除完成后，CQE会清零 CQTCLR和 CQTDBR中对应的 bit n。软件应该轮询 CQTCLR，直到 CQE完成清除操作。软件将 0写入该寄存器不会有影响。<br/>同样软件操作该寄存器只影响 CQE，device中的任务还需要软件按照流程发送 CMDQ_TASK_MGMT（CMD48）。<br/>软件不应该使用该寄存器清除多个任务，应该使用 CQCTL寄存器来清除多个任务。</td></tr><tr><td>SQS and DCMD</td><td>CQSSC1</td><td>0x40</td><td>Command Queuing Send Status Configuration 1，RW，CQSQS配置寄存器1，该寄存器控制何时发送 SEND_QUEUE_STATUS（CMD13）查询 device 任务队列的状态。<br/>Send Status Command Block Counter（CBC） bit [19:16]，该字段配置 CQE何时发送 SEND_QUEUE_STATUS（CMD13）查询 device 任务队列的状态，CQE应该在 CMD线上发送 SQS。该字段值为 n，表示 CQE应该在块数量为 BLOCK_CNT - n期间发送 SQS，BLOCK_CNT是指当前这笔传输的块数量；该字段值为 0，表示在数据传输期间，不应该发送 SEND_QUEUE_STATUS（CMD13），只在 DATA线空闲时发送；该字段值为 1，表示 SQS将在这笔传输的最后一个块期间发送。<br/>Send Status Command Idle Timer（CIT） bit [15:0]，该字段配置 CQE周期性发送 SEND_QUEUE_STATUS（CMD13）所使用的轮询周期。<em>Periodic polling is used when tasks are pending in the device, but no data transfer is in progress. When a SEND_QUEUE_STATUS response indicating that no task is ready for execution, CQE counts the configured time until it issues the next SEND_QUEUE_STATUS.</em> <strong>注1</strong><br/>定时器的时钟周期，其频率已经在 CQCAP（ITCFMUL * ITCFVAL）中确定，最小值是 0x1（1个时钟周期），最大值是 0xffff（65535个时钟周期），默认值是 4096个时钟周期。例如，ITCFMUL * ITCFVAL = 19.2MHz，即周期为 52.08ns，如果 CQSSC1.CIT = 0x1000（4960 dec.），则 SQS的轮询周期为 4096 * 52.08ns = 213.33us。<br/><strong>注1：</strong>在 CIT的介绍中，协议原文比较晦涩难懂，原本是翻译如下，<em>当 SQS的 response表示 device中有任务等待执行，但没有进行数据传输时，CQE定时轮询发送 SQS。device没有任务可供执行时，CQE开始定时，直到它发出下一个 SQS。</em>但还是觉得不妥。翻阅协议，在 B.2.3. Task Selection and Execution - Reading the QSR，获得了清晰明了的说明。当有任务在 device中排队时（等待执行），CQE发送 SEND_QUEUE_STATUS（CMD13）获取 QSR以确定哪些任务准备好执行。如果此时正在进行数据传输，则 CQE根据 CQSSC1.CBC的配置，在数据传输的末尾发送 SQS。如果此时总线空闲，则 CQE根据 CQSSC1.CIT的配置周期性的发送 SQS。</td></tr><tr><td></td><td>CQSSC2</td><td>0x44</td><td>Command Queuing Send Status Configuration 2，RW，CQSQS配置寄存器2，该寄存器用于配置 SQS argument中的 RCA。<br/>Send Queue Status RCA bit [15:0]，配置 CQE发送 SEND_QUEUE_STATUS（CMD13）argument中 16位的 RCA，即 argument bit [31:16]。</td></tr><tr><td></td><td>CQRDCT</td><td>0x48</td><td>Command Queuing Command Response for Direct-Command Task，RO，CQ直接命令响应寄存器，该寄存器储存着 CQE最后接收到 direct-command（DCMD）任务的 response，CQE应该在每次收到命令的响应后更新该寄存器，且只有在 CQE清零 CQTDBR的 bit31，该寄存器才被认为有效。</td></tr><tr><td>Error handing</td><td>CQRMEM</td><td>0x50</td><td>Command Queuing Response Mode Error Mask，RW，CQ命令响应错误掩码寄存器，该寄存器控制 Response Error Detection（RED）中断的生成，即作为 R1/R1b响应中接收的 device状态的中断掩码。<br/>bit n = 1对应 device状态中对应的 bit n为 1时能触发 RED中断，为 bit n = 0时则被忽略。该寄存器的默认值为 0xFDF9A080，即能触发 device状态中所有错误类型的 RED中断，具体错误类型可以查看 Table 68 — Device status。<br/> 对于 CMD13（SQS）的响应 QSR，逻辑（CQE）应该忽略。</td></tr><tr><td></td><td>CQTERRI</td><td>0x54</td><td>Command Queuing Task Error Information，RO，CQ任务错误信息寄存器，该寄存器会在任务相关数据或者命令出现错误的时候由 CQE进行更新。不管是 CQE还是 device上报的，CQE会将错误发生时在 CMD线和 DATA线上执行的 CMD index和 task id储存在 CQTERRI中，并在错误恢复流程中使用，具体见 B.2.8. Error Detection and Recovery。<br/>Data Transfer Error Fields Valid bit [31]，当 CQE检测到错误或者 device上报错误，该 bit将会更新。如果正在进行数据传输出问题则 bit [31] = 1，<em>如果出问题时是无数据传输则 bit [31] = 0</em>。<strong>注1</strong><br/>Data Transfer Error Task ID bit [28:24]，如果出现错误且正在进行数据传输（CQTERRI.bit [31] = 1），CQE应更新该字段，将 DATA线上执行的 task id存储于此。<br/>Data Transfer Error Command Index bit [21:16]，如果出现错误且正在进行数据传输（CQTERRI.bit [31] = 1），CQE应更新该字段，将发生错误时在 DATA线执行的 CMD index存储于此。根据数据方向，CMD index不是 EXECUTE_READ_TASK（CMD46）就是 EXECUTE_WRITE_TASK（CMD47）。<br/>Response Mode Error Fields Valid bit [15]，当 CQE检测到错误或者 device上报错误，该 bit将会更新。如果正在进行命令传输出问题则 bit [15] = 1，<em>如果出问题时是无命令传输则 bit [15] = 0</em>。<strong>注2</strong><br/>Response Mode Error Task ID bit [12:8]，如果出现错误且正在进行命令传输（CQTERRI.bit [15] = 1），CQE应更新该字段，将 CMD线上执行的 task id存储于此。<br/>Response Mode Error Command Index bit [5:0]，如果出现错误且正在进行命令传输（CQTERRI.bit [15] = 1），CQE应更新该字段，将 CMD线上执行的 CMD index存储于此。<br/><strong>注1、注2：</strong>协议此处说得比较模糊，结合 Data Transfer Error Task ID、Data Transfer Error Command Index和 Response Mode Error Task ID、Response Mode Error Command Index，可以理解为只有 bit [31] = 1时，Data Transfer Error Task ID、Data Transfer Error Command Index有效或 bit [15] = 1时，Response Mode Error Task ID、Response Mode Error Command Index有效，bit [31]或 bit [15]为 0时，上述字段是无效的。</td></tr><tr><td></td><td>CQCRI</td><td>0x58</td><td>Command Queuing Command Response Index，RO，CQ命令索引寄存器，该寄存器储存着 CQE最后接收到的是哪个命令（CMD index），CQE应该在每次收到命令的响应后更新该寄存器。</td></tr><tr><td></td><td>CQCRA</td><td>0x5c</td><td>Command Queuing Command Response Argument，RO，CQ命令响应寄存器，该寄存器储存着 CQE最后接收到的 response，CQE应该在每次收到命令的响应后更新该寄存器。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eMMC</tag>
      
      <tag>mmc</tag>
      
      <tag>CMDQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eMMC识别流程简介</title>
    <link href="/xxx/2021/04/eMMC%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B/"/>
    <url>/xxx/2021/04/eMMC%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>之前文章介绍了 Boot mode，<a href="http://xxxdk.xyz/xxx/2021/02/eMMC%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F-Boot-mode/">eMMC操作模式-Boot mode</a>，这次介绍 <strong>Device identification mode</strong>和 <strong>Data transfer mode</strong>，即 Normal mode。</p><p>Normal mode涉及到的速度模式主要包括：High-speed、HS200和 HS400。</p><h4 id="Device-identification-mode"><a href="#Device-identification-mode" class="headerlink" title="Device identification mode"></a>Device identification mode</h4><p>1、<strong>Power-up</strong>，向器件 VCC（3.3V）和 VCCQ（3.3V / 1.8V）提供电源。设置时钟最大到 400KHz，host等待 74 clock cycles或者是电源电压上升至 3.3V，最大等待 1ms；</p><p><img src="http://pic.xxxdk.xyz/eMMC%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-Power-up.webp" alt="Power-up"></p><p>2、<strong>进入 Idle State</strong>，Power on后有 4种情况进入 Idle State：a. Boot mode完成后，b. Pre-boot state下 CMD拉低的时间少于 74 clock cycle或 Boot sequence失败，c. EXT_CSD[179] BOOT_PARTITION_ENABLE = 0，d. host发送 GO_PRE_IDLE_STATE（CMD0 with 0xF0F0F0F0）；</p><p><img src="http://pic.xxxdk.xyz/eMMC%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-Device%20identification%20mode.webp" alt="Device identification mode"></p><p>3、<strong>访问模式确认</strong>，CMD1，host发送 CMD1（SEND_OP_COND），参数为 OCR寄存器，device并不需要理会里面的电压相关值，bit [23:7]。host会不断的发送 CMD1，直到 device完成初始化，容量小于或等于 2GB的 device会返回 R3 = 0x80FF8080，容量大于 2GB的 device返回 R3 = 0xC0FF8080，并且 device将会进入 Ready State；</p><p>循环的最后一次交互是有意义的，用于双方确认访问模式 bit [30:29] Access Mode，host不支持 Sector access Mode而 device只能使用该模式，则 device进入 Inactive State；</p><p>4、<strong>获取 CID</strong>，CMD2，host发送 CMD2（ALL_SEND_CID）获取 device的 CID，device进入Identification State；</p><p>5、<strong>分配 RCA</strong>，CMD3，host发送 CMD3（SET_RELATIVE_ADDR）给 device分配一个 RCA，device进入 Standy-by State，kernel一般分配是从 0x1开始的。</p><p>完成 Device identification mode后，device处于 Backward Compatible，即 DS速度模式。</p><h4 id="Data-transfer-mode"><a href="#Data-transfer-mode" class="headerlink" title="Data transfer mode"></a>Data transfer mode</h4><p>1、<strong>读取 CSD寄存器</strong>，CMD9，host不知道 device的 CSD寄存器值前，fpp（Clock frequency Data Transfer Mode，详见 Table 208，下图）应该要小于等于 fod（400KHz），host 发送 CMD9（SEND_CSD）获取 CSD寄存器，根据返回的信息对 host参数进行调整。例如，通过 TRAN_SPEED确定 device支持的最大时钟频率 fpp，CCC确定是否支持 CMD6（SWITCH）和 CMD8（SEND_EXT_CSD）；</p><p><img src="http://pic.xxxdk.xyz/eMMC%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-High-speed%20Device%20interface%20timing.webp" alt="High-speed Device interface timing"></p><h5 id="High-speed识别流程"><a href="#High-speed识别流程" class="headerlink" title="High-speed识别流程"></a>High-speed识别流程</h5><p><img src="http://pic.xxxdk.xyz/eMMC%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-High%20speed%20Selection%20flow%20diagram.webp" alt="High speed Selection flow diagram"></p><p>2、<strong>发送选卡命令</strong>，CMD7，host发送 CMD7，device进入 Transfer State，如果 device返回了 R1b响应，bit25 DEVICE_IS_LOCKED = 1，则 device已经锁定，需要在下一步操作前发送 CMD42解锁 device；</p><p>3、<strong>获取 EXT_CSD寄存器</strong>，CMD8，host发送 CMD8（SEND_EXT_CSD）获取 EXT_CSD寄存器，根据 EXT_CSD[196] DEVICE_TYPE，确认 device在 HS模式下的最高时钟频率；</p><p>4、<strong>切换到 high speed模式</strong>，CMD6，host发送 CMD6（SWITCH）将 EXT_CSD[185]  HS_TIMING的值设置为 0x1，device返回 R1b响应，host需要等待 BUSY signal（DAT0为低）解除，device从 BUSY恢复后，速度模式已经为 high speed（一定不能用 CMD13确认 device状态，uboot 2020掉过的坑）；</p><p><img src="http://pic.xxxdk.xyz/eMMC%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-HS_TIMING%20Interface%20values.webp" alt="HS_TIMING Interface values"></p><p>5、<strong>切换时钟频率</strong>，host将自身的时钟频率切换到最大不超过 26/52MHz/TRAN_SPEED；</p><p>6、<strong>设置电源等级</strong>，CMD6，host发送 CMD6（SWITCH）将 EXT_CSD[187]  POWER_CLASS的值设置为 host能为 device提供的最大能力值；</p><p>7、<strong>切换总线宽度</strong>，CMD6，host发送 CMD6（SWITCH）将 EXT_CSD[183]  BUS_WIDTH的 bit [3:0]值设置所需的宽度，0x1为 4-bit，0x2为 8-bit。</p><p><img src="http://pic.xxxdk.xyz/eMMC%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-BUS_WIDTH.webp" alt="BUS_WIDTH"></p><h5 id="HS200识别流程"><a href="#HS200识别流程" class="headerlink" title="HS200识别流程"></a>HS200识别流程</h5><p><img src="http://pic.xxxdk.xyz/eMMC%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-HS200%20Selection%20flow%20diagram.webp" alt="HS200 Selection flow diagram"></p><p>8、<strong>发送选卡命令</strong>，CMD7，host发送 CMD7，device进入 Transfer State，如果 device返回了 R1b响应，bit25 DEVICE_IS_LOCKED = 1，则 device已经锁定，需要在下一步操作前发送 CMD42解锁 device；</p><p>9、<strong>host IO电压确认</strong>，HS200 IO（VCCQ）只支持 1.8V/1.2V电压，host需要能提供相关电压；</p><p>10、<strong>获取 EXT_CSD寄存器</strong>，CMD8，host发送 CMD8（SEND_EXT_CSD）获取 EXT_CSD寄存器，根据 EXT_CSD[196] DEVICE_TYPE，确认 device是否支持 HS200和 IO电压；</p><p><img src="http://pic.xxxdk.xyz/eMMC%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-DEVICE_TYPE.webp" alt="DEVICE_TYPE"></p><p>11、<strong>切换总线宽度</strong>，CMD6，host发送 CMD6（SWITCH）将 EXT_CSD[183]  BUS_WIDTH的 bit [3:0]值设置所需的宽度，0x1为 4-bit，0x2为 8-bit。</p><p>12、<strong>读取设备支持的驱动能力</strong>，查询 EXT_CSD[197] DRIVER_STRENGTH，获得 device支持的驱动能力；</p><p>13、<strong>切换到 HS200模式</strong>，CMD6，host发送 CMD6（SWITCH）将 EXT_CSD[185]  HS_TIMING的 bit[3:0]设置为 0x2，bit[7:4] Driver Strength根据实际情况确定是否修改。device返回 R1b响应，host需要等待 BUSY signal（DAT0为低）解除；</p><p>14、<strong>查询状态</strong>，CMD13，host发送 CMD13（SEND_STATUS），device返回 R1响应，host确认 device已经处于 Transfer State且无错误状态，则表示速度模式成功切为 HS200；</p><p>15、<strong>切换时钟频率</strong>，host将自身的时钟频率切换到最大不超过 200MHz；</p><p>16、<strong>tuning of sampling point</strong>，CMD21，采样点优化，host将不同的采样相位设置给数字逻辑并发送 CMD21，从而确认最佳的采样相位，host可以在 CMD21失败的情况下发送 CMD12去停止该笔传输，再发送下一个采样点的 CMD21；</p><p>17、到此 HS200的识别流程就走完了。</p><h5 id="HS400识别流程"><a href="#HS400识别流程" class="headerlink" title="HS400识别流程"></a>HS400识别流程</h5><p><img src="http://pic.xxxdk.xyz/eMMC%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-HS400%20Selection%20flow%20diagram.webp" alt="HS400 Selection flow diagram"></p><p>18、HS400是在 HS200完成的基础上进行的，HS400 IO只支持 1.8V/1.2V电压，总线宽度只支持 DDR 8bit；</p><p>19、<strong>获取 EXT_CSD寄存器</strong>，CMD8，host发送 CMD8（SEND_EXT_CSD）获取 EXT_CSD寄存器，根据 EXT_CSD[196] DEVICE_TYPE，确认 device是否支持 HS400和 IO电压，这步在 linux中可能是在步骤 10阶段完成；</p><p>20、<strong>切换到 high speed模式</strong>，CMD6，host发送 CMD6（SWITCH）将 EXT_CSD[185]  HS_TIMING的值设置为 0x1；</p><p>21、<strong>切换时钟频率</strong>，切换时钟频率到小于或等于 52MHz；</p><p>22、<strong>切换总线宽度</strong>，CMD6，host发送 CMD6（SWITCH）将 EXT_CSD[183]  BUS_WIDTH的 bit [3:0]值设置为 0x6，DDR 8-bit；</p><p>23、<strong>读取设备支持的驱动能力</strong>，查询 EXT_CSD[197] DRIVER_STRENGTH，获得 device支持的驱动能力；</p><p>24、<strong>切换到 HS400模式</strong>，CMD6，host发送 CMD6（SWITCH）将 EXT_CSD[185]  HS_TIMING的 bit[3:0]设置为 0x3，bit[7:4] Driver Strength根据实际情况确定是否修改，device返回 R1b响应，host需要等待 BUSY signal（DAT0为低）解除；</p><p>25、<strong>查询状态</strong>，CMD13，host发送 CMD13（SEND_STATUS），device返回 R1响应，host确认 device已经处于 Transfer State且无错误状态，则表示速度模式成功切为 HS400；</p><p>26、<strong>切换时钟频率</strong>，host将自身的时钟频率切换到最大不超过 200MHz；</p><p>27、因为采样相位使用的是 HS200的，所以 HS400就不用 tuning，到此 HS400的识别流程就走完了。</p><h5 id="HS400ES识别流程"><a href="#HS400ES识别流程" class="headerlink" title="HS400ES识别流程"></a>HS400ES识别流程</h5><p>28、HS400ES即 HS400 Enhanced Strobe，HS400模式，引入了 Data Strobe线，使得数字逻辑在 Data Out、CRC response上不依赖 tuning流程就可以确认最佳采样相位，但 CMD Response没有这个机制，Enhanced Strobe就是用来弥补这个事情的。</p><p><img src="http://pic.xxxdk.xyz/eMMC%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-HS400ES%20Selection%20flow%20diagram.webp" alt="HS400ES Selection flow diagram"></p><p>29、<strong>发送选卡命令</strong>，CMD7，上接步骤 “1、读取 CSD寄存器”，host发送 CMD7，device进入 Transfer State，如果 device返回了 R1b响应，bit25 DEVICE_IS_LOCKED = 1，则 device已经锁定，需要在下一步操作前发送 CMD42解锁 device；</p><p>30、<strong>获取 EXT_CSD寄存器</strong>，CMD8，host发送 CMD8（SEND_EXT_CSD）获取 EXT_CSD寄存器，根据 EXT_CSD[196] DEVICE_TYPE，确认 device是否支持 HS400和对应的 IO工作电压；</p><p>31、<strong>确认是否支持 Enhanced Strobe</strong>，根据 EXT_CSD[184] STROBE_SUPPORT，确认 device是否 Enhanced Strobe，支持为 0x1；</p><p>32、<strong>切换到 high speed模式</strong>，CMD6，host发送 CMD6（SWITCH）将 EXT_CSD[185]  HS_TIMING的值设置为 0x1；</p><p>33、<strong>切换时钟频率</strong>，切换时钟频率到小于或等于 52MHz；</p><p>34、<strong>切换总线宽度</strong>，CMD6，host发送 CMD6（SWITCH）将 EXT_CSD[183]  BUS_WIDTH的 bit [7]值设置为 0x1，bit [3:0]值设置为 0x6，使能 Enhanced Strobe和 DDR 8-bit；</p><p>35、<strong>读取设备支持的驱动能力</strong>，查询 EXT_CSD[197] DRIVER_STRENGTH，获得 device支持的驱动能力；</p><p>36、<strong>切换到 HS400模式</strong>，CMD6，host发送 CMD6（SWITCH）将 EXT_CSD[185]  HS_TIMING的 bit[3:0]设置为 0x3，bit[7:4] Driver Strength根据实际情况确定是否修改，device返回 R1b响应，host需要等待 BUSY signal（DAT0为低）解除；</p><p>37、<strong>切换时钟频率</strong>，host将自身的时钟频率切换到最大不超过 200MHz；</p><p>38、HS400 Enhanced Strobe的识别流程也介绍了。</p><p>详细的流程详见 6.6.2  High-speed modes selection和 A.6  High-speed e•MMC bus functions，以及 Linux和 u-boot的代码，毕竟有很多兼容性的点是协议不会描述的。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eMMC</tag>
      
      <tag>mmc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SD卡识别流程简介</title>
    <link href="/xxx/2021/03/SD%E5%8D%A1%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B/"/>
    <url>/xxx/2021/03/SD%E5%8D%A1%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>SD卡速度模式描述众多，命名让人觉得极其混乱，USB在它面前不过是小巫见大巫。从容量角度出发，SDSC、SDHC、SDXC和 SDUC；从速度角度出发，<strong>Default Speed</strong>、<strong>High Speed</strong>、Speed Class 2/4/6/10、<strong>UHS-I/UHS-II</strong>（UHS Speed Grade 3：U1/U2/U3）、Video Speed Class V4/6/10/30/60/90、Application Performance Class A1/A2、<strong>PCIe 4.0 single lane/PCIe 4.0 dual lane/PCIe 3.1 dual lane</strong>。</p><p>我们也可以从厂商的商品介绍大概了解一下，该 SD卡是支持 UHS-II mode的 SDXC卡。</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-KIOXIA_SD_Card.webp" alt="KIOXIA SD Card"></p><p>*某东价格：2459元，对老法师来说这个价格不算贵，该 SD卡不仅拥有众多奇奇怪怪的图标，连管脚都多人 8根，真是金闪闪。</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-UHS-II_PIN.webp" alt="UHS-II PIN"></p><p>虽然很混乱，但幸运的是消费类市场上，最高速度一般是 UHS-I，属于低速信号，软件 debug比较方便。也正是规格要求低，各种各样的白牌卡一堆，都是些省成本的幺蛾子。</p><p>在混乱中，我们只要了解 Default Speed、High Speed和 UHS-I（SDR12、SDR25、SDR50、DDR50和 SDR104），就可以在遇到识别问题时心中不慌，有条理的解决问题。</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-UHS-I_Host_Init_Flow.webp" alt="UHS-I Host Init Flow Chart"></p><p>上图是 UHS-I Host的初始化流程图，SD卡识别流程（SD mode）也是基于该图进行介绍，详细说明请看 4.  SD Memory Card Functional Description。</p><p><strong>1）Power On</strong>，host为卡提供工作电压，一般是 3.3V，当电压上升到 2.7V，卡开始初始化，host需要等待最大 1ms或者 74个 clock cycle（400KHz），具体如下图；</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-Power-up.webp" alt="Power-up"></p><p><strong>2）设置卡进入 Idle State</strong>，CMD0，卡初始化完成后，host发送 CMD0让卡进入 Idle State；</p><p><strong>3）发送接口条件命令</strong>，CMD8，卡已经处于 Idle State，host发送 CMD8确认卡是否支持 host当前提供的工作电压，卡通过 R7响应，不支持则不响应，继续走流程；</p><p><strong>4）发送初始化命令</strong>，ACMD41，host反复的发送 ACMD41（HSC=1 / Host Capacity Support和 S18R=1 / Switching to 1.8 Request）（只有第一个 ACMD41的参数是有效的，但后续的 ACMD41也应该使用相同的参数发送），直到卡响应的 R3的 bit31=1，表示卡初始化完成后，host检测 CCS（Card Capacity Status）和 S18A（Switching to 1.8 Accepted），S18A=1表示卡支持切换工作电压到 1.8V，CCS=1表示卡为 SDHC or SDXC；</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-ACMD41_Voltage_Switch_Sequence.webp" alt="ACMD41 Voltage Switch Sequence"></p><p><strong>5）发送电压切换命令</strong>，CMD11，S18A=1则 host发送 CMD11，卡返回 R1响应，host开始切换电压，当 host检测到卡的 DAT[3:0]任意管脚为高电平，则电压切换成功，此时卡进入 UHS-I模式，默认总线速度模式为 SDR12；</p><p><strong>6）获取 CID</strong>，CMD2，host发送 CMD2获取卡的 CID，卡返回 R2响应；</p><p><strong>7）获取 RCA</strong>，CMD3，host发送 CMD3获取卡发布的 RCA，host可以多次发送 CMD3要求卡发布新的 RCA；</p><p><strong>8）发送选卡命令</strong>，CMD7，host发送 CMD7，卡进入 Transfer State，如果卡返回了 R1b响应，bit25 CARD_IS_LOCKED=1，则卡已经锁定，需要在下一步操作前发送 CMD42解锁卡；</p><p><strong>9）设置总线带宽</strong>，ACMD6，UHS-I仅支持 4bit模式，host通过 ACMD6选择总线工作在 4bit模式；</p><p><strong>10）设置驱动强度</strong>，CMD6，host通过 CMD6设置 Driver Strength（Function Group 3），默认是 Type-B，具体值见下图 Available Functions；</p><p><strong>11）设置具体 UHS-I模式和对应的电流限制</strong>，CMD6，host通过 CMD6设置 Bus Speed Mode（Function Group 1），Current Limit（Function Group 4），具体值见下图 Available Functions；</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-Available%20Functions.webp" alt="Available Functions"></p><p><strong>12）tuning of sampling point</strong>，CMD19，采样点优化，在 SDR50和 SR104模式中 host通过发送 CMD19确认最优的采样点，在兼容性方面，host可以在 CMD19失败的情况下发送 CMD12去停止该笔传输，再发送下一个采样点的 CMD19；</p><p>13）后面 host就可以正常的与卡进行数据交互了；</p><p>14）对于步骤 4），CCS=0表示卡为 SDSC，直接跳到步骤 6）完成后续流程，SDSC的卡不支持 UHS-I模式，S18A=0表示卡只工作在 3.3V电压，除了跳过切换电压步骤，后续流程与正常的 UHS-I识别流程一样。</p><p>Power Cycle，是指 host执行 Power-off –&gt; Power-up的操作，并保持 1ms以上，即 VDD掉电再重新上电。一般保持的时间需要根据具体硬件确定，可以通过示波器测量 VDD跌落至 0.5V的时间，不过测量跌落到 0V的时间最保险。</p><p>详细的 1）Power On到 7）获取 RCA流程，可以查看协议 Figure 4-2: Card Initialization and Identification Flow (SD mode)。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mmc</tag>
      
      <tag>sd card</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eMMC操作模式-Boot mode</title>
    <link href="/xxx/2021/02/eMMC%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F-Boot-mode/"/>
    <url>/xxx/2021/02/eMMC%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F-Boot-mode/</url>
    
    <content type="html"><![CDATA[<p>协议定义了五种操作模式：</p><p><strong>Boot mode</strong>，device 在 power on、接收到参数为 0xF0F0F0F0的 CMD0或者是硬件重置后会进入 Boot mode。</p><p><strong>Device identification mode</strong>，在 Boot mode完成后或者 host与 device不支持 Boot mode，则 device会进入 Device identification mode。device会一直处于该状态，直到收到 SET_RCA（CMD3）命令。</p><p><strong>Interrupt mode</strong>，host与 device进入或者退出 Interrupt mode是同步的，在 interrupt mode不会有数据传输，唯一允许的是消息是来自 device或者是 host的中断服务请求。</p><p><strong>Data transfer mode</strong>，分配 RCA后，device会进入 Data transfer mode。host会在识别总线上的 device后进入 Data transfer mode。</p><p><strong>Inactive mode</strong>，如果 device的工作电压范围或是访问模式无效（OCR相关），那 device将会进入 Inactive mode。或者给 device发送 GO_INACTIVE_STATE（CMD15）命令，device将会重置，进行 power cycle到 Pre-idle状态。</p><p>下图是 Device state、Operation mode和 CMD line mode之间的关系。</p><p><img src="http://pic.xxxdk.xyz/eMMC%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F-Boot%20mode-dependencies.webp" alt="dependencies"></p><p>本文主要介绍 Boot mode。</p><h4 id="Boot-mode"><a href="#Boot-mode" class="headerlink" title="Boot mode"></a>Boot mode</h4><p>device在 boot mode有两种状态，Pre-Idle State和 Pre-Idle State，状态机中还有 Boot State。</p><p><strong>Pre-Idle State</strong>，device有三种方式进入 Pre-Idle State。(1) power on后；(2) host发送 GO_PRE_IDLE_STATE（CMD0 with 0xF0F0F0F0）命令对 device进行软件重置；(3) 有效的硬件重置（RST_n上升沿触发），具体信号波形查看 Figure 65 — H/W reset waveform。在 power on场景，device内部可能还处于初始化阶段，无法检测到 RST_n信号，但 power on流程已经保证 device内部会进行初始化，而且 device需要在 1s内完成初始化。在这种场景，初始化延时应最长为 1ms或 RST_n完成后 74 clock cycle或是电源上升时间中的最大者。RST_n信号是否有效需要从 EXT_CSD [162]，RST_n_FUNCTION确认。</p><p><strong>Pre-Boot State</strong>，device进入 Pre-Idle State后，如果 BOOT_PARTITION_ENABLE为1，则进入 Pre-Boot State。</p><p><strong>Boot State</strong>，host将 CMD线拉低至少 74 clock cycles则 device从 Pre-Boot State进入 Boot state，处于 Original Boot Mode（常用）；host发送参数为 0xFFFFFFFA的 CMD0，device也会从 Pre-Boot State进入 Boot state，但处于 Alternative Boot Mode。</p><p><strong>Boot operation</strong>，进入 Boot State后，host就可以从 device读取 boot data。</p><p>根据 EXT_CSD [179]，BOOT_PARTITION_ENABLE的 bit [5:3]的设置，boot data可以来自 boot area或是 user area，bit [6]则可要求 device在接收到 boot ack并在 CMD线拉低 50ms内发送 ack pattern 010。</p><p><img src="http://pic.xxxdk.xyz/eMMC%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F-Boot%20mode-PARTITON_CONFIG.webp" alt="PARTITON_CONFIG"></p><p>boot data的大小由 128KB乘于 BOOT_SIZE_MULT (EXT_CSD byte [226]计算得出，该 byte是只读的。</p><p><img src="http://pic.xxxdk.xyz/eMMC%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F-Boot%20mode-BOOT_SIZE_MULT.webp" alt="BOOT_SIZE_MULT"></p><p>在 CMD线拉低最多 1秒后，device将开始向 host发送 boot data，host必须持续拉低 CMD线，DATA线需要保持 push-pull模式，直到 boot操作结束。下图是 boot mode时序图和 boot mode状态机。</p><p><img src="http://pic.xxxdk.xyz/eMMC%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F-Boot%20mode-boot%20mode%E6%97%B6%E5%BA%8F%E5%9B%BE.webp" alt="boot mode时序图"></p><p><img src="http://pic.xxxdk.xyz/eMMC%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F-Boot%20mode-boot%20mode%E7%8A%B6%E6%80%81%E6%9C%BA.webp" alt="boot mode状态机"></p><p>host可以通过 EXT_CSD [177]，BOOT_BUS_CONDITIONS的 bit [4:3] 选择通信速率，最高支持 High Speed。是否支持 High Speed需要查看 EXT_CSD [177]，BOOT_INFO的 bit [2]，是否支持 DDR则需要查看 bit [1]，支持 DDR的 device必须支持 High Speed。</p><p><img src="http://pic.xxxdk.xyz/eMMC%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F-Boot%20mode-BOOT_BUS_CONDITIONS.webp" alt="BOOT_BUS_CONDITIONS"></p><p>boot mode因为协议简单，实现的代码量少，多实现在 bootrom（ SOC片内 ROM的 BootLoader），用于读取emmc内的 u-boot。但也有很多 SOC因为业务场景需要，会从走 Data transfer mode，可以加快启动流程，实现复杂业务等。因为 bootrom固化在 SOC内，从稳定性和兼容性考虑，一般会使用 backward compatible（DS）模式和 400k的时钟。</p><p>更多 boot mode信息见 6.3  Boot operation mode。</p><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://blog.csdn.net/Reborn_Lee/article/details/88736274">https://blog.csdn.net/Reborn_Lee/article/details/88736274</a></p><p><a href="https://www.cnblogs.com/smartjourneys/p/6663561.html">https://www.cnblogs.com/smartjourneys/p/6663561.html</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eMMC</tag>
      
      <tag>mmc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SD卡命令简介</title>
    <link href="/xxx/2021/01/SD%E5%8D%A1%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/"/>
    <url>/xxx/2021/01/SD%E5%8D%A1%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>SD卡命令在网上可以看到很多资料，本文仅为笔记用途。平时使用场景都是基于 SD3.0的版本，虽然现在 Physical Layer Simplified Specification已经发展到 8.0版本，但这里基于 3.01版本进行介绍。具体协议可以查看 Physical Layer Simplified Specification 3.01的 4.7 Commands、4.8 Card State Transition Table、4.9 Responses。</p><h4 id="命令类型"><a href="#命令类型" class="headerlink" title="命令类型"></a>命令类型</h4><table><thead><tr><th>类型</th><th>缩写</th><th>描述</th></tr></thead><tbody><tr><td>Broadcast commands</td><td>bc</td><td>没有 response的广播命令</td></tr><tr><td>Broadcast commands with response</td><td>bcr</td><td>有 response的广播命令</td></tr><tr><td>Addressed（point-to-point）commands</td><td>ac</td><td>点对点（指定地址）无数据传输</td></tr><tr><td>Addressed（point-to-point）data transfer commands</td><td>adtc</td><td>点对点数据传输</td></tr></tbody></table><p>注：在 SPI mode下可以通过 CS管脚去选择具体的卡进行通信。个人理解，SPI mode下 CMD、DAT、CLK线复用，在识别过程和数据传输阶段才使得广播和点对点命令区分有意义。不过我没接触过 SPI mode的 SD卡，不确定是否有该场景存在。在 SD mode，当前大多数 SD控制器都不支持挂载多个 card，SD Card Association也不建议，感觉广播和点对点命令的区分没啥意义。</p><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>命令长度为 48 bits，结构如下图。软件主要配置 Transmission Bit（读/写），Command Index（命令序号），Argument（命令参数），其余由逻辑处理。与 eMMC的完全一致（mmc的控制器 IP一般都是 eMMC/SD/SDIO复用的，例如 synopsys的 dwc_mshc）。</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B-CMD_format.webp" alt="CMD_format"></p><h4 id="命令集"><a href="#命令集" class="headerlink" title="命令集"></a>命令集</h4><p>SD卡的命令集总共有 12种（class 9只用于 SDIO设备，正常涉及为 11种），每种 class代表一类功能，包含相关命令。具体可以查看协议 Table 4-18。SD卡具体支持的命令集可以通过 CSD寄存器的 bit [95:84]，CCC field来确定。</p><table><thead><tr><th>命令分类</th><th>描述</th></tr></thead><tbody><tr><td>class 0</td><td>basic，基础命令，如 CMD0、CMD2、CMD3、CMD4、CMD7、CMD8、CMD9、CMD10、CMD11（UHS-I mode支持）、CMD12、CMD13、CMD15</td></tr><tr><td>class 1</td><td>reserved，保留</td></tr><tr><td>class 2</td><td>block read，设置块长度、读取单块、多块数据、发送 tuning数据块、设置读取块数量，如 CMD16、CMD17、CMD18、CMD19、CMD20、CMD23、</td></tr><tr><td>class 3</td><td>reserved，保留</td></tr><tr><td>class 4</td><td>block write，设置块长度、设置写入块数量、写取单块、多块数据、写 CSD寄存器，如 CMD16、CMD23、CMD24、CMD25、CMD27</td></tr><tr><td>class 5</td><td>erase，设置擦除开始、结束地址、擦除操作，如 CMD32、CMD33、CMD38</td></tr><tr><td>class 6</td><td>write protection，设置写保护、清除写保护、获取 card写保护状态，如 CMD28、CMD29、CMD30（该命令集在 SDHC和 SDXC卡都已经不支持）</td></tr><tr><td>class 7</td><td>lock card，设置需要上/解锁的块长度、card上锁、解锁，如 CMD16、CMD42</td></tr><tr><td>class 8</td><td>Application-specific，表示下一个命令是一个特定应用命令，如 CMD55</td></tr><tr><td>class 10</td><td>用于 SDIO设备，CMD52-54</td></tr><tr><td>class 10</td><td>Switch Function，功能查询、变更速度模式、驱动能力等，如 CMD6</td></tr><tr><td>class 11</td><td>reserved，保留</td></tr></tbody></table><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th align="center">CMD index</th><th align="center">type</th><th align="left">argument</th><th align="center">resp</th><th align="center">abbr.</th><th align="left">description</th></tr></thead><tbody><tr><td align="center">class 0</td><td align="center"></td><td align="left"></td><td align="center"></td><td align="center"></td><td align="left"></td></tr><tr><td align="center">CMD0</td><td align="center">bc</td><td align="left">[31:0] 0000 0000</td><td align="center">none</td><td align="center">GO_IDLE_STATE</td><td align="left">重置 card进入 idle状态</td></tr><tr><td align="center">CMD2</td><td align="center">bcr</td><td align="left">[31:0] stuff bits</td><td align="center">R2</td><td align="center">ALL_SEND_CID</td><td align="left">card从 CMD线发送其 CID编号给 host</td></tr><tr><td align="center">CMD3</td><td align="center">ac</td><td align="left">[31:16] RCA<br/>[15:0] stuff bits</td><td align="center">R6</td><td align="center">SET_RELATIVE_ADDR</td><td align="left">为 card分配相对地址</td></tr><tr><td align="center">CMD8</td><td align="center">bcr</td><td align="left">[31:12] reserved bits(0)<br/>[11:8] supply voltage(VHS)<br/>[7:0] check pattern<br/></td><td align="center">R7</td><td align="center">SEND_IF_COND</td><td align="left">发送 host支持的工作电压给 card，询问 card是否支持相关工作电压。SDSC卡无法正常响应该命令，识别流程中，用于区分 SDSC与 SDHC和SDXC卡</td></tr><tr><td align="center">CMD9</td><td align="center">ac</td><td align="left">[31:16] RCA<br/>[15:0] stuff bits</td><td align="center">R2</td><td align="center">SEND_CSD</td><td align="left">card从 CMD线发送其 CSD寄存器内容给 host</td></tr><tr><td align="center">CMD11</td><td align="center">ac</td><td align="left">[31:0] reserved bits(0)</td><td align="center">R1</td><td align="center">VOLTAGE_SWITCH</td><td align="left">切换总线信号电平到 1.8V</td></tr><tr><td align="center">CMD12</td><td align="center">ac</td><td align="left">[31:0] stuff bits</td><td align="center">R1b</td><td align="center">STOP_TRANSMISSION</td><td align="left">强制 card停止传输。</td></tr><tr><td align="center">CMD13</td><td align="center">ac</td><td align="left">[31:16] RCA<br/>[15:0] stuff bits</td><td align="center">R1</td><td align="center">SEND_STATUS</td><td align="left">card发送其状态寄存器给 host。</td></tr><tr><td align="center">CMD15</td><td align="center">ac</td><td align="left">[31:16] RCA<br/>[15:0] reserved bits(0)</td><td align="center">none</td><td align="center">GO_INACTIVE_STATE</td><td align="left">使 card进入 inactive状态</td></tr><tr><td align="center">class 2</td><td align="center"></td><td align="left"></td><td align="center"></td><td align="center"></td><td align="left"></td></tr><tr><td align="center">CMD16</td><td align="center">ac</td><td align="left">[31:0] block length</td><td align="center">R1</td><td align="center">SET_BLOCKLEN</td><td align="left">设置块读写操作的块长度，SDHC/SDXC card默认值都是 512bytes。对于 LOCK_UNLOCK命令，如果设置的长度大于 512bytes，BLOCK_LEN_ERROR bit将会置位。</td></tr><tr><td align="center">CMD17</td><td align="center">adtc</td><td align="left">[31:0] data address</td><td align="center">R1</td><td align="center">READ_SINGLE_BLOCK</td><td align="left">读取单块数据，SDSC卡块长度取决于 CMD16，SDHC卡和 SDXC卡为 512bytes</td></tr><tr><td align="center">CMD18</td><td align="center">adtc</td><td align="left">[31:0] data address</td><td align="center">R1</td><td align="center">READ_MULTIPLE_BLOCK</td><td align="left">连续读取多块数据，直到 host发送 STOP_TRANSMISSION命令，块长度与 CMD17情况一致</td></tr><tr><td align="center">CMD19</td><td align="center">adtc</td><td align="left">[31:0] reserved bits(0)</td><td align="center">R1</td><td align="center">SEND_TUNING_BLOCK</td><td align="left">在 tuning模式下，发送  64 bytes特定数据块，用于 SDR50和 SDR104模式最佳采样点的检测</td></tr><tr><td align="center">CMD23</td><td align="center">ac</td><td align="left">[31:0] Block Count</td><td align="center">R1</td><td align="center">SET_BLOCK_COUNT</td><td align="left">指定 CMD18和 CMD25的传输块数量</td></tr><tr><td align="center">class 4</td><td align="center"></td><td align="left"></td><td align="center"></td><td align="center"></td><td align="left"></td></tr><tr><td align="center">CMD16</td><td align="center">ac</td><td align="left">[31:0] block length</td><td align="center">R1</td><td align="center">SET_BLOCKLEN</td><td align="left">设置块读写操作的块长度，SDHC/SDXC card默认值都是 512bytes。对于 LOCK_UNLOCK命令，如果设置的长度大于 512bytes，BLOCK_LEN_ERROR bit将会置位。</td></tr><tr><td align="center">CMD23</td><td align="center">ac</td><td align="left">[31:0] Block Count</td><td align="center">R1</td><td align="center">SET_BLOCK_COUNT</td><td align="left">指定 CMD18和 CMD25的传输块数量</td></tr><tr><td align="center">CMD24</td><td align="center">adtc</td><td align="left">[31:0] data address</td><td align="center">R1</td><td align="center">WRITE_BLOCK</td><td align="left">写入单块数据，SDSC卡块长度取决于 CMD16，SDHC卡和 SDXC卡为 512bytes</td></tr><tr><td align="center">CMD25</td><td align="center">adtc</td><td align="left">[31:0] data address</td><td align="center">R1</td><td align="center">WRITE_MULTIPLE_BLOCK</td><td align="left">连续写入多块数据，直到 host发送 STOP_TRANSMISSION命令，块长度与 CMD24情况一致</td></tr><tr><td align="center">CMD27</td><td align="center">adtc</td><td align="left">[31:0] stuff bits</td><td align="center">R1</td><td align="center">PROGRAM_CSD</td><td align="left">写 CSD寄存器</td></tr><tr><td align="center">ACMDs</td><td align="center"></td><td align="left"></td><td align="center"></td><td align="center"></td><td align="left"></td></tr><tr><td align="center">ACMD6</td><td align="center">ac</td><td align="left">[31:2] stuff bits <br/>[1:0] bus width</td><td align="center">R1</td><td align="center">SET_BUS_WIDTH</td><td align="left">定义用于数据传输的数据总线宽度，00b为 1bit，10b为 4bits，可以在 SCR寄存器确认 card允许的数据总线宽度</td></tr><tr><td align="center">ACMD13</td><td align="center">adtc</td><td align="left">[31:0] stuff bits</td><td align="center">R2</td><td align="center">SD_STATUS</td><td align="left">card向 host发送卡状态寄存器内容（SD Status）</td></tr><tr><td align="center">ACMD41</td><td align="center">bcr</td><td align="left">[31] reserved bit<br/>[30] HSC(OCR[30])<br/>[29] reserved for eSD<br/>[28] XPC<br/>[27:25] reserved bits<br/>[24] S18R<br/>[23:0] VDD Voltage Window(OCR[23:0])<br/></td><td align="center">R3</td><td align="center">SD_SEND_OP_COND</td><td align="left">host发送其支持的容量信息（bit[30] HSC）给 card，并且 card将在 CMD线返回其 OCR寄存器内容。HSC需要在 card已经接收过 CMD8才有效。<br/>bit [28] XPC 用于控制 SDXC卡在默认速度模式下的最大电流，XPC=0，表示最大电流为 100mA，不支持速度等级，XPC=1，表示最大电流为 150mA，支持速度等级。<br/>bit [24] S18R为 1时，用于请求将信号切换到 1.8V。<br/>bit [23:0] 提供给 card检查其工作电压是否匹配，不匹配则进入 Inactive state</td></tr><tr><td align="center">ACMD42</td><td align="center">ac</td><td align="left">[31:1] stuff bits<br/>[0] set_cd<br/></td><td align="center">R1</td><td align="center">SET_CLR_CARD_DETECT</td><td align="left">控制 card CD/DAT3管脚的 50kΩ的上拉电阻，1b为连接，0b为断开</td></tr><tr><td align="center">ACMD51</td><td align="center">adtc</td><td align="left">[31:0] stuff bits</td><td align="center">R1</td><td align="center">SEND_SCR</td><td align="left">读取 card的 SD配置寄存器（SCR）</td></tr><tr><td align="center">class 10</td><td align="center"></td><td align="left"></td><td align="center"></td><td align="center"></td><td align="left"></td></tr><tr><td align="center">CMD6</td><td align="center">adtc</td><td align="left">[31] Mode<br/>    0 : Check function<br/>    1 : Switch function<br/>[30:24] reserved (0)<br/>[23:20] reserved for function group 6 (0h or Fh)<br/>[19:16] reserved for function group 5 (0h or Fh)<br/>[15:12] function group 4 for current limit<br/>[11:8] function group 3 for drive strength<br/>[7:4] function group 2 for command system<br/>[3:0] function group 1 for access mode<br/></td><td align="center">R1</td><td align="center">SWITCH_FUNC</td><td align="left">bit [31] 0b为功能检查，1b为功能切换<br/>bit [15:12] 切换 UHS-I mode下主机提供的最大电流<br/>bit [11:8] 切换 UHS-I mode下主机的驱动能力<br/>bit [7:4] 切换到特定命令系统，实现特殊功能如<br/>bit [3:0] SD总线速度模式选择<br/>具体可以查看图 ‘Available Functions’<br/>CMD6详细信息可以查看 4.3.10 Switch Function Command</td></tr></tbody></table><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B-Available%20Functions.webp" alt="Available Functions"></p><h4 id="Responses"><a href="#Responses" class="headerlink" title="Responses"></a>Responses</h4><p>Response总共有 6种类型，分别是 R1，R1b，R2，R3，R6，R7。所有的 responses都是从 CMD线返回的，其长度和格式与类型相关，但都是以 0为起始位，1为结束位，传输方向位紧接着起始位，0表示 card到 host。除 R3类型外，所有的 responses都受到 CRC7保护。</p><h5 id="R1（normal-response-command）"><a href="#R1（normal-response-command）" class="headerlink" title="R1（normal response command）"></a>R1（normal response command）</h5><p>一般命令都是响应 R1，长度为 48 bit。bit [45:40] 描述响应的命令，bit [39:8] 描述 card的状态，详细状态可以查看 4.10 Two Status Information of SD Memory Card。</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B-R1.webp" alt="R1"></p><h5 id="R1b"><a href="#R1b" class="headerlink" title="R1b"></a>R1b</h5><p>R1b与 R1格式上完全一样，只是会在数据线 DAT0 传输 busy信号，card接受到部分命令会变得忙碌，例如 CMD12，忙碌时 DAT0会被 card拉低。</p><h5 id="R2（CID，CSD-register）"><a href="#R2（CID，CSD-register）" class="headerlink" title="R2（CID，CSD register）"></a>R2（CID，CSD register）</h5><p>R2长度为 136 bit，用于响应 CMD2和 CMD10，返回 CID寄存器的值，以及响应 CMD9，返回 CSD寄存器的值。CID和 CSD的 bit [0]会被结束位替代，即实际传输 bit [127:1]，不过它们两个的 bit [0]也没有使用上，默认为 1。</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B-R2.webp" alt="R2"></p><h5 id="R3（OCR-register）"><a href="#R3（OCR-register）" class="headerlink" title="R3（OCR register）"></a>R3（OCR register）</h5><p>R3长度为 48 bit，用于响应 ACMD41，返回 card的 OCR寄存器值。</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B-R3.webp" alt="R3"></p><h5 id="R6（Published-RCA-response）"><a href="#R6（Published-RCA-response）" class="headerlink" title="R6（Published RCA response）"></a>R6（Published RCA response）</h5><p>R6长度为 48 bit，用于响应 CMD3。bit [45:40] 默认为 ‘000011b’，bit [39:24] 是给 card设置的 RCA，bit [23:8] 表示 card的状态，具体查看 Table 4-36 Card Status，包括 bit 23，22，19，12:0这几个状态。</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B-R6.webp" alt="R6"></p><h5 id="R7（Card-interface-condition）"><a href="#R7（Card-interface-condition）" class="headerlink" title="R7（Card interface condition）"></a>R7（Card interface condition）</h5><p>R7长度为 48bit，用于响应 CMD8。bit [19:16]（voltage accepted）是返回 card支持的工作电压范围，bit [15:8] 返回 host发送的 check pattern。</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B-R7.webp" alt="R7"></p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B-Voltage%20Accepted.webp" alt="Voltage Accepted"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mmc</tag>
      
      <tag>sd card</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sdhci_set_transfer_mode函数解析</title>
    <link href="/xxx/2021/01/sdhci-set-transfer-mode%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/"/>
    <url>/xxx/2021/01/sdhci-set-transfer-mode%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近逻辑和测试对软件传输数据的流程有很多问号？？？软件是否会设置控制器相关寄存器，让控制器自行发 stop transfer的命令，即 Auto CMD23或 Auto CMD12。本着对版本负责，作为寄存器配置工程师，即使是内核原生流程，我也会将相关代码解析告诉他们。</p><p>在具体分析代码前，我们大概了解下 CMD12和 CMD23。CMD12，STOP_TRANSMISSION，停止多块传输操作。启动多块读 CMD18或者多块写 CMD25后，可以通过 CMD12停止传输。CMD23，SET_BLOCK_COUNT，定义读/写的块数量。启动多块读 CMD18或者多块写 CMD25前，如果通过 CMD23定义了传输的块数量，则完成指定数量的传输后，将停止传输。当然 CMD12和 CMD23还能影响 CMD30、CMD27这些命令。</p><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>基于 linux 4.14.212版本进行分析，linux 4.19.163差异也不大，代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sdhci_set_transfer_mode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sdhci_host *host,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> mmc_command *cmd)</span><br>&#123;<br>u16 mode = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mmc_data</span> *<span class="hljs-title">data</span> =</span> cmd-&gt;data;<br><br><span class="hljs-keyword">if</span> (data == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">if</span> (host-&gt;quirks2 &amp;<br>SDHCI_QUIRK2_CLEAR_TRANSFERMODE_REG_BEFORE_CMD) &#123;<br>sdhci_writew(host, <span class="hljs-number">0x0</span>, SDHCI_TRANSFER_MODE);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* clear Auto CMD settings for no data CMDs */</span><br>mode = sdhci_readw(host, SDHCI_TRANSFER_MODE);<br>sdhci_writew(host, mode &amp; ~(SDHCI_TRNS_AUTO_CMD12 |<br>SDHCI_TRNS_AUTO_CMD23), SDHCI_TRANSFER_MODE);<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>WARN_ON(!host-&gt;data);<br><br><span class="hljs-keyword">if</span> (!(host-&gt;quirks2 &amp; SDHCI_QUIRK2_SUPPORT_SINGLE))<br>mode = SDHCI_TRNS_BLK_CNT_EN;<br><br><span class="hljs-keyword">if</span> (mmc_op_multi(cmd-&gt;opcode) || data-&gt;blocks &gt; <span class="hljs-number">1</span>) &#123;<br>mode = SDHCI_TRNS_BLK_CNT_EN | SDHCI_TRNS_MULTI;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we are sending CMD23, CMD12 never gets sent</span><br><span class="hljs-comment"> * on successful completion (so no Auto-CMD12).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (sdhci_auto_cmd12(host, cmd-&gt;mrq) &amp;&amp;<br>    (cmd-&gt;opcode != SD_IO_RW_EXTENDED))<br>mode |= SDHCI_TRNS_AUTO_CMD12;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmd-&gt;mrq-&gt;sbc &amp;&amp; (host-&gt;flags &amp; SDHCI_AUTO_CMD23)) &#123;<br>mode |= SDHCI_TRNS_AUTO_CMD23;<br>sdhci_writel(host, cmd-&gt;mrq-&gt;sbc-&gt;arg, SDHCI_ARGUMENT2);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (data-&gt;flags &amp; MMC_DATA_READ)<br>mode |= SDHCI_TRNS_READ;<br><span class="hljs-keyword">if</span> (host-&gt;flags &amp; SDHCI_REQ_USE_DMA)<br>mode |= SDHCI_TRNS_DMA;<br><br>sdhci_writew(host, mode, SDHCI_TRANSFER_MODE);<br>&#125;<br></code></pre></td></tr></table></figure><p>sdhci_set_transfer_mode()主要由两部分组成，即本次传输是否需要传输数据。</p><h4 id="Non-DAT-transfer"><a href="#Non-DAT-transfer" class="headerlink" title="Non-DAT transfer"></a>Non-DAT transfer</h4><p>无数据传输分支，会先对控制器的特性进行判断，确定是否需要在发送命令前清零传输模式寄存器（0x0c） （SDHCI_QUIRK2_CLEAR_TRANSFERMODE_REG_BEFORE_CMD）。不需要则把 Auto CMD关掉，因为没有数据传输，就不需要发 CMD12或者 CMD23了，至此就设置好无数据传输的传输模式寄存器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (data == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">if</span> (host-&gt;quirks2 &amp;<br>SDHCI_QUIRK2_CLEAR_TRANSFERMODE_REG_BEFORE_CMD) &#123;<br>sdhci_writew(host, <span class="hljs-number">0x0</span>, SDHCI_TRANSFER_MODE);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* clear Auto CMD settings for no data CMDs */</span><br>mode = sdhci_readw(host, SDHCI_TRANSFER_MODE);<br>sdhci_writew(host, mode &amp; ~(SDHCI_TRNS_AUTO_CMD12 |<br>SDHCI_TRNS_AUTO_CMD23), SDHCI_TRANSFER_MODE);<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Data-transfer"><a href="#Data-transfer" class="headerlink" title="Data transfer"></a>Data transfer</h4><p>数据传输分支，先确认软件是否配置了控制器支持单块传输计数，没有则使能控制器块计数（block count enable）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!(host-&gt;quirks2 &amp; SDHCI_QUIRK2_SUPPORT_SINGLE))<br>mode = SDHCI_TRNS_BLK_CNT_EN;<br></code></pre></td></tr></table></figure><p>然后判断这次传输的命令是否是多块读或是多块写 （mmc_op_multi(cmd-&gt;opcode)），或者是传输的块数量大于 1 （data-&gt;blocks &gt; 1），是则会使能控制器块计数和多块传输。</p><p>接着判断控制器如果不支持 Auto CMD12 （sdhci_auto_cmd12() 返回 false，具体解析见下一段），同时命令不是 CMD53（SDIO多块读写命令），则使能控制器 Auto CMD23能力。如果不是上述条件则继续判断，struct mmc_request的变量 sbc（SET_BLOCK_COUNT for multiblock）是否已经初始化，同时软件初始化控制器是否设置了 Auto CMD23标志 （SDHCI_AUTO_CMD23），是，则使能控制器 Auto CMD23能力和将配置好的 mrq-&gt;sbc-&gt;arg（blocks / ../core/mmc_test.c +210）写入控制器的 SDHCI_ARGUMENT2中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (mmc_op_multi(cmd-&gt;opcode) || data-&gt;blocks &gt; <span class="hljs-number">1</span>) &#123;<br>mode = SDHCI_TRNS_BLK_CNT_EN | SDHCI_TRNS_MULTI;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we are sending CMD23, CMD12 never gets sent</span><br><span class="hljs-comment"> * on successful completion (so no Auto-CMD12).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (sdhci_auto_cmd12(host, cmd-&gt;mrq) &amp;&amp;<br>    (cmd-&gt;opcode != SD_IO_RW_EXTENDED))<br>mode |= SDHCI_TRNS_AUTO_CMD12;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmd-&gt;mrq-&gt;sbc &amp;&amp; (host-&gt;flags &amp; SDHCI_AUTO_CMD23)) &#123;<br>mode |= SDHCI_TRNS_AUTO_CMD23;<br>sdhci_writel(host, cmd-&gt;mrq-&gt;sbc-&gt;arg, SDHCI_ARGUMENT2);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>sdhci_auto_cmd12，返回 true则控制器当前配置使能了 Auto CMD12，false反之。分析下 return的这三个条件，1、struct mmc_request的变量 sbc（SET_BLOCK_COUNT for multiblock）没有初始化；</p><p>2、软件初始化控制器时，设置了 Auto CMD12标志 （SDHCI_AUTO_CMD12）；</p><p>3、struct mmc_request的变量 cap_cmd_during_tfr（数据传输或者忙等待中，允许发送命令）是 false（不允许）。</p><p>同时满足上述三个条件，则逻辑会自行发 CMD12。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">sdhci_auto_cmd12</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sdhci_host *host,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> mmc_request *mrq)</span><br>&#123;<br><span class="hljs-keyword">return</span> !mrq-&gt;sbc &amp;&amp; (host-&gt;flags &amp; SDHCI_AUTO_CMD12) &amp;&amp;<br>       !mrq-&gt;cap_cmd_during_tfr;<br>&#125;<br></code></pre></td></tr></table></figure><p>后续再判断是否是读传输和是否使用 DMA。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (data-&gt;flags &amp; MMC_DATA_READ)<br>mode |= SDHCI_TRNS_READ;<br><span class="hljs-keyword">if</span> (host-&gt;flags &amp; SDHCI_REQ_USE_DMA)<br>mode |= SDHCI_TRNS_DMA;<br></code></pre></td></tr></table></figure><p>最后将上述配置写入传输模式寄存器 SDHCI_TRANSFER_MODE。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sdhci_writew(host, mode, SDHCI_TRANSFER_MODE);<br></code></pre></td></tr></table></figure><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>2021的第一篇博客/文档，真是写了一年的，希望 2021升职加薪，love&amp;peace。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mmc</tag>
      
      <tag>sdhci</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年新年音乐会</title>
    <link href="/xxx/2020/12/2021%E5%B9%B4%E6%96%B0%E5%B9%B4%E9%9F%B3%E4%B9%90%E4%BC%9A/"/>
    <url>/xxx/2020/12/2021%E5%B9%B4%E6%96%B0%E5%B9%B4%E9%9F%B3%E4%B9%90%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>12月28日，傍晚，伴着许久未见的火烧云出发了，昏暗的车厢外橙黄的天空让人放下手机，静静的欣赏沿途的风景。快节奏的深圳，我有多久没有慢下来呢？想想都心累。点缀着加班人灯光的摩天大楼慢慢进入眼帘，而远处又是缤纷的霓虹和平安的大宝剑。班车从龙岗开到福田核心区，一路的风景给我一种乡巴佬进城的错觉，明明我也是在“坂田CBD”搬砖的呀。嗯，大概就这样了，路上并没有遇上塞车，我们得以提前一个半小时，从 D区到了深圳音乐厅，这是秘书小姐姐没有想到的事情。想想上次欣赏高雅艺术还是三年前了，那时候还在顺德搬砖。</p><p>一个半小时的时间，我还是在深圳音乐厅附近转了下，拍了两张不错的照片。</p><p><img src="http://pic.xxxdk.xyz/2021%E5%B9%B4%E6%96%B0%E5%B9%B4%E9%9F%B3%E4%B9%90%E4%BC%9A-1.webp" alt="市民中心"></p><p><img src="http://pic.xxxdk.xyz/2021%E5%B9%B4%E6%96%B0%E5%B9%B4%E9%9F%B3%E4%B9%90%E4%BC%9A-2.webp" alt="深圳市当代艺术与城市规划馆"></p><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>进入会场前，准备中场休息时喝的水被要求寄存了，这个也无所谓，毕竟当前还是学习摸索阶段。全程都有人专门指引座位，不知道是防疫要求还是担心低价位入座高价位区域，能感觉到工作人员对这方面明显的控制。进入厅内，发现整个音乐厅，除了管风琴位置，都安排了座位，山脚到山顶的坡度还是蛮陡，而我在山腰。事后觉得还是山脚好，加钱也应该到山下。一个原因是山腰听到的是音箱放出来的，虽然也不排除山脚感受差不多；另外一个原因是太远了，什么都看不到，我理解观看指挥和乐手们的演奏也是很重要的，不然中间会有点无聊。不过整体体验不错，时间还是过得很快的。</p><p>这次音乐会是由长影乐团演奏，指挥是曲鑫。长影乐团，长春电影制片厂交响乐团，新中国第一支国家级电影交响乐团。70多年中，共为 700余部电影创作录制音乐作品，如《上甘岭》中的《我的祖国》，后面的返场曲目就有这首经典之作。</p><p>整体下来，虽然没有听得意犹未尽，也有点心潮澎湃，打满了鸡血，明天可以努力加班了，觉得每年听两到三次音乐会还是很有价值的。</p><p>这次音乐会遇到了之前大概知道的一件事情，演奏家的多次谢幕，满满的套路呀，感觉大家把手都拍麻了。乐团也没让大家失望，返场曲目演奏了三首《我的祖国》、《将军令》和《卡门序曲》。《将军令》对比林子祥的《男儿当自强》，还是喜欢后者多点，中气十足的人声也是很重要的。</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>发现很多事情还是值得吐槽的，厅内手机完全没信号，身边有人想要连 WiFi，全程安静的听音乐会，你用手机是要干啥？演奏过程中，也有人时不时的拍照，录像，不戴口罩，或者是说话沟通。拍照录像，出来的结果画质和音质都十分惊人，为啥不去网上把维也纳新年音乐会的 BD下回来，搭个 7.1环绕好好欣赏呢？不戴口罩的人都被工作人员提醒 N+1次了，呼吸困难建议回家隔离，真是大写的尴尬。说话的就没啥好吐槽了，毕竟你说啥，大家都听得很清楚，该安静的时候，会场都很寂静。</p><p>当然自己也有不足的地方，那么多曲目都没有预习下，不明白其大意，听得事后有种一知半解的味道。古典音乐会相关知识还有很多，有空还得多接触、学习。</p><h4 id="节目单"><a href="#节目单" class="headerlink" title="节目单"></a>节目单</h4><p>1、管弦乐《千人之力》</p><p>2、管弦乐《卡门序曲》选自歌剧《卡门》</p><p>3、女声独唱《亲爱的爸爸》选自歌剧《贾尼·斯基基》唱段</p><p>4、管弦乐《拉科齐进行曲》</p><p>5、管弦乐《快速列车波尔卡》</p><p>6、萨克斯与乐队《我心永恒》选自影片《泰坦尼克号》主题音乐</p><p>7、管弦乐《威廉退尔序曲》</p><p>8、管弦乐《马刀舞曲》选自芭蕾舞剧《加雅涅》舞曲</p><p>9、管弦乐《雷电波尔卡》</p><p>10、男声独唱《我的太阳》意大利民歌</p><p>11、男女声二重唱《饮酒歌》选自歌剧《茶花女》唱段</p><p>12、管弦乐《He’s A Pirate》选自影片《加勒比海盗》主题音乐</p><p>13、管弦乐《蓝色多瑙河》圆舞曲</p><p>14、管弦乐《天堂与地狱》选自轻歌剧《地狱中的奥菲欧》序曲</p><p>返场曲目</p><p>1、管弦乐《我的祖国》</p><p>2、管弦乐《将军令》</p><p>3、管弦乐《卡门序曲》选自歌剧《卡门》</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>音乐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eMMC命令简介</title>
    <link href="/xxx/2020/11/eMMC%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/"/>
    <url>/xxx/2020/11/eMMC%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>eMMC命令详细介绍网上有很多资料，具体协议可以查看 JESD84-B51的 6.10  Commands，本文仅为笔记用途。</p><h4 id="命令类型"><a href="#命令类型" class="headerlink" title="命令类型"></a>命令类型</h4><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>bc</td><td>没有 response的广播命令</td></tr><tr><td>bcr</td><td>有 response的广播命令</td></tr><tr><td>ac</td><td>点对点（指定地址）无数据传输</td></tr><tr><td>adtc</td><td>点对点数据传输</td></tr></tbody></table><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>命令长度为 48 bits，结构如下图。软件主要配置 Transmission Bit（读/写），Command Index（命令序号），Argument（命令参数），其余由逻辑处理。</p><p><img src="http://pic.xxxdk.xyz/eMMC%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B-CMD_format.webp" alt="CMD_format"></p><h4 id="命令集"><a href="#命令集" class="headerlink" title="命令集"></a>命令集</h4><p>eMMC的命令集总共有 12种，每种 class代表一类功能，包含相关命令，每个命令只会属于一种 class。class 0是所有 devices必须支持的，其余的可以通过 CSD寄存器的 bit [95:84]，CCC field来确定 device支持的命令集。</p><table><thead><tr><th>命令分类</th><th>描述</th></tr></thead><tbody><tr><td>class 0</td><td>basic，基础命令，如 CMD0、CMD1、CMD2、CMD3、CMD6、CMD8、CMD12、CMD13</td></tr><tr><td>class 1</td><td>Obsolete，废弃</td></tr><tr><td>class 2</td><td>block read，读取单块、多块数据、设置块长度、发送 tuning数据块，如 CMD16、CMD17、CMD18、CMD21</td></tr><tr><td>class 3</td><td>Obsolete，废弃</td></tr><tr><td>class 4</td><td>block write，写取单块、多块数据、设置块长度，如 CMD23、CMD24、CMD25</td></tr><tr><td>class 5</td><td>erase，擦除操作、设置擦除开始、结束地址，如 CMD35、CMD36、CMD38</td></tr><tr><td>class 6</td><td>write protection，设置写保护、清除写保护、获取 device写保护状态、获取写保护类型，如 CMD 28、CMD29、CMD30、CMD31</td></tr><tr><td>class 7</td><td>lock Device，device 上锁、解锁，如 CMD42</td></tr><tr><td>class 8</td><td>Application-specific，表示下一个命令是一个特定应用命令，如 CMD55</td></tr><tr><td>class 9</td><td>I/O mode，读写 device特定的寄存器（未在 eMMC标准中定义）、设置系统进入中断模式，如 CMD39、CMD40</td></tr><tr><td>class 10</td><td>Security Protocols，连续数据块传输，如 CMD53、CMD54</td></tr><tr><td>class 11</td><td>Command Queuing，命令队列，定义操作的读或写、优先级、任务ID等、定义任务队列的块地址、丢弃特定队列或者整个队列，如 CMD44、CMD45、CMD46、CMD47、CMD48</td></tr></tbody></table><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th align="center">CMD index</th><th align="center">type</th><th align="left">argument</th><th align="center">resp</th><th align="center">abbr.</th><th align="left">description</th></tr></thead><tbody><tr><td align="center">class 0</td><td align="center"></td><td align="left"></td><td align="center"></td><td align="center"></td><td align="left"></td></tr><tr><td align="center">CMD0</td><td align="center">bc</td><td align="left">[31:0] 0000 0000</td><td align="center">none</td><td align="center">GO_IDLE_STATE</td><td align="left">重置 device进入 idle状态</td></tr><tr><td align="center">CMD1</td><td align="center">bcr</td><td align="left">[31:0] OCR with-out busy</td><td align="center">R3</td><td align="center">SEND_OP_COND</td><td align="left">在idle状态下，device从 CMD线的发送其 OCR寄存器内容给 host</td></tr><tr><td align="center">CMD2</td><td align="center">bcr</td><td align="left">[31:0] stuff bits</td><td align="center">R2</td><td align="center">ALL_SEND_CID</td><td align="left">device从 CMD线发送其 CID编号给 host</td></tr><tr><td align="center">CMD3</td><td align="center">ac</td><td align="left">[31:16] RCA<br/>[15:0] stuff bits</td><td align="center">R1</td><td align="center">SET_RELATIVE_ADDR</td><td align="left">为 device分配相对地址</td></tr><tr><td align="center">CMD6</td><td align="center">ac</td><td align="left">[31:26] Set to 0<br/>[25:24] Access<br/>[23:16] Index<br/>[15:8] Value<br/>[7:3] Set to 0<br/>[2:0] Cmd Set</td><td align="center">R1b</td><td align="center">SWITCH</td><td align="left">切换 device运行的命令集或者修改 EXT_CSD寄存器的值。<br/>bit [25:24]，Access，00，Command Set表示根据 Cmd Set的值改变运行的命令集；01，Set Bits表示根据 Value中为 1的 bit对 Index指向 byte相应位进行置位；10，Clear Bits表示根据 Value中为 1的 bit对 Index所指向 byte相应位进行清零；11，Write Byte表示将Value的值写入指向的 byte<br/>bit [23:16]，Index，EXT_CSD的索引值，有效值为 0到 191<br/>bit [2:0]，Cmd Set，要切换的命令集<br/>具体请查看 6.6.1  Command sets and extended settings</td></tr><tr><td align="center">CMD8</td><td align="center">adtc</td><td align="left">[31:0] stuff bits</td><td align="center">R1</td><td align="center">SEND_EXT_CSD</td><td align="left">device 以数据块的形式发送其 EXT_CSD寄存器的内容给 host</td></tr><tr><td align="center">CMD9</td><td align="center">ac</td><td align="left">[31:16] RCA<br/>[15:0] stuff bits</td><td align="center">R2</td><td align="center">SEND_CSD</td><td align="left">device从 CMD线发送其 CSD寄存器内容给 host</td></tr><tr><td align="center">CMD12</td><td align="center">ac</td><td align="left">[31:16] RCA<br/>[15:1] stuff bits<br/>[0] HPI</td><td align="center">R1/R1b</td><td align="center">STOP_TRANSMISSION</td><td align="left">强制 device停止传输。如果置位了 HPI，device应在明确规定的时间内中断其内部操作。读操作返回 R1，写操作返回 R1b</td></tr><tr><td align="center">CMD13</td><td align="center">ac</td><td align="left">[31:16] RCA<br/>[15] SQS<br/>[14:1] stuff bits<br/>[0] HPI</td><td align="center">R1</td><td align="center">SEND_STATUS</td><td align="left">如果 SQS bit=0：device发送其状态寄存器给 host。如果置位了 HPI，device应在明确规定的时间内中断其内部操作。<br/>如果 SQS bit=1：表示这是一个 QSR查询。device应发送 QSR寄存器给 host。这种情况下，HPI必须为 0</td></tr><tr><td align="center">class 2</td><td align="center"></td><td align="left"></td><td align="center"></td><td align="center"></td><td align="left"></td></tr><tr><td align="center">CMD16</td><td align="center">ac</td><td align="left">[31:0] block length</td><td align="center">R1</td><td align="center">SET_BLOCKLEN</td><td align="left">设置块读写操作的块长度，默认值在 CSD寄存器 READ_BL_LEN bit [83:80] / WRITE_BL_LEN bit [25:22]指定</td></tr><tr><td align="center">CMD17</td><td align="center">adtc</td><td align="left">[31:0] data address</td><td align="center">R1</td><td align="center">READ_SINGLE_BLOCK</td><td align="left">读取单块数据</td></tr><tr><td align="center">CMD18</td><td align="center">adtc</td><td align="left">[31:0] data address</td><td align="center">R1</td><td align="center">READ_MULTIPLE_BLOCK</td><td align="left">连续读取多块数据，直到传输停止，或者读取数据块数达到请求的数据块数</td></tr><tr><td align="center">CMD21</td><td align="center">adtc</td><td align="left">[31:0] stuff bits</td><td align="center">R1</td><td align="center">SEND_TUNING_BLOCK</td><td align="left">在 tuning模式下，发送特定数据块（4 bit模式为 64 byte，8 bit模式为 128 byte）用于 HS200模式最佳采样点的检测</td></tr><tr><td align="center">class 4</td><td align="center"></td><td align="left"></td><td align="center"></td><td align="center"></td><td align="left"></td></tr><tr><td align="center">CMD23</td><td align="center">ac</td><td align="left">[31] Reliable Write Request<br/>[30] ‘0’ non- packed ‘1’ packed<br/>[29] tag request<br/>[28:25] context ID<br/>[24]: forced programming<br/>[23:16] set to 0<br/>[15:0] number of blocks</td><td align="center">R1</td><td align="center">SET_BLOCK_COUNT</td><td align="left">bit [31] 可靠写请求，bit [30] ‘0’ non-packed / ‘1’ packed，bit [24] forced programming，设置为1，强迫数据直接写入存储介质，而不是写入 cache，bit [15:0] number of blocks，定义读写块数量</td></tr><tr><td align="center">CMD24</td><td align="center">adtc</td><td align="left">[31:0] data address</td><td align="center">R1</td><td align="center">WRITE_BLOCK</td><td align="left">写入单块数据</td></tr><tr><td align="center">CMD25</td><td align="center">adtc</td><td align="left">[31:0] data address</td><td align="center">R1</td><td align="center">WRITE_MULTIPLE_BLOCK</td><td align="left">连续写入多块数据，直到传输停止，或者写入数据块数达到设定的数据块数</td></tr><tr><td align="center">class 11</td><td align="center"></td><td align="left"></td><td align="center"></td><td align="center"></td><td align="left"></td></tr><tr><td align="center">CMD44</td><td align="center">ac</td><td align="left">[31] Reliable Write Request<br/>[30] DD: “1” read / “0” write<br/>[29] Tag request<br/>[28:25] Context ID<br/>[24]: Forced Programming<br/>[23] Priority: “0” simple / “1” high<br/>[22:21] reserved<br/>[20:16] Task ID<br/>[15:0] Number of Blocks</td><td align="center">R1</td><td align="center">QUEUED_TASK_PARAMS</td><td align="left">bit [31] 可靠写请求，bit [30] 定义操作的方向，’1’ 读取 / ‘0’ 写入，bit [23] 优先级，bit [20:16] 任务 ID，bit [15:0] 任务队列的块计数</td></tr><tr><td align="center">CMD45</td><td align="center">ac</td><td align="left">[31:0] Start block address</td><td align="center">R1</td><td align="center">QUEUED_TASK_ADDRESS</td><td align="left">定义任务队列的起始块地址</td></tr><tr><td align="center">CMD46</td><td align="center">adtc</td><td align="left">[31:21] reserved<br/>[20:16] Task ID<br/>[15:0] reserved</td><td align="center">R1</td><td align="center">EXECUTE_READ_TASK</td><td align="left">device执行对应任务 ID的读操作</td></tr><tr><td align="center">CMD47</td><td align="center">adtc</td><td align="left">[31:21] reserved<br/>[20:16] Task ID<br/>[15:0] reserved</td><td align="center">R1</td><td align="center">EXECUTE_WRITE_TASK</td><td align="left">device执行对应任务 ID的写操作</td></tr><tr><td align="center">CMD48</td><td align="center">ac</td><td align="left">[31:21] reserved<br/>[20:16]: TaskID<br/>[15:4]: reserved<br/>[3:0] TM op-code (Table 5)</td><td align="center">R1b</td><td align="center">CMDQ_TASK_MGMT</td><td align="left">device 丢弃特定任务或者整个队列<br/>当 bit [3:0] TM op-code = 0x2时，bit [20:16]表示 task id，当 TM op-code = 0x1时，bit [20:16]为保留，无意义。</td></tr></tbody></table><h4 id="Responses"><a href="#Responses" class="headerlink" title="Responses"></a>Responses</h4><p>Response总共有 6种类型，分别是 R1，R1b，R2，R3，R4，R5。所有的 responses都是从 CMD线返回的，其长度和格式与类型相关，但都是以 0为起始位，1为结束位，传输方向位紧接着起始位，0表示 device到 host。除 R3类型外，所有的 responses都受到 CRC7保护。</p><h5 id="R1"><a href="#R1" class="headerlink" title="R1"></a>R1</h5><p>一般命令都是响应 R1，长度为 48 bit。bit [45:40] 描述响应的命令，bit [39:8] 描述 device的状态，详细状态可以查看 6.13 Device status。</p><p><img src="http://pic.xxxdk.xyz/eMMC%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B-R1.webp" alt="R1"></p><h5 id="R1b"><a href="#R1b" class="headerlink" title="R1b"></a>R1b</h5><p>R1b与 R1格式上完全一样，只是会在数据线 DAT0 传输 busy信号，device接受到部分命令会变得忙碌，例如 CMD6，忙碌时 DAT0会被 device拉低，具体时序可以查看 6.15.1 Command and response，R1b responses。</p><h5 id="R2"><a href="#R2" class="headerlink" title="R2"></a>R2</h5><p>R2长度为 136 bit，用于响应 CMD2和 CMD10，返回 CID寄存器的值，以及响应 CMD9，返回 CSD寄存器的值。CID和 CSD的 bit [0]会被结束位替代，即实际传输 bit [127:1]，不过它们两个的 bit [0]没有使用上，默认为 1。</p><p><img src="http://pic.xxxdk.xyz/eMMC%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B-R2.webp" alt="R2"></p><h5 id="R3"><a href="#R3" class="headerlink" title="R3"></a>R3</h5><p>R3长度为 48 bit，用于响应 CMD1，返回 device的 OCR寄存器值。</p><p><img src="http://pic.xxxdk.xyz/eMMC%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B-R3.webp" alt="R3"></p><h5 id="R4"><a href="#R4" class="headerlink" title="R4"></a>R4</h5><p>R4长度为 48 bit，用于响应 CMD39。bit [15]，Status表示操作是否成功，成功为 1，bit [14:8]，Register address表示 device的特定寄存器地址，bit [7:0]，Read register contents表示读取到的内容。</p><p><img src="http://pic.xxxdk.xyz/eMMC%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B-R4.webp" alt="R4"></p><h5 id="R5"><a href="#R5" class="headerlink" title="R5"></a>R5</h5><p>R5长度为 48bit，用于响应 CMD40。host发送 CMD40让 device进入中断模式，device返回 R5则表明进入中断模式，后续 RCA将使用 0x0000。</p><p><img src="http://pic.xxxdk.xyz/eMMC%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B-R5.webp" alt="R5"></p><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://blog.csdn.net/yuesichiu/article/details/74012312">https://blog.csdn.net/yuesichiu/article/details/74012312</a></p><p><a href="https://www.cnblogs.com/smartjourneys/p/6657397.html">https://www.cnblogs.com/smartjourneys/p/6657397.html</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eMMC</tag>
      
      <tag>mmc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SD卡相关寄存器简介</title>
    <link href="/xxx/2020/10/SD%E5%8D%A1%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B/"/>
    <url>/xxx/2020/10/SD%E5%8D%A1%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>SD Association制定了 SD卡、SDIO的相关的标准，目前物理层协议已经发展到 8.0，它定义了六个 SD卡接口寄存器，OCR、CID、CSD、RCA、DSR、SCR以及没直接说明的 SSR和 CSR。</p><h4 id="OCR"><a href="#OCR" class="headerlink" title="OCR"></a>OCR</h4><p>工作条件寄存器，Operation conditions register，32 bits。通过 CMD1（SEND_OP_COND）获取，在 CMD线上传输，包括以下信息：</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B-OCR.webp" alt="OCR"></p><p>对比 eMMC的 OCR寄存器还是有相似性的，目前常用的是 SDHC/SDXC卡，主要关注</p><p>bit [31]，忙状态位，在 device初始化完成后置位；</p><p>bit [30]，0是 SDSC卡，1则是 SDHC/SDXC卡；</p><p>bit [29]，1则是 UHS-II卡；</p><p>bit [24]，置位则表示 device接受 ACMD41设置 1.8V为工作电压；</p><p>bit [23:15]，表示 device支持的电压，基本是 High Speed mode用的；</p><p>bit [7]，预留给低电压。现在 UHS-I mode的工作电压就是 1.8V，但这个 bit在 physical layer version 8.00还是没有描述。</p><h4 id="CID"><a href="#CID" class="headerlink" title="CID"></a>CID</h4><p>卡识别寄存器，Card IDentification register，128 bits。通过 CMD2（ALL_SEND_CID）或 CMD10（SEND_CID）获取，在 CMD线上传输。CMD2在 Ready State阶段获取，CMD10在 Stand-by State阶段使用，并且需要指定 RCA。CID寄存器的值是唯一的，常用于产品身份识别、key的派生等。CID寄存器包括以下信息：</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B-CID.webp" alt="CID"></p><h4 id="CSD"><a href="#CSD" class="headerlink" title="CSD"></a>CSD</h4><p>卡特性数据寄存器，Card-Specific Data register，128 bits。通过 CMD9（SEND_CSD）获取。CSD寄存器提供了 device内容访问方式的信息，定义了块大小，SD卡容量大小、数据格式、纠错类型、最长数据访问时间、数据传输速度、DSR寄存器是否可用等。可以通过 CMD27（PROGRAM_CSD）对可编程部分（marked by W/E）进行修改。更多详细信息可查看协议 5.3 CSD Register。</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B-CSD%20structure.webp" alt="CSD structure"></p><p>bit [127:126]，CSD_STRUCTURE，描述 CSD register的版本，0x0为 Version 1.0对应 SDSC，0x1为 Version 2.0对应 SDHC/SDXC，0x2为 Version 3.0对应 SDUC。</p><p>下图是 CSD register (Version 2.0)：</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B-CSD%202.0.webp" alt="CSD 2.0"></p><p>bit [95:84]，卡支持的命令集，12 bits。目前定义了 12种命令集，所有版本的 SD卡必须支持 Class 0，2，4，5和 8，SDHC、SDXC、SDUC还需要支持 Class 7，支持哪个 Class就需要在对应的 bit置1。</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B-CCC.webp" alt="CCC"></p><p>bit [69:48]，C_SIZE，卡容量，22 bits，计算方法是 C_SIZE+1乘 2的 READ_BL_LEN次方。例如，用 SDHC卡最大容量 32GB - 80MB计算，则 C_SIZE是 0x00ff5f（65375），即 65376 * 512 / 1024 /1024 = 31.921875‬GB。</p><h4 id="RCA"><a href="#RCA" class="headerlink" title="RCA"></a>RCA</h4><p>相对地址寄存器，Relative card address register，16 bits。通过 CMD3（SET_RELATIVE_ADDR）设置。host在 Identification State阶段对 device设置地址，用于后续的通信。</p><h4 id="DSR"><a href="#DSR" class="headerlink" title="DSR"></a>DSR</h4><p>Driver stage register，16 bits，通过 CMD4（SET_DSR）配置。在 SD中，这个寄存器是可选的，不一定需要实现。它可选择性地用于改善总线在扩展工作条件下的性能（取决于总线长度、传输速率或设备数量等参数）。具体影响 CMD和 DAT的总线驱动器中的预驱动级（ pre-driver stage）和互补驱动晶体管，配置预驱动级的输出电压的上升和下降时间和互补驱动晶体管的数量。实际场景还未遇到需要配置的情况。</p><h4 id="SCR"><a href="#SCR" class="headerlink" title="SCR"></a>SCR</h4><p>SD卡配置寄存器，SD CARD Configuration Register，64 bits，通过 ACMD51（SEND_SCR），从 DAT线读回。具体描述了 SD卡的版本、总线宽度、数据擦除后颗粒是 “0”或 “1”等。</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B-SCR.webp" alt="SCR"></p><p>bit [59:56]（SD_SPEC）、bit [47]（SD_SPEC3）、bit [42]（SD_SPEC4）、bit [41:38]（SD_SPECX），可以用于判断 SD卡的版本，不过常用的 SDXC/UHS-I mode的卡只需用上 SD_SPEC和 SD_SPEC3。</p><p><img src="http://pic.xxxdk.xyz/SD%E5%8D%A1%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B-SCR_SPEC.webp" alt="SCR_SPEC"></p><p>bit [35:32]，CMD_SUPPORT，支持 CMD20、CMD23、CMD48/49、CMD58/59会在这里有具体的 bit描述，当然首先要支持对应的 CCC（Card Command Class）。</p><h4 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h4><p>SD 状态寄存器，SD Status register，512 bits， 通过 ACMD13（SD_STATUS），从 DAT线读回。描述有总线位宽、速度等级、保护区域大小、擦除相关参数等，具体查看协议 4.10.2 SD Status。</p><h4 id="CSR"><a href="#CSR" class="headerlink" title="CSR"></a>CSR</h4><p>SD卡状态寄存器，Card Status，32 bits，通过 CMD13（SEND_STATUS），从 CMD线读回，response为 R1。描述卡是否发生了什么错误或者处于什么状态，例如 bit [29]，传输设置的块长度是否与卡匹配；bit [27]，擦除目的块无效；bit [25]，卡是否上锁；bit [20]，卡内部控制器是否出错；具体看协议 4.10.2 Card Status。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mmc</tag>
      
      <tag>sd card</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《君主论》后篇</title>
    <link href="/xxx/2020/09/%E8%AF%BB%E3%80%8A%E5%90%9B%E4%B8%BB%E8%AE%BA%E3%80%8B%E5%90%8E%E7%AF%87/"/>
    <url>/xxx/2020/09/%E8%AF%BB%E3%80%8A%E5%90%9B%E4%B8%BB%E8%AE%BA%E3%80%8B%E5%90%8E%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="读《君主论》后篇"><a href="#读《君主论》后篇" class="headerlink" title="读《君主论》后篇"></a>读《君主论》后篇</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><a href="http://xxxdk.xyz/xxx/2020/08/%E8%AF%BB%E3%80%8A%E5%90%9B%E4%B8%BB%E8%AE%BA%E3%80%8B%E5%89%8D%E7%AF%87/">读《君主论》前篇</a> </p><p><a href="https://baike.baidu.com/item/%E5%B0%BC%E5%8F%AF%E7%BD%97%C2%B7%E9%A9%AC%E5%9F%BA%E4%BA%9A%E7%BB%B4%E5%88%A9/1117363">尼可罗·马基雅维里</a></p><p>豆瓣：<a href="https://book.douban.com/subject/1060774/">《君主论》</a></p><p>我在前篇的疑惑，马基雅维里为什么只关注军事，对于民生、国家治理基本不讲述？在我看到第十四章终于有了答案。</p><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>第十四章，君主关于军事方面的责任</p><p><em>君主除了战争、军事制度和训练之外，不应该有其他的目标、其他的思想，也不应该把其他事情作为自己的专业，因为这是进行统帅的人应有的唯一的专业。译者注：这是有意夸张的表达，但是它符合马基雅维里的一个观点，根据这个观点，君主可以（甚至应该）将民事管理工作交给自己选择的地方官，而自己绝对地掌握战争事务。</em></p><p>第十一章到第十四章，马基雅维里在论述不同军队，并始终认为，君主应该拥有自己的军队，不管在战争还是和平时期，都应该将军事放在首位，民事经营可交由地方官处理。</p><p>第十七章，论残酷与仁慈，被人爱戴是否比被人畏惧来得好些</p><p><em>新的国家充满着危险，要避免残酷之名是不可能的。维吉尔借迪多的口说道：</em></p><p>​            <em>“严峻的形势、崭新的邦家，</em></p><p>​            <em>命我森严壁垒，警戒着海角天涯。”</em></p><p><em>但是，君主对于信任他人或者采取行动则务须慎重；不过，也不要杯弓蛇影，妄自惊慌。他应该慎思明辨，人道为怀，有节制地行事，以免由于过分自信而使自己流于轻率鲁莽，或者由于过分猜疑而使自己褊狭不能容人。</em></p><p><em>现在我们回到关于被人畏惧或者被人爱戴这个问题上来。我的结论是：人们爱戴君主，是基于他们自己的意志，而感到畏惧则是基于君主的意志，因此一位明智的君主应当立足在自己的意志之上，而不是立足在他人的意志之上。他只是必须努力避免招仇惹恨，犹如前述。</em></p><p>第十八章，论君主应当怎样守信</p><p>根据译者的注释，本章是马基雅维里的名著中受后世许多评论家最严厉非议的一章。本章所述是君主应该明白不做恶，而非必要情况下，无需讲究信义与仁慈。可以表现得慈悲为怀、笃守信义、合乎人道、清廉正直、虔敬信神，但内心应明白人性本恶而保持狡猾，一切不过是应做的表面功夫罢了。</p><p>第十九章，论应该避免受到蔑视与憎恨</p><p><em>君主如果被人认为变幻无常、轻率浅薄、软弱怯懦、优柔寡断，就会受到轻视。因此，他必须像提防暗礁一样提防这一切。他应该努力在行动中表现伟大、英勇、严肃庄重、坚韧不拔、关于臣民的私事问题，他所作的决断应该是不可更改的。而且他应该支持人们对他抱有这样一种见解：谁都不要指望欺骗他或者瞒过他。</em></p><p>我理解，做人也是如此。</p><p>本章马基雅维里用大量罗马皇帝从称帝到被杀的事情做为例子，简述避免受到蔑视与憎恨的重要，以及人民与军队之间的平衡之道。</p><p>第二十一章，君主为了受人尊敬应当怎样为人</p><p>君主应该为了受人尊敬应当怎样为人？<br>马基雅维里开头就基本说明了一切，世上没有任何事情比得上伟大的事业和做出卓越的范例，能够使君主赢得人们更大的尊敬。同时也讨论了军事外交上，应该中立还是支持一方，马基雅维里是推荐表态赞同一方。中立是怯懦的，优柔寡断的表现，选边胜利可以获得利益，失败也能获得尊敬。但在行动上不应该结盟或依赖比自己强大的国家，事后只会成为其附庸，除非迫不得已。<br>同时君主应该在多重不利情况下，谨慎认识本质，选择害处最少为最佳途径。君主也必须表明自己是爱才之人，激励行业中的杰出人物，给予荣誉，促使城市、国家发展。</p><p>第二十四章，意大利的君主们为什么丧失了他们的国家</p><p><em>因此我们的这些君主们，如果曾经享有王国多年而后来丧失了国家的话，他们不应咒骂命运而应该咒骂自己庸碌无能。在气候好的时候从不考虑可能出现的变化（在风和日丽的时候不想到暴风雨，这是人们的共同的短处），到了有朝一日恶劣的气候来临的时候，他们就只想到逃跑而不是考虑自己怎样进行防卫。他们希望人民在惨遭征服者凌辱之余，召唤他们回来。如果再没有别的法子，这个主意也是好的。但是寄希望于此而忽视其他补救之道，这就糟透了，因为，任何人绝不应该因为相信有人日后会使他复位，而自甘倒台。再说，那种情况或者是不会出现，或者是即使出现，它并不给你带来安全，因为这是一种懦夫的防卫之道，而不是依靠你自己。而只有依靠你自己和你自己的能力来保卫，才是可靠的、有把握的和持久的。</em></p><p>第二十五章，命运在人世事务上有多大力量和怎么样对抗</p><p><em>因此我得出的结论是：当命运正在变化之中而人们仍然顽强地坚持自己的方法时，如果人们同命运密切地协调，他们就成功了；而如果不协调，他们就不成功。我确实认为是这样：迅猛胜于小心谨慎，因为命运之神是一个女子，你想要压倒她，就必须打她，冲击她。人们可以看到，她宁愿让那样行动的人们去征服她，胜过那些冷冰冰地进行工作的人们。因此，正如女子一徉，命运常常是青年人的朋友，因为他们在小心谨慎方面较差，但是比较凶猛，而且能够更加大胆地制服她。</em></p><p>意思是未雨绸缪，顺势而为，灵活多变，明白自己的舒适区，平时多做积累并适时的去调整，而不是当舒适区变成危险区才改变。想起我们的芯片架构大牛这样说过：鸡蛋从外部打破，做成煎蛋是很美味的；从内部打破，那就是生命；保持不动，只能变坏被丢弃。</p><p>第二十六章，奉劝将意大利从蛮族手中解放出来</p><p>马基雅维里总结前文，引经据典，希望看到本书的君主（洛伦佐·梅迪奇？），可以一统意大利。</p><p>译后记<br>记述翻译过程的艰辛，迭代四稿，历时20余年，查阅资料涉及数国。</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>终于看完君主论了，总得来说：</p><p>放以前是枪杆子里出政权，放现代是科技是第一生产力。</p><p>水能载舟，亦能覆舟。</p><p>夫以铜为镜，可以正衣冠；以史为镜，可以知兴替；以人为镜，可以明得失。</p>]]></content>
    
    
    <categories>
      
      <category>提升</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eMMC器件相关寄存器简介</title>
    <link href="/xxx/2020/09/eMMC%E5%99%A8%E4%BB%B6%E5%85%B3%E9%94%AE%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B/"/>
    <url>/xxx/2020/09/eMMC%E5%99%A8%E4%BB%B6%E5%85%B3%E9%94%AE%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>eMMC / SD Card / SDIO是三个非常有趣的设备/接口，在 Linux，它们的驱动都放在了 “drivers/mmc”目录，协议是两个不同的组织制定的。</p><p>JDEDC在 JESD84-B51协议中定义了七个 eMMC设备接口寄存器，OCR、CID、CSD、EXT_CSD、RCA、DSR和 QSR。</p><h4 id="OCR"><a href="#OCR" class="headerlink" title="OCR"></a>OCR</h4><p>工作条件寄存器，Operation conditions register，32 bits。通过 CMD1（SEND_OP_COND）获取，在 CMD线上传输，包括以下信息：</p><p><img src="http://pic.xxxdk.xyz/eMMC%E5%99%A8%E4%BB%B6%E5%85%B3%E9%94%AE%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B-OCR.jpg" alt="OCR"></p><p>bit [23:7]，device的工作电压配置，即 host与 device通信所需的电压范围；</p><p>bit [30:29]，表明 device的访问模式，包括按 byte寻址和按 sector寻址，容量小于等于 2GB的 eMMC器件为 byte mode，大于2GB的为 sector mode（host也可以通过 EXT_CSD [215:212]寄存器的 SEC_COUNT来确认寻址模式）；</p><p>bit [31]，状态信息位，在 device初始化完成后置位。</p><h4 id="CID"><a href="#CID" class="headerlink" title="CID"></a>CID</h4><p>设备识别寄存器，Device IDentification register，128 bits。通过 CMD2（ALL_SEND_CID）或 CMD10（SEND_CID）获取，在 CMD线上传输。CMD2在 Ready State阶段获取，CMD10在 Stand-by State阶段使用，并且需要指定 RCA。CID寄存器的值是唯一的，常用于产品身份识别、key的派生等。CID寄存器包括以下信息：</p><p><img src="http://pic.xxxdk.xyz/eMMC%E5%99%A8%E4%BB%B6%E5%85%B3%E9%94%AE%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B-CID.jpg" alt="CID"></p><h4 id="CSD"><a href="#CSD" class="headerlink" title="CSD"></a>CSD</h4><p>设备特性数据寄存器，Device-Specific Data register，128 bits。通过 CMD9（SEND_CSD）获取。CSD寄存器提供了 device内容访问方式的信息，定义了数据格式、纠错类型、最长数据访问时间、数据传输速度、DSR寄存器是否可用等。可以通过 CMD27（PROGRAM_CSD）对可编程部分（marked by W/E）进行修改。详细信息可查看协议 7.3 CSD Register，内容如下：</p><p><img src="http://pic.xxxdk.xyz/eMMC%E5%99%A8%E4%BB%B6%E5%85%B3%E9%94%AE%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B-CSD.jpg" alt="CSD"></p><p>CCC 表示 eMMC支持的指令集；READ_BL_LEN表示读块的最大长度，WRITE_BL_LEN与它一致；DSR_IMP用于确认 DSR寄存器是否允许配置。</p><h4 id="EXT-CSD"><a href="#EXT-CSD" class="headerlink" title="EXT_CSD"></a>EXT_CSD</h4><p>扩展设备特性数据寄存器，Extended CSD register，512 bytes。通过 CMD8（SEND_EXT_CSD）获取。高 320 bytes是属性段，定义了 device的能力，不能被host修改，低 192 bytes是模式段，定义了 device的工作配置，可以通过 CMD6（SWITCH）改变。EXT_CSD寄存器内容较长，可自行查看协议 7.4  Extended CSD register。EXT_CSD寄存器的作用十分的丰富：</p><p>1、切换 eMMC boot/RPMB/User Data分区（PARTITION_CONFIG [179] [2:0] PARTITION_ACCESS）；</p><p>2、查看 eMMC寿命（DEVICE_LIFE_TIME_EST_TYP_B [269]、DEVICE_LIFE_TIME_EST_TYP_A [268]、PRE_EOL_INFO [267]）；</p><p>3、可靠写（WR_REL_PARAM [166]、ERASE_GROUP_DEF [175]=0x1、WR_REL_SET [167]=0x1f/all、PARTITION_SETTING_COMPLETED [155]=0x1）；</p><p>4、写保护（HC_ERASE_GRP_SIZE [224]、ERASE_GROUP_DEF [175]、HC_WP_GRP_SIZE [221]）</p><p>5、… 等。</p><h4 id="RCA"><a href="#RCA" class="headerlink" title="RCA"></a>RCA</h4><p>相对地址寄存器，Relative Device address register，16 bits。通过 CMD3（SET_RELATIVE_ADDR）设置。host在 Identification State阶段对 device设置地址，用于后续的通信。</p><h4 id="DSR"><a href="#DSR" class="headerlink" title="DSR"></a>DSR</h4><p>Driver stage register，16 bits，通过 CMD4（SET_DSR）配置。它可选择性地用于改善总线在扩展工作条件下的性能（取决于总线长度、传输速率或设备数量等参数）。具体影响 CMD和 DAT的总线驱动器中的预驱动级（ pre-driver stage）和互补驱动晶体管，配置预驱动级的输出电压的上升和下降时间和互补驱动晶体管的数量。实际场景还未遇到需要配置的情况。</p><h4 id="QSR"><a href="#QSR" class="headerlink" title="QSR"></a>QSR</h4><p>队列状态寄存器，Queue Status Register，队列状态寄存器，32 bits。通过 CMD13（SEND_STATUS）并设置传参 SQS位（bit [15]）为 1，进行一次 QSR查询，host用以确认各任务队列处于准备中还是准备执行。CMDQ相关知识，建议多看协议 “Command Queuing”相关内容，例如 “Annex B (Normative) Host Controller Interface for Command Queuing”。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eMMC</tag>
      
      <tag>mmc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《君主论》前篇</title>
    <link href="/xxx/2020/08/%E8%AF%BB%E3%80%8A%E5%90%9B%E4%B8%BB%E8%AE%BA%E3%80%8B%E5%89%8D%E7%AF%87/"/>
    <url>/xxx/2020/08/%E8%AF%BB%E3%80%8A%E5%90%9B%E4%B8%BB%E8%AE%BA%E3%80%8B%E5%89%8D%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>《君主论》的背景对于大多数人太过于陌生了，在阅读之前可以去了解下 14到16世纪的欧洲历史。这里是一些参考链接：</p><p><a href="https://www.fmprc.gov.cn/web/gjhdq_676201/gj_676203/oz_678770/1206_679882/1206x0_679884/">意大利国家概况</a></p><p><a href="https://www.zhihu.com/question/23482738">欧洲历史的脉络是怎样的？</a></p><p><a href="https://baijiahao.baidu.com/s?id=1613018410737442933">16世纪的欧洲到底是什么样子的？当时的人们是怎样的一种生活状态</a></p><p><a href="https://www.sohu.com/a/236913122_802893">让意大利由贵族变屌丝的意大利战争</a></p><img src="http://pic.xxxdk.xyz/%E8%AF%BB%E3%80%8A%E5%90%9B%E4%B8%BB%E8%AE%BA%E3%80%8B%E5%89%8D%E7%AF%871.jpg" alt="当今意大利"  /> <p><img src="http://pic.xxxdk.xyz/%E8%AF%BB%E3%80%8A%E5%90%9B%E4%B8%BB%E8%AE%BA%E3%80%8B%E5%89%8D%E7%AF%872.jpg" alt="15世纪的意大利"></p><p>前图是当今意大利，后图是15世纪的意大利，我们可以透过意大利语的表音，猜出其中的中文地名。</p><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>从第一章到第十一章，作者介绍了他所认知的君主国，包括确立君主的路径（类型），统治国家的方式，是否统治自由，君主与人民、贵族、外敌和教廷的关系；是借住外力(法国、教廷)，或是贵族，还是人民成为君主；后续维持统治的依赖人民、巩固城防、统御贵族与官吏、抵御外敌以及征服等方面。并没有章节描述工商业、农业等社会发展方面，在以经济发展为中心大背景成长的我看来有点违和，考虑作者的从政领域主要是外交与军事，或许也正常吧。但很多东西都是点到即止，如果君主没有一个很好的历史知识储备，阅读《君主论》估计需要一位老师从旁说明吧。目前个人觉得作者所说的国家，不过是中国一座地级市大小的领域，讨论的东西总有点“小”，没有君王应该一统天下的感觉。或许东西方的差异在那时候或者更早的时候就深入骨髓了。书中描述的国与国之间碰撞如此激烈，不经让人想到以前的冷战，现在的中美，老大与老二的较量。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">因此，我的结论是：任何一个君主国如果没有自己的军队，它是不稳固的。反之，一个君主国在不利的情况下，如果没有实力带着信心防卫自已，它就不得不完全依靠侥幸了。明智的人们常常提出这样的意见和论断：“世界上最弱和最不牢固的东西，莫过于不以自己的力量为基础的权力的声誉了”。<br></code></pre></td></tr></table></figure><p>我理解，作者推崇君主应该拥有完全由公民组成的军队，而非雇佣军或是外国援军。我对这个主张是有所疑惑，但黑格尔常说，存在即合理。在当时的欧洲，君主使用雇佣军或是外国援军肯定是有其考虑的，而且并不是只有作者所在的佛罗伦萨这样，强大的法国就只有骑兵，步兵也是雇佣瑞士人。这背后的原因是因为君主无法长期供养自己的军队，雇佣军队性价比高，民众没有参军习惯并反对征兵制，国内政治氛围、征召男丁影响社会生产进而影响君主税收还是其他原因呢？</p><p>《君主论》阅读得有点吃力，它所描述的人物、事件、时间都与我相去甚远，在理解上能感受到自己知识储备的薄弱。其一，我不清楚精细中国的古代史，无法做类比，其二，欧洲古代史更是一片空白，它们的国家的数量和变迁，国内南北朝和五代十国也是小巫见大巫。这大概是译者的序言为何篇幅比作者绝大多数章节还要长的原因。译者如果不从作者生平、历史上的地位、历史背景、关键事件等方面向读者粗略介绍一遍，那这本书就无法让人沉浸并思考，从而有所感悟收获。目前我只读完本书前七章，后面的精华都还没接触。当前收获只觉得书中思想、行事方法，在生活中较难用上，反而在国家大局，世界形势发展却可以套用，如香港、澳门、台湾和中印，或是最近的亚美尼亚与阿塞拜疆的纳卡之争以及背后的俄罗斯与土耳其。</p><p>在此小计，以待通读后进行对比。</p>]]></content>
    
    
    <categories>
      
      <category>提升</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>目标管理：SMART原则</title>
    <link href="/xxx/2020/07/%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86%EF%BC%9ASMART%E6%B3%95%E5%88%99/"/>
    <url>/xxx/2020/07/%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86%EF%BC%9ASMART%E6%B3%95%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>最近业务量在不断的增加，事项积压也有点严重，大佬为了团队建设和提高大家的工作效率，就弄了个茶会，进行了一波组内赋能，其中就包括 SMART法则。只有确定一个个的目标，才能在有限的时间明确要做的事情，避免大脑混乱，迷失方向，从而提高效率。当然也要预留好 buffer，防止 interrupt。这方面与编程就很像了，空间换时间。</p><h4 id="SMART法则"><a href="#SMART法则" class="headerlink" title="SMART法则"></a>SMART法则</h4><p>即 Specific、Measurable、Attainable、Relevant、Time-based。一句话，将目标确定为具体、可量化、可达成、相关联和时间安排合理。</p><h4 id="Specific（具体）"><a href="#Specific（具体）" class="headerlink" title="Specific（具体）"></a>Specific（具体）</h4><p>在设定目标的时候，一定不能是模糊、抽象的。必须清楚地了解需求是什么，问题是什么，否则后续重新确定需求、问题的过程会十分耗费时间，或是一开始就路径错误，失之毫厘，差之千里。同时定义精确一点的目标，可以帮助自己更轻松的达成目标。</p><h4 id="Measurable（可衡量）"><a href="#Measurable（可衡量）" class="headerlink" title="Measurable（可衡量）"></a>Measurable（可衡量）</h4><p>量化自己的目标，清楚地了解自己通过怎么样的途径和方式可以达成目标。例如，进行 CSCE整改，不要描述为三天完成，应该明确为每天要解决多少条，或是将某个规则的报告数清零。</p><h4 id="Attainable（可达成）"><a href="#Attainable（可达成）" class="headerlink" title="Attainable（可达成）"></a>Attainable（可达成）</h4><p>制定的目标必须是合理的，真实可行的。我们需要对自己的能力有准确的把握，不能设定超出自身能力的目标，不然目标永远都完成不了。当然也不能设定过于简单的目标，这样会拉低自身效率，降低自己实现更高目标的心理预期，提高标准完成的目标也会给自己带来个人满足。</p><h4 id="Relevant（相关联的）"><a href="#Relevant（相关联的）" class="headerlink" title="Relevant（相关联的）"></a>Relevant（相关联的）</h4><p>这条可以是对相关资源的把握，也可以是设定的目标集应该与一个更大的目标相关。在一个大团队中工作，资源总是有限的，我们需要确保有足够的资源支撑目标的完成，没有资源的时候应该及时上升，报风险。例如协调回片时，资源紧张的温冲箱，解信号相关问题时，提前准备好测量信号的示波器等。对于目标集与大目标，如果设定的小目标与你的大目标无关紧要，结果也不会很在乎，那付出的实际投入可能会很少，这个目标最后面可能会 delay或者是 abandon。毕竟我是搞底层驱动的，哪天想写个 Android app去测试自己的驱动就有点偏题了。</p><h4 id="Time-based（时限）"><a href="#Time-based（时限）" class="headerlink" title="Time-based（时限）"></a>Time-based（时限）</h4><p>合理的时间安排，明确的时间节点，完善的时间框架，这样才能将时间用在正确的事情上，同时时间节点带来的紧迫感提升工作效率。否则缺乏时间计划性，即使一个目标完成了，后续的目标还是会受影响，出现系统性的爆雷。</p><p>通过上述知识点，我们在制定项目交付节点，每天工作安排中就可以做到心中有谱，脑子不乱。当然处理事项还要考虑优先级、自身的执行力等。进一步提升自我能力还有经典的二八原则、职责清晰的 6W1H原则、有效管理的 PDCA原则等。</p><p>一句话，光说不练假把式。</p>]]></content>
    
    
    <categories>
      
      <category>提升</category>
      
    </categories>
    
    
    <tags>
      
      <tag>目标管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转载】预加重、去加重和均衡</title>
    <link href="/xxx/2020/07/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E9%A2%84%E5%8A%A0%E9%87%8D%E3%80%81%E5%8E%BB%E5%8A%A0%E9%87%8D%E5%92%8C%E5%9D%87%E8%A1%A1/"/>
    <url>/xxx/2020/07/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E9%A2%84%E5%8A%A0%E9%87%8D%E3%80%81%E5%8E%BB%E5%8A%A0%E9%87%8D%E5%92%8C%E5%9D%87%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<p>USB是高速信号，虽然信号相关的问题都是模拟或者硬件的同事去处理的，但芯片回片的时候，软件还是需要去配置一些信号相关指标，例如校正眼图。这些过程中就有机会接触到相关的知识、或者产生相关的疑问，如预加重、去加重、展频等。</p><p>最近看到一篇关于信号处理的好文章，简单易懂，解答了我关于预加重的疑问，特意转载！可惜原文链接已经失效，无法找到原作者，如果有幸被原作者看到，不希望我转载或者有别的疑惑，请与我联系。下面即是正文。</p><h4 id="高速信号调整技术"><a href="#高速信号调整技术" class="headerlink" title="高速信号调整技术"></a>高速信号调整技术</h4><p>随着信号速率的增加，高速信号的趋肤效应和传输线的介质损耗，使信号在传输过程中受损很大，为了在接收终端能得到比较好的波形，就需要对受损的信号进行补偿，常用的补偿技术有：预加重、去加重和均衡在介绍这三种信号补偿技术之前，先来介绍下趋肤效应和介质损耗。</p><h4 id="趋肤效应"><a href="#趋肤效应" class="headerlink" title="趋肤效应"></a>趋肤效应</h4><p>交变电流(alternating electric current, AC)通过导体时，由于感应作用引起导体截面上电流分布不均匀，愈近导体表面电流密度越大。这种现象称“趋肤效应”。趋肤效应使导体的有效电阻增加。频率越高，趋肤效应越显著。当频率很高的电流通过导线时，可以认为电流只在导线表面上很薄的一层中流过，这等效于导线的截面减小，电阻增大。</p><h4 id="介质损耗"><a href="#介质损耗" class="headerlink" title="介质损耗"></a>介质损耗</h4><p>绝缘材料在电场作用下，由于介质电导和介质极化的滞后效应，在其内部引起的能量损耗叫介质损耗。在交变电场作用下，电介质内流过的电流相量和电压相量之间的夹角叫做介质损耗角，该角的正切值称为介质损耗因素。</p><p>在高速信号传输中，信号的高频分量衰减要比低频分量的衰减大很多，传输线路表现出来的特性像一个低通滤波器。如下图所示。</p><p><img src="http://pic.xxxdk.xyz/%E9%A2%84%E5%8A%A0%E9%87%8D-%E9%AB%98%E9%80%9F%E4%BF%A1%E5%8F%B7%E4%BC%A0%E8%BE%93%E7%89%B9%E6%80%A7.jpg" alt="高速信号传输特性"></p><h4 id="预加重-Pre-emphasis"><a href="#预加重-Pre-emphasis" class="headerlink" title="预加重 (Pre-emphasis)"></a>预加重 (Pre-emphasis)</h4><p>前面已经介绍过了，信号传输线表现出来的是低通滤波特性，传输过程中信号的高频成分衰减大，低频成分衰减少。预加重技术的思想就是在传输线的始端增强信号的高频成分，以补偿高频分量在传输过程中的过大衰减。我们知道，信号频率的高低主要是由信号电平变化的速度决定的，所以信号的高频分量主要出现在信号的上升沿和下降沿处，预加重技术就是增强信号上升沿和下降沿处的幅度。如下图所示。</p><p><img src="http://pic.xxxdk.xyz/%E9%A2%84%E5%8A%A0%E9%87%8D-%E9%A2%84%E5%8A%A0%E9%87%8D.jpg" alt="预加重"></p><h4 id="去加重-De-emphasis"><a href="#去加重-De-emphasis" class="headerlink" title="去加重(De-emphasis)"></a>去加重(De-emphasis)</h4><p>去加重技术的思想跟预加重技术有点类似，只是实现方法有点不同，预加重是增加信号上升沿和下降沿处的幅度，其它地方幅度不变；而去加重是保持信号上升沿和下降沿处的幅度不变，其他地方信号减弱。如下图所示。</p><p><img src="http://pic.xxxdk.xyz/%E9%A2%84%E5%8A%A0%E9%87%8D-%E5%8E%BB%E5%8A%A0%E9%87%8D.jpg" alt="去加重"></p><p>去加重补偿后的信号摆渡比预加重补偿后的信号摆幅小，眼图高度低，功耗小，EMC辐射小。</p><h4 id="均衡器"><a href="#均衡器" class="headerlink" title="均衡器"></a>均衡器</h4><p>前面介绍的预加重和去加重能很好的补偿信号在传输过程中的损耗，改善信号质量，但是预加重和去加重技术也存在一些缺陷，比如当线路上存在串扰时，预加重和去加重会将高频串扰分量放大，增大串扰的危害。为了弥补预加重和去加重技术的缺陷，后来就出现了均衡技术。</p><p>跟预加重和去加重不同，均衡技术在信号的接收端使用，它的特性相当于一个高通滤波器，高频分量会损耗很大，正好可以滤除高频串扰。其原理如下：</p><p><img src="http://pic.xxxdk.xyz/%E9%A2%84%E5%8A%A0%E9%87%8D-%E6%80%BB%E5%93%8D%E5%BA%94.jpg" alt="总响应"></p><p>均衡器实际上是一个高通滤波器，下图是一个简单的高通滤波器，即均衡器。</p><p><img src="http://pic.xxxdk.xyz/%E9%A2%84%E5%8A%A0%E9%87%8D-%E5%9D%87%E8%A1%A1%E5%99%A8.jpg" alt="均衡器"></p><p>转自:<a href="http://hi.baidu.com/wizard_li/item/bf9b20aa116c48f715329bc8">http://hi.baidu.com/wizard_li/item/bf9b20aa116c48f715329bc8</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>信号处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SCSI ASC/ASCQ 摘述</title>
    <link href="/xxx/2020/06/SCSI-ASC-ASCQ-%E6%91%98%E8%BF%B0/"/>
    <url>/xxx/2020/06/SCSI-ASC-ASCQ-%E6%91%98%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>前两篇 SCSI相关文章如下，结合本文基本可以快速定位 SCSI相关的问题。例如 U盘、移动硬盘热插拔不识别、读写文件失败或是读写引起 USB disconnect的问题。</p><p><a href="http://xxxdk.xyz/xxx/2020/03/SCSI-Operation-Codes/">SCSI Operation Codes</a></p><p><a href="http://xxxdk.xyz/xxx/2020/01/SCSI-%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E8%A1%A8%E6%95%B4%E7%90%86/">SCSI 错误信息表整理</a></p><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>出现 SCSI相关错误的时候，我们总能看到下面这样的 log。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sd <span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>: [sda] ASC=<span class="hljs-number">0x28</span> ASCQ=<span class="hljs-number">0x0</span><br></code></pre></td></tr></table></figure><p>log里面的关键词是 ASC和 ASCQ，大概的意思是：</p><p>ASC（ADDITIONAL SENSE CODE），附加检测码，用来描述 sense key报告的错误或者异常情况的更多信息，如果设备没有错误或者异常情况，则附加检测码应该设置为零。</p><p>ASCQ（ADDITIONAL SENSE CODE QUALIFIER），附加检测码的限定符，用来描述与附加检测码相关的详细信息，如果设备没有错误或者异常情况，则附加检测码的限定符应该设置为零。</p><p>在 log中 ASC=0x28、ASCQ=0x0，通过查表确定 sense key报告的详细信息是 NOT READY TO READY CHANGE, MEDIUM MAY HAVE CHANGED，大概意思 U盘中的存储介质发生了改变，即 U盘主控还在，但储存介质出现异常，主控无法对储存介质进行读写。例如出现了 U盘主控与介质通信部分的软件或者逻辑异常、介质命令阻塞、遇到坏块等问题，当然具体原因还是要根据实际应用场景分析。</p><h4 id="附表"><a href="#附表" class="headerlink" title="附表"></a>附表</h4><p>ASC值对应的具体含义如下，ASCQ值对应的具体含义可以跟随链接，在 <a href="https://www.t10.org/lists/asc-num.htm">t10.org</a>了解，或是查询 <em>SCSI Commands Reference Manual –&gt; 2.4.1.6 Additional Sense and Additional Sense Qualifier codes</em>。</p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_00">00h/00h NO ADDITIONAL SENSE INFORMATION</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_01">01h/00h NO INDEX/SECTOR SIGNAL</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_02">02h/00h NO SEEK COMPLETE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_03">03h/00h PERIPHERAL DEVICE WRITE FAULT</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_04">04h/00h LOGICAL UNIT NOT READY, CAUSE NOT REPORTABLE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_05">05h/00h LOGICAL UNIT DOES NOT RESPOND TO SELECTION</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_06">06h/00h NO REFERENCE POSITION FOUND</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_07">07h/00h MULTIPLE PERIPHERAL DEVICES SELECTED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_08">08h/00h LOGICAL UNIT COMMUNICATION FAILURE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_09">09h/00h TRACK FOLLOWING ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_0A">0Ah/00h ERROR LOG OVERFLOW</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_0B">0Bh/00h WARNING</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_0C">0Ch/00h WRITE ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_0D">0Dh/00h ERROR DETECTED BY THIRD PARTY TEMPORARY INITIATOR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_0E">0Eh/00h INVALID INFORMATION UNIT</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_10">10h/00h ID CRC OR ECC ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_11">11h/00h UNRECOVERED READ ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_12">12h/00h ADDRESS MARK NOT FOUND FOR ID FIELD</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_13">13h/00h ADDRESS MARK NOT FOUND FOR DATA FIELD</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_14">14h/00h RECORDED ENTITY NOT FOUND</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_15">15h/00h RANDOM POSITIONING ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_16">16h/00h DATA SYNCHRONIZATION MARK ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_17">17h/00h RECOVERED DATA WITH NO ERROR CORRECTION APPLIED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_18">18h/00h RECOVERED DATA WITH ERROR CORRECTION APPLIED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_19">19h/00h DEFECT LIST ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_1A">1Ah/00h PARAMETER LIST LENGTH ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_1B">1Bh/00h SYNCHRONOUS DATA TRANSFER ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_1C">1Ch/00h DEFECT LIST NOT FOUND</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_1D">1Dh/00h MISCOMPARE DURING VERIFY OPERATION</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_1E">1Eh/00h RECOVERED ID WITH ECC CORRECTION</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_1F">1Fh/00h PARTIAL DEFECT LIST TRANSFER</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_20">20h/00h INVALID COMMAND OPERATION CODE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_21">21h/00h LOGICAL BLOCK ADDRESS OUT OF RANGE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_22">22h/00h ILLEGAL FUNCTION (USE 20 00, 24 00, OR 26 00)</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_23">23h/00h INVALID TOKEN OPERATION, CAUSE NOT REPORTABLE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_24">24h/00h INVALID FIELD IN CDB</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_25">25h/00h LOGICAL UNIT NOT SUPPORTED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_26">26h/00h INVALID FIELD IN PARAMETER LIST</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_27">27h/00h WRITE PROTECTED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_28">28h/00h NOT READY TO READY CHANGE, MEDIUM MAY HAVE CHANGED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_29">29h/00h POWER ON, RESET, OR BUS DEVICE RESET OCCURRED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_2A">2Ah/00h PARAMETERS CHANGED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_2B">2Bh/00h COPY CANNOT EXECUTE SINCE HOST CANNOT DISCONNECT</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_2C">2Ch/00h COMMAND SEQUENCE ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_2D">2Dh/00h OVERWRITE ERROR ON UPDATE IN PLACE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_2E">2Eh/00h INSUFFICIENT TIME FOR OPERATION</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_2F">2Fh/00h COMMANDS CLEARED BY ANOTHER INITIATOR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_30">30h/00h INCOMPATIBLE MEDIUM INSTALLED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_31">31h/00h MEDIUM FORMAT CORRUPTED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_32">32h/00h NO DEFECT SPARE LOCATION AVAILABLE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_33">33h/00h TAPE LENGTH ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_34">34h/00h ENCLOSURE FAILURE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_35">35h/00h ENCLOSURE SERVICES FAILURE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_36">36h/00h RIBBON, INK, OR TONER FAILURE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_37">37h/00h ROUNDED PARAMETER</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_38">38h/00h EVENT STATUS NOTIFICATION</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_39">39h/00h SAVING PARAMETERS NOT SUPPORTED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_3A">3Ah/00h MEDIUM NOT PRESENT</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_3B">3Bh/00h SEQUENTIAL POSITIONING ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_3D">3Dh/00h INVALID BITS IN IDENTIFY MESSAGE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_3E">3Eh/00h LOGICAL UNIT HAS NOT SELF-CONFIGURED YET</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_3F">3Fh/00h TARGET OPERATING CONDITIONS HAVE CHANGED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_40">40h/00h RAM FAILURE (SHOULD USE 40 NN)</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_41">41h/00h DATA PATH FAILURE (SHOULD USE 40 NN)</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_42">42h/00h POWER-ON OR SELF-TEST FAILURE (SHOULD USE 40 NN)</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_43">43h/00h MESSAGE ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_44">44h/00h INTERNAL TARGET FAILURE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_45">45h/00h SELECT OR RESELECT FAILURE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_46">46h/00h UNSUCCESSFUL SOFT RESET</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_47">47h/00h SCSI PARITY ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_48">48h/00h INITIATOR DETECTED ERROR MESSAGE RECEIVED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_49">49h/00h INVALID MESSAGE ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_4A">4Ah/00h COMMAND PHASE ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_4B">4Bh/00h DATA PHASE ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_4C">4Ch/00h LOGICAL UNIT FAILED SELF-CONFIGURATION</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_4E">4Eh/00h OVERLAPPED COMMANDS ATTEMPTED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_50">50h/00h WRITE APPEND ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_51">51h/00h ERASE FAILURE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_52">52h/00h CARTRIDGE FAULT</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_53">53h/00h MEDIA LOAD OR EJECT FAILED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_54">54h/00h SCSI TO HOST SYSTEM INTERFACE FAILURE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_55">55h/00h SYSTEM RESOURCE FAILURE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_57">57h/00h UNABLE TO RECOVER TABLE-OF-CONTENTS</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_58">58h/00h GENERATION DOES NOT EXIST</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_59">59h/00h UPDATED BLOCK READ</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_5A">5Ah/00h OPERATOR REQUEST OR STATE CHANGE INPUT</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_5B">5Bh/00h LOG EXCEPTION</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_5C">5Ch/00h RPL STATUS CHANGE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_5D">5Dh/00h FAILURE PREDICTION THRESHOLD EXCEEDED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_5E">5Eh/00h LOW POWER CONDITION ON</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_60">60h/00h LAMP FAILURE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_61">61h/00h VIDEO ACQUISITION ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_62">62h/00h SCAN HEAD POSITIONING ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_63">63h/00h END OF USER AREA ENCOUNTERED ON THIS TRACK</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_64">64h/00h ILLEGAL MODE FOR THIS TRACK</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_65">65h/00h VOLTAGE FAULT</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_66">66h/00h AUTOMATIC DOCUMENT FEEDER COVER UP</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_67">67h/00h CONFIGURATION FAILURE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_68">68h/00h LOGICAL UNIT NOT CONFIGURED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_69">69h/00h DATA LOSS ON LOGICAL UNIT</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_6A">6Ah/00h INFORMATIONAL, REFER TO LOG</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_6B">6Bh/00h STATE CHANGE HAS OCCURRED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_6C">6Ch/00h REBUILD FAILURE OCCURRED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_6D">6Dh/00h RECALCULATE FAILURE OCCURRED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_6E">6Eh/00h COMMAND TO LOGICAL UNIT FAILED</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_6F">6Fh/00h COPY PROTECTION KEY EXCHANGE FAILURE - AUTHENTICATION FAILURE</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_71">71h/00h DECOMPRESSION EXCEPTION LONG ALGORITHM ID</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_72">72h/00h SESSION FIXATION ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_73">73h/00h CD CONTROL ERROR</a></p><p><a href="https://www.t10.org/lists/asc-num.htm#ASC_74">74h/00h SECURITY ERROR</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>USB</tag>
      
      <tag>Error</tag>
      
      <tag>SCSI</tag>
      
      <tag>Mass Storage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USB2.0 High Speed 握手略解</title>
    <link href="/xxx/2020/06/USB2-0-High-Speed-%E6%8F%A1%E6%89%8B%E7%95%A5%E8%A7%A3/"/>
    <url>/xxx/2020/06/USB2-0-High-Speed-%E6%8F%A1%E6%89%8B%E7%95%A5%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>USB （Universal Serial Bus） 是一种支持热插拔的高速串行传输总线，它使用差分信号来传输数据，目前已经发布USB 4 协议规格，向下兼容USB 3.2 Gen 2、USB 3.2 Gen 1（USB 3.1） 和 USB 2.0。</p><p>USB 协议是 host 与 device 通过信号握手，来确认使用哪种速度来通信的。其中 SuperSpeed是通过码型来确认的，比较复杂；high-speed、full-speed 和 low-speed 是通过电平高低变化确认的，比较简单。通过了解 high-speed 握手波形，就可以举一反三了明白另外两个了。</p><p>USB 2.0 线材由 4条线组成，VBUS、D+、D- 和 GND。其中 D+、D- 是一对差分信号线，USB 2.0 的握手和数据传输都是依靠它的。具体线材要求可以查看 Specification <em>6.6 Cable Mechanical Configuration and Material Requirements</em>。</p><p><img src="http://pic.xxxdk.xyz/USB2.0%20High%20Speed%20%E6%8F%A1%E6%89%8B%E7%95%A5%E8%A7%A3-cable.png" alt="cable"></p><p>下面是 high-speed 握手波形，在进入 high-speed握手前，会经过 full-speed握手前段。</p><p><img src="http://pic.xxxdk.xyz/USB2.0%20High%20Speed%20%E6%8F%A1%E6%89%8B%E7%95%A5%E8%A7%A3-HS%E6%8F%A1%E6%89%8B.jpg" alt="HS握手"></p><p>before a段：≤100ms，device插入 host，得电（功率足够）后，需要在 100ms内将 D+/D- 拉至 VIH或以上，VIH为 2V。<em>7.1.7.3 Connect and Disconnect Signaling  ∆t2 (T SIGATT )</em></p><p>a-b段：≥100ms，当 host controller通过中断通知软件（USB协议栈）当前 D+已经上拉后，软件将等待 至少 100ms，确保电气和机械连接都是稳定的，此时 D+ 幅值为 3.3V。</p><p>b-c段：2.5μs~3ms，在 b点软件等待 100ms后将会下发 port reset，将 D+拉低，总线进入 SE0状态。</p><p>c-d段：1ms~7ms，device检测到 SE0后必须等待不小于3ms，不大于3.125ms后，将回复一个 Chirp K，已表示自己是一个 high-speed设备，Chirp K必须持续 1~7ms，该 Chirp K幅度为 800mV。</p><p>d-e段：≤100μs，host检测到 device回复的 Chirp K后，将准备发送 Chirp KJ KJ KJ序列。</p><p>e-f 段：host 将发送 Chirp KJ KJ KJ序列，每个Chirp K、Chirp J的持续时间为 40~60μs，如果 device在 1ms~2.5ms未检测到 Chirp KJ KJ KJ序列则会回到 full-speed Default state并等待复位结束。</p><p>f-g 段：50ms，device 检测到 Chirp KJ KJ KJ序列后，将会在 ≤500μs内将自身 D+上拉电阻（terminal 电阻）断开，进入 high-speed Default state，即 device变为 45Ω，信号幅值变为 400mV。Chirp KJ序列会持续 50ms，直到软件会下发 port reset，停止发送Chirp KJ序列，完成 high-speed的握手。</p><p>after g段：进入 high-speed DATA阶段，第一个 packet是 SOF。</p><p>详细信息：<em>7.1.7.5 Reset Signaling、Table 7-13. Hub Event Timings (Continued)、Table 7-14. Device Event Timings</em></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>USB</tag>
      
      <tag>high-speed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USB high-speed disconnect检测</title>
    <link href="/xxx/2020/04/USB-high-speed-disconnect%E6%A3%80%E6%B5%8B/"/>
    <url>/xxx/2020/04/USB-high-speed-disconnect%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>USB 现在已经发展到 4.0了，USB-IF 起名字也是越来越放飞自我，追求真我了，但学学隔壁的 Wi-Fi Alliance不好吗？</p><p>USB目前版本有很多个，今天只讨论 high-speed的 disconnect检测。high-speed的 disconnect绕不开  SOF，因为 disconnect检测就是检测 SOF的 EOP的幅值。SOF是什么？具体描述可以查看这篇博文 <a href="http://xxxdk.xyz/xxx/2020/04/USB-high-speed-SOF/">USB high-speed SOF</a>。</p><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>High-speed Disconnect state是通过 Disconnection Envelope Detector检测 D+/D-上差分幅度确定的。1、当信号幅度 ≥625mV，则 detector必须上报 disconnect state；</p><p>2、信号幅度 ≤525mV时，detector不能上报 disconnect state；</p><p>3、信号幅度处于 525mV至 625mV之间，Specification并没有明确的说明，此处可以理解为由厂商自行决定，即可在芯片回片后的测试确定，根据兼容性测试结果对 USB disconnect指标进行配置。</p><p> (The detector must not indicate that the disconnection threshold has been exceeded if the differential signal amplitude is  ≤ 525 mV, and must indicate that the threshold has been exceeded if the differential signal amplitude is  ≥ 625 mV.)。详见 Table 7-1. Description of Functional Elements in the Example Shown in Figure 7-1 (Continued)、7.1.4.2 High-speed Receiver Characteristics、7.1.7.3 Connect and Disconnect Signaling。</p><p>D+/D-的信号幅度是怎么产生的呢？这需要先从 D+/D-的阻抗说起。</p><p>1、在 high-speed的收发器， D+/D-上的直流负载 Z(HSDRV) 必须为 40.5Ω ≤ Z(HSDRV) ≤ 49.5Ω，即 45Ω±10%；</p><p>2、当 D+/D-处于高电平的时候，V(HSOH)必须为 400mV±10%；</p><p>3、host与 device 的 D+/D-连接的时候，直流负载并联， Z(HSDRV)为 22.5Ω。</p><p>结合上述三点，大概理解为，</p><p>即需要在 high-speed的 PHY中有一个可以提供 17.78mA电流的恒流源。在 device与 host的 D+/D-建立物理连接的时候，因双方的直流负载并联，Z(HSDRV)为 22.5Ω，则有 17.78mA * 22.5Ω = 400mV ，在无设备接入的时候，则有 17.78mA * 45Ω = 800mV。详见 7.1.1.3 High-speed (480 Mb/s) Driver Characteristics。</p><p>Host与 devices high-speed连接成功后，会每隔 125μs发出一个 SOF，而 Disconnection Envelope Detector会去 check每个 SOF EOP的最后 8bit ，如果达到或者超过 disconnect的阈值，则上报disconnect state。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>USB</tag>
      
      <tag>high-speed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USB high-speed SOF</title>
    <link href="/xxx/2020/04/USB-high-speed-SOF/"/>
    <url>/xxx/2020/04/USB-high-speed-SOF/</url>
    
    <content type="html"><![CDATA[<p>SOF（Start Of Frame），帧起始数据包，USB high-speed、full-speed握手成功，进入数据阶段后，发送出来的第一个 packet。high-speed下，host每隔125μs ±0.0625μs发出一个 SOF，full-speed，每隔1ms ±0.0005ms发出一个SOF。Low speed不会发送SOF，而是使用keep alive达到同样的功能。详见 8.4.3 Start-of-Frame Packets、10.2.3 Frame and Microframe Generation。</p><p><img src="http://pic.xxxdk.xyz/USB%20high-speed%20SOF-SOF.png" alt="SOF"></p><p>这个波形信号质量一般，但也足够了。</p><p>high-speed的 SOF 由 SYNC（32Bits）、PID（8Bits）、MicroFrameNumber（14Bits）、CRC5（5Bits）和 EOP（40Bits）组成。SOF作为一种 host与 device之间的帧同步机制，可以防止总线进入 suspend状态以及用于判断 disconnect。 </p><p>SYNC，同步域，主要用于与本地时钟同步。序列为 KJKJKJKJ KJKJKJKJ KJKJKJKJ KJKJKJKK，因为第一个 state必定为 K，所以可以用于判断收到的协议波形的 D+、D-。详见 8.2 SYNC Field、7.1.7.4.2 High-speed Signaling。</p><p>PID（packet identifier），数据包标识符，用于表述当前的 packet的类型，例如 Token（OUT、IN、SOF、SETUP）、Data（DATA0、DATA1、DATA2、MDATA）、Handshake（ACK、NAK、STALL、NYET）和 Special（PRE、ERR、SPLIT、PING），详见 8.3 Packet Field Formats、Table 8-1. PID Types。</p><p>MicroFrameNumber，微帧号，host每发出一个 SOF，frame number就会加一，到达 max后会归零重新开始计数。</p><p>EOP（End-of-Packet），用于表述一个 packet的结束。由 5个没有 bit stuffing的 NRZ byte组成，即 01111111 11111111 11111111 11111111 11111111。在波形上就会出现一个较长无变化的电平。例如 EOP前最后一个是 J，那 EOP就是 40个 K。详见 7.1.13.2.2 High-speed EOP、7.1.7.4.2 High-speed Signaling。</p><p>本文内容主要翻译至 Specification，并加入自己的理解，SOF波形图来自<a href="https://blog.csdn.net/shenjin_s/article/details/87921856">申小白</a>的博客，谢谢。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>USB</tag>
      
      <tag>high-speed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SCSI Operation Codes</title>
    <link href="/xxx/2020/03/SCSI-Operation-Codes/"/>
    <url>/xxx/2020/03/SCSI-Operation-Codes/</url>
    
    <content type="html"><![CDATA[<p>USB Mass Storage 是 USB host侧遇到最多的场景，基于 Bulk传输，使用 SCSI协议进行资源交互。当然 UFS也用到 SCSI协议，在使用 UFS的系统，我们插入 U盘经常生成的 dev节点是 /dev/sdb或者是  /dev/sde 。前面的如 /dev/sda、/dev/sdc这些节点可能就被 UFS占用了，识别 log可能就变成 “sd 1:0:0:0: [sde] …”。 </p><p>在读写有坏块的 U盘时，不免会打印下面的 log。通过 opcode，就可以清楚是什么操作报的错。这里 opcode=0x28，即 READ(10)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">sd <span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>: [sda] tag#<span class="hljs-number">0</span> CDB: opcode=<span class="hljs-number">0x28</span> <span class="hljs-number">28</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">2b</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>d <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>我们还可以阅读 SCSI的 manual，确定这次的 READ(10) 想从 LBA 0x2b0900 读多 0x1d * block size的数据回来。</p><p><img src="http://pic.xxxdk.xyz/SCSI%20Operation%20Codes-READ10.jpg" alt="READ10"></p><p>USB Mass Storage 常用的 SCSI Operation Codes 包括下面这些：</p><table><thead><tr><th>指令代码</th><th>指令名称</th><th>指令说明</th></tr></thead><tbody><tr><td>0x00</td><td>Test Unit Ready</td><td>查询设备是否ready</td></tr><tr><td>0x03</td><td>Request Sense</td><td>主机请求设备返回执行结果，及获取状态信息</td></tr><tr><td>0x12</td><td>Inquiry</td><td>获取设备信息</td></tr><tr><td>0x1A</td><td>Mode Sense(6)</td><td>向host传输参数</td></tr><tr><td>0x5A</td><td>Mode Sense(10)</td><td>向host传输参数</td></tr><tr><td>0x25</td><td>Read Capacity(10)</td><td>读取设备容量</td></tr><tr><td>0x28</td><td>Read(10)</td><td>Host从设备读取数据</td></tr><tr><td>0x2A</td><td>Write(10)</td><td>Host写数据到存储设备</td></tr><tr><td>0x23</td><td>Read Format Capacity</td><td>查询当前容量及可用空间</td></tr><tr><td>0x15</td><td>Mode Select(6)</td><td>允许Host对外部设备设置参数</td></tr><tr><td>0x55</td><td>Mode Select(10)</td><td>允许Host对外部设备设置参数</td></tr><tr><td>0x1E</td><td>Prevent/Allow Medium Removal</td><td>禁止/允许存储介质移动</td></tr><tr><td>0x1B</td><td>Start/Stop Uint</td><td>启动/停止存储单元电源（写保护）</td></tr><tr><td>0xA0</td><td>Report LUNs</td><td>索取设备的LUN数和LUN清单</td></tr><tr><td>0x2F</td><td>Verify</td><td>在存储中验证数据</td></tr></tbody></table><p>下面是全部的 SCSI Operation Codes:</p><table><thead><tr><th align="left">Code</th><th align="left">Command</th></tr></thead><tbody><tr><td align="left">00</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Test_Unit_Ready_Command">TEST UNIT READY</a> (mandatory)</td></tr><tr><td align="left">01</td><td align="left">RECALIBRATE or REWIND</td></tr><tr><td align="left">03</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Request_Sense_Command">REQUEST SENSE</a> (mandatory except RBC)</td></tr><tr><td align="left">04</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Format_Unit_Command">FORMAT UNIT</a></td></tr><tr><td align="left">05</td><td align="left">READ BLOCK LIMITS</td></tr><tr><td align="left">07</td><td align="left">REASSIGN BLOCKS</td></tr><tr><td align="left">07</td><td align="left">INITIALIZE ELEMENT STATUS</td></tr><tr><td align="left">08</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Read_Commands#Read_.286.29">READ (6)</a></td></tr><tr><td align="left">0A</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Write_Commands#Write_.286.29">WRITE (6)</a></td></tr><tr><td align="left">0B</td><td align="left">SEEK (6)</td></tr><tr><td align="left">0F</td><td align="left">READ REVERSE (6)</td></tr><tr><td align="left">10</td><td align="left">WRITE FILEMARKS (6)</td></tr><tr><td align="left">11</td><td align="left">SPACE (6)</td></tr><tr><td align="left">12</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Inquiry_Command">INQUIRY</a> (mandatory)</td></tr><tr><td align="left">13</td><td align="left">VERIFY(6)</td></tr><tr><td align="left">14</td><td align="left">RECOVER BUFFERED DATA</td></tr><tr><td align="left">15</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Mode_Select_Command">MODE SELECT (6)</a></td></tr><tr><td align="left">16</td><td align="left">RESERVE (6)</td></tr><tr><td align="left">17</td><td align="left">RELEASE (6)</td></tr><tr><td align="left">18</td><td align="left">COPY</td></tr><tr><td align="left">19</td><td align="left">ERASE (6)</td></tr><tr><td align="left">1A</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Mode_Sense_Command">MODE SENSE (6)</a></td></tr><tr><td align="left">1B</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Start_Stop_Unit_Command">START/STOP UNIT</a></td></tr><tr><td align="left">1B</td><td align="left">LOAD UNLOAD</td></tr><tr><td align="left">1C</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Receive_Diagnostic_Results_Command">RECEIVE DIAGNOSTIC RESULTS</a></td></tr><tr><td align="left">1D</td><td align="left"><a href="http://en.wikipedia.org/w/index.php?title=SCSI_Send_Diagnostic_Command&action=edit&redlink=1">SEND DIAGNOSTIC</a></td></tr><tr><td align="left">1E</td><td align="left">PREVENT/ALLOW MEDIUM REMOVAL</td></tr><tr><td align="left">23</td><td align="left">READ FORMAT CAPACITIES (MMC)</td></tr><tr><td align="left">24</td><td align="left">SET WINDOW</td></tr><tr><td align="left">25</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Read_Capacity_Command">READ CAPACITY (10)</a></td></tr><tr><td align="left">28</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Read_Commands#Read_.2810.29">READ (10)</a></td></tr><tr><td align="left">29</td><td align="left">READ GENERATION</td></tr><tr><td align="left">2A</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Write_Commands#Write_.2810.29">WRITE (10)</a></td></tr><tr><td align="left">2B</td><td align="left">SEEK (10)</td></tr><tr><td align="left">2C</td><td align="left">ERASE (10)</td></tr><tr><td align="left">2D</td><td align="left">READ UPDATED BLOCK</td></tr><tr><td align="left">2E</td><td align="left">WRITE AND VERIFY (10)</td></tr><tr><td align="left">2F</td><td align="left">VERIFY (10)</td></tr><tr><td align="left">30</td><td align="left">SEARCH DATA HIGH (10)</td></tr><tr><td align="left">31</td><td align="left">SEARCH DATA EQUAL (10)</td></tr><tr><td align="left">32</td><td align="left">SEARCH DATA LOW (10)</td></tr><tr><td align="left">33</td><td align="left">SET LIMITS (10)</td></tr><tr><td align="left">34</td><td align="left">PRE-FETCH (10)</td></tr><tr><td align="left">35</td><td align="left">SYNCHRONIZE CACHE (10)</td></tr><tr><td align="left">36</td><td align="left">LOCK/UNLOCK CACHE (10)</td></tr><tr><td align="left">37</td><td align="left">READ DEFECT DATA (10)</td></tr><tr><td align="left">37</td><td align="left">INITIALIZE ELEMENT STATUS WITH RANGE</td></tr><tr><td align="left">38</td><td align="left">MEDIUM SCAN</td></tr><tr><td align="left">39</td><td align="left">COMPARE</td></tr><tr><td align="left">3A</td><td align="left">COPY AND VERIFY</td></tr><tr><td align="left">3B</td><td align="left">WRITE BUFFER</td></tr><tr><td align="left">3C</td><td align="left">READ BUFFER</td></tr><tr><td align="left">3D</td><td align="left">UPDATE BLOCK</td></tr><tr><td align="left">3E</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Read_Commands#Read_Long">READ LONG</a></td></tr><tr><td align="left">3F</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Write_Commands#Write_Long">WRITE LONG</a></td></tr><tr><td align="left">40</td><td align="left">CHANGE DEFINITION</td></tr><tr><td align="left">41</td><td align="left">WRITE SAME (10)</td></tr><tr><td align="left">44</td><td align="left">REPORT DENSITY SUPPORT</td></tr><tr><td align="left">45</td><td align="left">PLAY AUDIO (10)</td></tr><tr><td align="left">46</td><td align="left">GET CONFIGURATION</td></tr><tr><td align="left">47</td><td align="left">PLAY AUDIO MSF</td></tr><tr><td align="left">48</td><td align="left">AUDIO TRACK INDEX (not mentioned in T10 overview)</td></tr><tr><td align="left">49</td><td align="left">AUDIO TRACK RELATIVE 10 (not mentioned in T10 overview)</td></tr><tr><td align="left">4A</td><td align="left">GET EVENT STATUS NOTIFICATION</td></tr><tr><td align="left">4B</td><td align="left">PAUSE / RESUME</td></tr><tr><td align="left">4C</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Log_Select_Command">LOG SELECT</a></td></tr><tr><td align="left">4D</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Log_Sense_Command">LOG SENSE</a></td></tr><tr><td align="left">50</td><td align="left">XDWRITE (10)</td></tr><tr><td align="left">51</td><td align="left">XPWRITE (10) /<em>READ DISC INFORMATION CDB (in mmc5r02c 6.22.2)</em>/</td></tr><tr><td align="left">52</td><td align="left">XDREAD (10)</td></tr><tr><td align="left">53</td><td align="left">XDWRITEREAD (10)</td></tr><tr><td align="left">54</td><td align="left">SEND OPC INFORMATION</td></tr><tr><td align="left">55</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Mode_Select_Command">MODE SELECT (10)</a></td></tr><tr><td align="left">56</td><td align="left">RESERVE (10)</td></tr><tr><td align="left">57</td><td align="left">RELEASE (10)</td></tr><tr><td align="left">58</td><td align="left">REPAIR TRACK</td></tr><tr><td align="left">5A</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Mode_Sense_Command">MODE SENSE (10)</a></td></tr><tr><td align="left">5B</td><td align="left">CLOSE TRACK / SESSION</td></tr><tr><td align="left">5C</td><td align="left">READ BUFFER CAPACITY</td></tr><tr><td align="left">5D</td><td align="left">SEND CUE SHEET</td></tr><tr><td align="left">5E</td><td align="left">PERSISTENT RESERVE IN</td></tr><tr><td align="left">5F</td><td align="left">PERSISTENT RESERVE OUT</td></tr><tr><td align="left">7E</td><td align="left">EXTENDED CDB</td></tr><tr><td align="left">7F</td><td align="left">VARIABLE LENGTH CDB</td></tr><tr><td align="left">80</td><td align="left">XDWRITE EXTENDED (16)</td></tr><tr><td align="left">80</td><td align="left">WRITE FILEMARKS (16)</td></tr><tr><td align="left">81</td><td align="left">REBUILD (16)</td></tr><tr><td align="left">81</td><td align="left">READ REVERSE (16)</td></tr><tr><td align="left">82</td><td align="left">REGENERATE (16)</td></tr><tr><td align="left">83</td><td align="left">EXTENDED COPY</td></tr><tr><td align="left">84</td><td align="left">RECEIVE COPY RESULTS</td></tr><tr><td align="left">85</td><td align="left">ATA COMMAND PASS THROUGH (16)</td></tr><tr><td align="left">86</td><td align="left">ACCESS CONTROL IN</td></tr><tr><td align="left">87</td><td align="left">ACCESS CONTROL OUT</td></tr><tr><td align="left">88</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Read_Commands#Read_.2816.29">READ (16)</a></td></tr><tr><td align="left">89</td><td align="left">COMPARE AND WRITE</td></tr><tr><td align="left">8A</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Write_Commands#Write_.2816.29">WRITE (16)</a></td></tr><tr><td align="left">8B</td><td align="left">ORWRITE</td></tr><tr><td align="left">8C</td><td align="left">READ ATTRIBUTE</td></tr><tr><td align="left">8D</td><td align="left">WRITE ATTRIBUTE</td></tr><tr><td align="left">8E</td><td align="left">WRITE AND VERIFY (16)</td></tr><tr><td align="left">8F</td><td align="left">VERIFY (16)</td></tr><tr><td align="left">90</td><td align="left">PRE-FETCH (16)</td></tr><tr><td align="left">91</td><td align="left">SYNCHRONIZE CACHE (16)</td></tr><tr><td align="left">91</td><td align="left">SPACE (16)</td></tr><tr><td align="left">92</td><td align="left">LOCK UNLOCK CACHE (16)</td></tr><tr><td align="left">93</td><td align="left">WRITE SAME (16)</td></tr><tr><td align="left">9E</td><td align="left">SERVICE ACTION IN (16)</td></tr><tr><td align="left">9F</td><td align="left">SERVICE ACTION OUT (16)</td></tr><tr><td align="left">A0</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Report_LUNs_Command">REPORT LUNS</a></td></tr><tr><td align="left">A1</td><td align="left">ATA COMMAND PASS THROUGH (12)</td></tr><tr><td align="left">A2</td><td align="left">SECURITY PROTOCOL IN</td></tr><tr><td align="left">A2</td><td align="left">SEND EVENT (not mentioned in T10 overview)</td></tr><tr><td align="left">A3</td><td align="left">MAINTENANCE IN</td></tr><tr><td align="left">A4</td><td align="left">MAINTENANCE OUT (REPORT_KEY)</td></tr><tr><td align="left">A5</td><td align="left">MOVE MEDIUM</td></tr><tr><td align="left">A5</td><td align="left">PLAY AUDIO 12 (not mentioned in T10 overview)</td></tr><tr><td align="left">A6</td><td align="left">EXCHANGE MEDIUM</td></tr><tr><td align="left">A7</td><td align="left">MOVE MEDIUM ATTACHED</td></tr><tr><td align="left">A8</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Read_Commands#Read_.2812.29">READ (12)</a></td></tr><tr><td align="left">A9</td><td align="left">SERVICE ACTION OUT (12)</td></tr><tr><td align="left">A9</td><td align="left">AUDIO TRACK RELATIVE 12 (not mentioned in T10 overview)</td></tr><tr><td align="left">AA</td><td align="left"><a href="http://en.wikipedia.org/wiki/SCSI_Write_Commands#Write_.2812.29">WRITE (12)</a></td></tr><tr><td align="left">AB</td><td align="left">SERVICE ACTION IN (12)</td></tr><tr><td align="left">AC</td><td align="left">ERASE (12)</td></tr><tr><td align="left">AD</td><td align="left">READ DVD STRUCTURE</td></tr><tr><td align="left">AE</td><td align="left">WRITE AND VERIFY (12)</td></tr><tr><td align="left">AF</td><td align="left">VERIFY (12)</td></tr><tr><td align="left">B0</td><td align="left">SEARCH DATA HIGH (12)</td></tr><tr><td align="left">B1</td><td align="left">SEARCH DATA EQUAL (12)</td></tr><tr><td align="left">B2</td><td align="left">SEARCH DATA LOW (12)</td></tr><tr><td align="left">B3</td><td align="left">SET LIMITS (12)</td></tr><tr><td align="left">B4</td><td align="left">READ ELEMENT STATUS ATTACHED</td></tr><tr><td align="left">B5</td><td align="left">SECURITY PROTOCOL OUT</td></tr><tr><td align="left">B6</td><td align="left">SEND VOLUME TAG</td></tr><tr><td align="left">B7</td><td align="left">READ DEFECT DATA (12)</td></tr><tr><td align="left">B8</td><td align="left">READ ELEMENT STATUS</td></tr><tr><td align="left">B9</td><td align="left">READ CD MSF</td></tr><tr><td align="left">BA</td><td align="left">REDUNDANCY GROUP (IN)</td></tr><tr><td align="left">BB</td><td align="left">REDUNDANCY GROUP (OUT)</td></tr><tr><td align="left">BC</td><td align="left">SPARE (IN)</td></tr><tr><td align="left">BC</td><td align="left">PLAY CD (not mentioned in T10 overview)</td></tr><tr><td align="left">BD</td><td align="left">SPARE (OUT)</td></tr><tr><td align="left">BE</td><td align="left">VOLUME SET (IN)</td></tr><tr><td align="left">BF</td><td align="left">VOLUME SET (OUT)</td></tr></tbody></table><p>上述部分内容来自 <a href="http://en.wikipedia.org/wiki/SCSI_Read_Commands">wiki</a> 、<a href="https://blog.csdn.net/ymangu666/article/details/39580257">ymangu</a> 和 SCSI Commands Reference Manual。更多SCSI 相关推荐查看 SCSI Commands Reference Manual、<a href="https://www.t10.org/">t10.org</a>。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>USB</tag>
      
      <tag>SCSI</tag>
      
      <tag>Mass Storage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于“GND”</title>
    <link href="/xxx/2020/02/%E5%85%B3%E4%BA%8E%E2%80%9CGND%E2%80%9D/"/>
    <url>/xxx/2020/02/%E5%85%B3%E4%BA%8E%E2%80%9CGND%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5dc9ab497be9fe2d78a20327fa6f2df952c5d63fd3ffb24b122f4cd0f27e6d80">16c4a5cd16abe2138be58f52f480a7857ff47d5e7bdd50a1ede71c7e1f4f00fed9f4c7a61b35c92bac1484cb5f7082c0ff1766beb40fb3cdce1210c395134aab2df31b70ff9363c41c37207695cf3c3d3eb319c8654ee0077d4975076b7568c8b99afab776e0905a2fc8193ba649291820247e185b49508fb6f632d93a26ae2210008042e9123453a3a6408030f7cc990167c30f67531bd149f5f886e863f5e9b0f026ac004235e3657c6fc5edfa7456172bb7c4955c2193b7de0d324f1292d21615ec9a9da6df8928620c91ebd2656df1ae9ecbed878b7276535ca0d46233ae39f67082bb86d749c35f182d1a75787dcc97308fd2e487fac494ccdfc09b1c37ec84bbdda74d39fa6fdb45ac3babe00e6529d737537b7434f4a0dbd64ae81f6d6f73c255662cf7e82b1759942c920849d24445b9966a29a8396bf34e89a012a5587f7627a63713ec19317ffd5799c87d7b0b283d647962fa985d3b148bf0ae991e192d078c97a378e86dcf5306d00ca2672df8b8973d36784a2911104f9c5461b32d2d2180d1d456c6d7283632ec00a869c6dbcd050edc8b2e841ee0b75e6703ebbfef369a765e496737e885bfaee9a361f7f8c049757ba593d8d00be4f9ff34e7fcce6b254e74167d3bf6bcfb8e357761b19cdca4f747db592dfd98937d7981dcb5fa135feed1d68f0f3f26cb4bcd4832cf40f4c2cb7cdc5cad6a310fab5811dc4f7ad6857bfaf9286d1b78b2c07af1f43eee033ce698c2436a51847da95afd342729c9d0c761fd9292f25821e1e081ecf1c3adbf18b17efebcc7434ee19bbe058a1dd84a39988de4871c1d8624cfba0d8bafebecb57ac15323c97e95a89a56b46e3d9c55bf544f39acb9d6503e790089b9fa920197c1b9eaeb68b6940bc3df857809c2314835c2f26c46e6f1abae1a04d39ffd0de9fca4b3953e4c146fb9352f1f579d700f12e359f507461824ded618695d2289c6dc165c11a140e370010c30dd9a4d338382053a102e42195c74a4aa03fff65803b351194ef6a9dad855182c7ee7de2495c70755d5851d3bd67ac84535adb476471b8dddac9837c080e1e87f8cf86d1a972850549a9e9af1701f54a4457ed364e9816f7883b5bc234fc4e84beeeef38f1d8efdbfb13430c0903d5df7a9f7e4eccd7de85269d39f63e54562ec198c504f9777436c228a4d09e15e0737f6669b66f5bd7bc4ceac29314e9497548c071411104a181761e18ca5c739e0e75bbf15e0a1eef04c3c0b4bee166755ebf06167882cb78ecf2ac94653e1d8bf725ff1d7d6be53dedbcf6aaf6aaf71947fb4c607699ee82e8547ddcfa8f258e1eec1e04baf0d916c31a73dc2c3c58b2a56ad151e1a310638d1a36acdc314e1da3d604cebb1682e009decbd4878c0b09009019c5c9437bbc7e6271746f5798c3fefd937ad4c19adb7a503e14ae7b3ae59f853114742d653c30f13cbe9068b3dc408259b18e53accdfe0afbd08fbd92ae96aac3b288374a5a6daee831831240c1fa2a96e5b0d8812db4e5c66ebbeedf880ac7dd38354e7f1ec8a9f42f88dfc0b314744c9f0ceab4466857fbe8afa710bf6e183f8b822163f8ca6f79ad626564141f4a76dba36f29bb606e730d949e43f513b581683a09f734fa1fdd637f2c0889e6f626509c87c592b99f716fae4dbe836452c4f896962028953393e441028dd763c609ba9320c946581cf0a58592f78412ddefffa22531ec859cd9431bfafe092f85ea8f0c0102532a7c4895d76a87940128d6134d6723ee48df1bb3b109f9b0108ddc1af3e4c8d29f2e8a076dad53d00867bdaa9fa9d2d9dfe50e66a03d81469a35fab3004ae9364a13e4c3b80b228d57ca4f9c8aaf4041cbf17f1347799ea0365e48601d640b365562a50f73828a9b61fcae64ca27abc2e57c0aaef4fdcbacbd4e4f7119205fa3bdc73dd06e2fa6c8da1ef47275f5a79fa0a7deda2d44857b5a15393aaf9c01cf65e139b390c2c28deb00c493a1ff1ca8ab71fe2c8dde83455bd441fed76fa8b537b4d83dcb8eacede67f0d99ee8a4c7c33899b42d10d87f7177733382e98b63c8307e211509c2554f9f4a2c2d9f6b9e9ec1082e6b3cfd540909a4a816b2cbb3288924f4b7f96971e2e6159ed979fd95534ca87c64776681bf6c5147b02d398587fd70de833c9fae7c6ef522be231472d10876ecd324296f97b3f6e2a0fbbad7002a42206770c5ab5760d89b4fb3aa5993753b9d7c952e74e072e55c470dde70de4b310884857a9ef8ea17c8b112d722e7629090ac09a26791253c5553842521fcaad33b8d9968a13d70ecd0f56ac095a14ca87c1dbf047d13f37f6ed8cbab7238298aa800639f4b1c9f7e232e89d7b9ad62751edb01856fcaa5ed3e1a530c060385360235b70869a6be80052af0c72856011fe59f1b962a23b7abcab085912361517f3a3c21e2769c87b64865bed2690f0bf6d78d60ac2ecb07ff6819b6fde43a4efb022d3837a49488e2364489a3471bd468213095abb1e0ad79372a745df611ff6738ab627aee2ef662a9ebe49f9def0ad2c18a80dbf298430bdc3f3a08ba96891014b7967583071a4fa49f745e0c2cd667fad2b24c1a894213d6ccb693561c6980f0a28b23bc864f1bd1e4bedfd5608090a875ede7225a90722473b09dbc784de155a70183eab2f2d3b19995e044964babc383f02661a2b9ea91b084751fccebd09f79dc7469c45ff425a4cff9ec7c08b1d147758674654e2e9b9d651a6f3f2f63de3299909cd11561a5c9abc8b78354755466a5000ef6c33a2591311cff9d64d9bb302ead0afba755f3595b831cafcd560ef771119dfac65f9596d5cb236913c086bbd9f082536df5229c5af67fb8b8290d770f5003567a36644f245e246d9a9e1c3cf9c5642a016c4ff5fcb5711a9a8b097f1285b468c2952f7e10bb985f2dfcc4e6c77675855c3213a44e90035f344ab87bc78c072f497f8c30a93f6eb97aa02a1eecf775571956c96a4c95b4cd766dc914c4602b295e562ec6ae3ad837d1048b740196f8ee03f8fe38c26bd6692653a3c7ea510f3be52d47b76039e4e8f739eabb8f01692b67314e44a1b861869b31764d7c5ed034f0d4db8b5d0098688a7753a728f0f04f950b4df19e57a6ce0f51fb670b3467845241ad40891f085ea4b1ea3243a0e09a4712e061fba661921a65d532952b2545f4ad8aaa8ef37190a6a04842b995cf0ef767245fae1b52d69f3bf893af8562b66fce1ae275164e6046223fad13d1d0ac02305e57ee9758c6fbb06f91f34b731669a5102fa8b075888c356bf526afe5f025453ecb7bfaf091e4f5af4940d116161d03277b4dd19c951f8601edd4e72051c36c1e2c2d6faa49026a41972a1573f6a10f70303db0a47ee4e6f58be03efa665ecfd262db7fb2c70d4a92e86386058a725c22e0bc457646013abd4569e39e884a77ff2cc1828a3c2b57ca2612b5cab3e48576906774f6492f32722cb2126e7a422b280a8b789e5672ea39af00394c0d0258248360d020be5647634646b60138443611854a9d88f4cadd8bd4dd939671b194092dda0d179c5eb961afa2b3f0befac4450ddea287abbb5fa24b5d9f3b3e35992576284fc6227a7265072ed87970224b69734c641a4be49590e2d239f542f2883afd01047b0a7d2abb8b416472b98f7f2fc1a8072139076573aed9c1979153b62886c1e55ea1c795a3bb639427f35ef37795bb635956d7c12db17fd83994f14449a0fc489951f2cef97fb4c43175cc110f7b0e057befc82dcbdd49c26d51389c6aa1fa3d9ac844c2140d6eefd807fe697289574f0704b6cfd028f7c3f5f7fa58e2ffeeffb8e8cd066df34a823f659bb888a7a6d9d8233a86fbcc105382ebcb323f0f4fc1eaa3be69f32d1c469f3c516521f9af212cd8352d15f9999018b89e48c14e09667491d628b083cffb42fbe25ea3b49b9faf66e2fa187c0392983b4df71aa4b029eed5087f5da81ef5033055f61573b63f1b29de316e0acd35384589a09d209b50282bf931bad822516c7db10faf243998105c857806feac70dfe17d8323c8a0f6cc54fe57efd5f286c18167b2f4cd22a87f8d7b9607d776d96d7d03bc9004b24ec852d7f7f92fdbda8c99c0d7dc76c931bed35ce79545ffe9fea38408f2e6cbdeb59b8be3cf5ba3992a9b2367096ae265e8ee5cd32c5d9c7ffb3384a412bd8c6ea4b8e3bce53f519a0316287212215e76869c88b586f809b3df00a6e548c9a6348c4590876af34d0f13dd8ff14bcb90166f3eacb06eef965afa38ba4bbebc5cc017bea0d0ebba652dcd6f38fbc0b0e3e9c18867ecea44b5fd50bac6c147be94e492570f8f4e1958060e97eec67ce7510adef0fc946663bb94fed5d0e848facff8a7e3d792174a370672820a9113e473d626e43c19392b25a78a00e0728a49c9a5b35366967d283cdd8d8b12f28860a142b918609140e8ed2ff550a2360190dfd175c1cbddfa6312ae291380b13e1259661facd94734d81dbe63e0a1ebdfe36bb0259e315c0437fabbd8bd93240e25b440f03da65d474499a77d621f475bcd02cc200e032b9b963d448c75545861c120564b3e5757dac4067223810aa35476faf1d1fab3c831eee2a3c2e5206892701796a48418d8f4900a3185341c65e8062980168b2e1e64e2e37831e4fbdc632106899bee802bb9f4bd630a3c95dbe7d8dcd0913194bd14c39ce0c2631f0e4bcf4e0d0a3dbb6014c7e1a1940a367a5b59ab1adc2220dfa8675dc93d8ee3a7ac20ca652c43fd2f84a22a5903c25c7e9115f6481921c0b338445a462aa542082bc0cd547e0d1292a4c15a78f6f2b26c16aa6b52add13f83faeda911d3b22c06adac5b837bbbba041096f2ac50e06fdd23fd66f90e7555f0939572d04338b9611c7e04da4f515b6ae2dfe5c72bec0e1d1d3858aed4a4285a0199d074791d888ac5bd2e540e3674332a5b003ebe9618b5d648d22257f650d378deea5b6f8c27e985fb40e4a38e1af260119cd253e40d8be4357eb29e9073cd2be5a96a8c72ee905cd2869967a8ec6d65a3f19d790e00eec38b78955b6930def050012cf5745695f87177d6805d2d01a12a9c04b5e67ba3d5abb3261cf615a24044eed68679e0c18a20a74b3f7c80615fd75cce73c7586960ae9f28d944ec3b7414cb7fbdb8c54c573e8a39e11febc6bac77f5bc41bc3c65c127b30b3a31ef18d68f8c2b3f7bf07e0331cead5cbf9d4252019d0f71e68529ce85ad1392b89099ceb33bc053e87c855d037cdd00a5a8b3d07b5322ebb1e7384a1899318e3321f40d40be5447c10a67c69ee44de2b585ddfe0e324edc5e16965a1b1ba142a9af2376608ff310c9a43d499acfe510feb016e8f130eb76cecde18009fe8fe69af8355d5dd77dd0111302475043bae6c679c093f5e124a30ff22c98bad3204deb54ea8ba2c5de810289a8bca0183845dd77aa2669cf92e8d345348fe8830e9792aefd9e01bc30afba2df2ea8638dedfa1218812c21fa2d2fc9cfee9b643012609959f5d711da175caf6cf863768ff4b8d1189e2de26fddab79466dff5bb6db739db4d3eed5c7a1fe7b0050b5925f27690a2b39d3569e23af1036f10bf21d1dc8389d0af12c157d48af6aabb36056136ab01c69723e555c532e24275baadea39f33a831c45f9e6156947f29b75f78c40fecee75e4b17599b2cc584f5e0fccef79266b17b0cdbd5b9465fb123de879205fc63a8cdd6ec75b311f9c2ec019431458318041de5e582309a8834dc025cbfc66339dd7a4356b4c2d995e70f6af21377185128d374aa36dee7936aa12aa3ea25559d3074a2320bb760a7d90cb76b2fd4f2d1f4158343b31c9b0637fb3e8d7f37dc8e24f86a1955806b128757237e596fec2ae4a08e3b142cbf75c6b6ad15bbdc6adb4f195e27c064374330c238bca3a78524edf462a71343e22a61cc8c3020879b3952cefe53f88d1817f2e7574e79223367c4207a14016b5d92f12502d80790867a2e39a5dfca59061a4d1f43dcd8bf7f6323c986d0068f1ea66154dc3a313c4cb6a91c35202cb940c8552a5e6bdfae12af0d9bb0dc58dff</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GND</tag>
      
      <tag>硬件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USB3.0 开机上电识别场景总结</title>
    <link href="/xxx/2020/01/USB3-0-%E5%BC%80%E6%9C%BA%E4%B8%8A%E7%94%B5%E8%AF%86%E5%88%AB%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/"/>
    <url>/xxx/2020/01/USB3-0-%E5%BC%80%E6%9C%BA%E4%B8%8A%E7%94%B5%E8%AF%86%E5%88%AB%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4 id="USB3-0-开机上电识别场景总结"><a href="#USB3-0-开机上电识别场景总结" class="headerlink" title="USB3.0 开机上电识别场景总结"></a>USB3.0 开机上电识别场景总结</h4><p>针对 U盘进行重点分析，可推导其他 USB3.0 设备的识别。</p><p>需要 4通道高采样率示波器、USB3.0 U盘若干、USB3.0 预供电治具、USB3.0 DP/DM 与 RX/TX 分离治具。</p><p>开机上电识别场景，主要针对无 GPIO (power on) 控制 vbus 的环境。大体意思就是 U盘已经在整机上电那一刻也会得电运行。</p><h4 id="思路与总结"><a href="#思路与总结" class="headerlink" title="思路与总结"></a>思路与总结</h4><p>1、通过给 U盘预供电，模拟无 GPIO 控制 vbus 的上电识别情况。</p><p>2、抓取 DP、 DM、 VBUS、 TX、 RX 波形。</p><p>3、如果预上电，热拔插识别过程的波形出现 high-speed 握手波形，则在开机上电识别场景， DP/DM、 TX/RX 分开的 USB3.0 口上，该 U盘是不识别的。</p><p>4、因为 U盘是黑盒设备，推测 U盘存在 SuperSpeed 握手窗口时间，预上电时间过长会导致错过该窗口， U盘后续只会一直等待 high-speed 握手。</p><p>5、在非标准 USB3.0 口（缺失 DP/ DM），因为没有 USB2.0 的相关引脚导致无法 high-speed 握手。</p><p>6、在标准 USB3.0 口上，有 DP/DM 可以进行 high-speed 握手，因 host 仍然支持 SuperSpeed 握手，所以后续  U盘先 high-speed 握手再响应 SuperSpeed 握手，再由 U盘自行仲裁使用哪种速度进行后续通信。</p><p>7、预上电识别可以理解为 device SuperSpeed 握手失败，进入降速识别流程。 device 会将自身的 Rx Termination 移除，避免继续与 host USB3.0 部分产生交互，从而以 high-speed device 的身份继续与 host 识别。</p><p>8、 USB3.0 的握手，是否降速识别完全是靠 device 实现的， host 要做的是确保可以同时兼容 SuperSpeed 和 high-speed 的 device。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>USB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx 部署多个web应用</title>
    <link href="/xxx/2020/01/Nginx-%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AAweb%E5%BA%94%E7%94%A8/"/>
    <url>/xxx/2020/01/Nginx-%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AAweb%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>以往服务器就部署了一个个人博客，平时也没几个人看，图床也是放在七牛，资源利用十分的低。最近某人希望可以帮忙跑个 Python 脚本，通过给微信公众号发消息，触发脚本收集、整理信息并将信息发到指定的邮箱去。对接微信公众号这个不难，以前弄过，但要占用 80 端口，会和现有的博客冲突，只能端口转发了。</p><p>经过多轮百度、多篇博客以及不断的尝试，总算搞定了，下面是大概内容，作为记录。</p><p>1、服务器与微信公众号的对接具体可以查看微信官方的 demo，但要注意 demo 是用 Python 2 写的，别掉进 Python 2 与 3 之间差异的坑里面去了。</p><p>2、修改 nginx 配置文件，在 server 项中增加一个 location 配置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">location ^~ /wechat &#123;<br>        proxy_pass http://www.xxxdk.xyz:8080/wx;<br>&#125;<br></code></pre></td></tr></table></figure><p>^~ 表示 uri 以某个常规字符串开头，理解为匹配 url 路径即可。该 location 配置匹配 xxxdk.xyz/wechat 后代理转发到 xxxdk.xyz:8080/wx，wx 是 demo 中 main.py 指定的，8080 端口是在脚本运行时候指定的。</p><p>3、调试</p><p>检查 nginx 的配置文件有没问题，nginx -t 。</p><p>重启 nginx，nginx -s reload 。</p><p>可以用 curl 查看 header 信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl --<span class="hljs-built_in">head</span> xxxdk.xyz/wx <br></code></pre></td></tr></table></figure><p>与微信公众号对接时，可以在脚本里面加多点打印看看过程。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SCSI 错误信息表整理</title>
    <link href="/xxx/2020/01/SCSI-%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E8%A1%A8%E6%95%B4%E7%90%86/"/>
    <url>/xxx/2020/01/SCSI-%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E8%A1%A8%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>USB 管道的第一大使用场景非 U盘、移动硬盘莫属了！U盘、移动硬盘即 Mass Storage，使用USB 管道的 Bluk 传输承载 SCSI 协议进行资源交互。</p><p>SCSI 协议是让数据以块的方式进行传输的一种协议规范。</p><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>Mass Storage 插入单板时总会有 “sd xxxx: [sdx] Result: xxxxxxx” 的log，这打印是 USB 枚举成功后，SCSI 识别设备的过程log。U盘即是USB 设备，也是 SCSI 设备。</p><p>下面是 SCSI 识别过程出错的 log，我们从中可以看到三个关键词：hostbyte、driverbyte 和 Sense Key。通过这查询这三个值，结合后续的文件系统 log，我们就可以大概了解出错的原因。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">sd <span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>: [sda] Result: hostbyte=<span class="hljs-number">0x00</span> driverbyte=<span class="hljs-number">0x08</span><br>sd <span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>: [sda] Sense Key : <span class="hljs-number">0xb</span><br></code></pre></td></tr></table></figure><h5 id="hostbyte-含义"><a href="#hostbyte-含义" class="headerlink" title="hostbyte 含义"></a>hostbyte 含义</h5><table><thead><tr><th><strong>hostbyte</strong></th><th><strong>符号（Symbol）</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>0x00</td><td>DID_OK</td><td>没有错误</td></tr><tr><td>0x01</td><td>DID_NO_CONNECT</td><td>在超时之前，不能连接</td></tr><tr><td>0x02</td><td>DID_BUS_BUSY</td><td>在超时期间，BUS一直处于忙状态</td></tr><tr><td>0x03</td><td>DID_TIME_OUT</td><td>因为其他原因超时</td></tr><tr><td>0x04</td><td>DID_BAD_TARGET</td><td>BAD target</td></tr><tr><td>0x05</td><td>DID_ABORT</td><td>因为其他原因取消</td></tr><tr><td>0x06</td><td>DID_PARITY</td><td>Parity错误</td></tr><tr><td>0x07</td><td>DID_ERROR</td><td>内部错误（internal error）</td></tr><tr><td>0x08</td><td>DID_RESET</td><td>被复位</td></tr><tr><td>0x09</td><td>DID_BAD_INTR</td><td>得到一个未被期望的中断</td></tr></tbody></table><h5 id="driverbyte-含义"><a href="#driverbyte-含义" class="headerlink" title="driverbyte 含义"></a>driverbyte 含义</h5><table><thead><tr><th><strong>driverbyte</strong></th><th><strong>符号（Symbol）</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>0x00</td><td>DRIVER_OK</td><td>没有错误</td></tr><tr><td>0x01</td><td>DRIVER_BUSY</td><td>未使用</td></tr><tr><td>0x02</td><td>DRIVER_SOFT</td><td>未使用</td></tr><tr><td>0x03</td><td>DRIVER_MEDIA</td><td>未使用</td></tr><tr><td>0x04</td><td>DRIVER_ERROR</td><td>内部驱动错误</td></tr><tr><td>0x05</td><td>DRIVER_INVALID</td><td>完成（DID_BAD_TARGET或DID_ABORT）</td></tr><tr><td>0x06</td><td>DRIVER_TIMEOUT</td><td>超时完成</td></tr><tr><td>0x07</td><td>DRIVER_HARD</td><td>完成，但有致命错误</td></tr><tr><td>0x08</td><td>DRIVER_SENSE</td><td>有sense信息</td></tr><tr><td>0x10</td><td>SUGGEST_RETRY</td><td>重试SCSI请求</td></tr><tr><td>0x20</td><td>SUGGEST_ABORT</td><td>取消请求</td></tr><tr><td>0x30</td><td>SUGGEST_REMAP</td><td>重新映射block，但没有完成</td></tr><tr><td>0x40</td><td>SUGGEST_DIE</td><td>让内核Panic</td></tr><tr><td>0x80</td><td>SUGGEST_SENSE</td><td>从设备上获取Sense信息</td></tr><tr><td>0xff</td><td>SUGGEST_IS_OK</td><td>不需要做任何操作</td></tr></tbody></table><h5 id="Sense-Key-含义"><a href="#Sense-Key-含义" class="headerlink" title="Sense Key 含义"></a>Sense Key 含义</h5><table><thead><tr><th><strong>Sense Key 代码</strong></th><th><strong>Sense Key符号 （Symbol）</strong></th><th><strong>具体含义描述</strong></th></tr></thead><tbody><tr><td>0x00</td><td>NO_SENSE</td><td>在特定逻辑单元上，没有特殊的Sense Key信息。发生这种情况情形包括： （1）成功完成一个命令；（2）命令收到CHECK CONDITION或COMMAND TERMINATED状态，原因为filemark,EOM或ILI某个比特位设置为1。</td></tr><tr><td>0x01</td><td>RECOVERED_ERROR</td><td>表示最后一个命令成功执行，但在该Target上有恢复动作。 详细原因由Additional Sense Key和信息区域来确定。当一条命令中出现多个纠正的错误时，报告哪一个错误被纠正是和设备相关。</td></tr><tr><td>0x02</td><td>NOT_READY</td><td>表示访问的逻辑地址单元不可访问，此时需要人为干预来纠正这种错误。</td></tr><tr><td>0x03</td><td>MEDIUM_ERROR</td><td>表示命令因为不可恢复的错误条件而终止，原因可能为存储介质的缺陷或 记录的数据存在错误。当Target区别不了存储介质的缺陷和特定硬件失效（Sense Key 4h）时，也会报告”MEDIUM ERROR”错误。</td></tr><tr><td>0x04</td><td>HARDWARE_ERROR</td><td>表示执行一条命令或在自检期间，Target发现了一个不可纠正的硬件错误，如控制器失效、设备失效、校验错误。</td></tr><tr><td>0x05</td><td>ILLEGAL_REQUEST</td><td>表示在SCSI命令描述块中有非法参数，或在数据/某些命令中（如FORMAT UNIT、SEARCH DATA等） 非法参数。当Target检测到命令块中有非法参数时，应该终止该命令而不能改变介质。当Target检测到额外参数数据中的无效参数时，Taget可能已经更改了介质。该Sense Key也可以表示收到无效的IDENTIFY消息。</td></tr><tr><td>0x06</td><td>UNIT_ATTENTION</td><td>表示可移除的介质可能已经被更改或Target被复位。</td></tr><tr><td>0x07</td><td>DATA_PROTECT</td><td>表示命令试图读/写被设置为读/写保护的block。读写操作不会被执行。</td></tr><tr><td>0x08</td><td>BLANK_CHECK</td><td>表示一次性写/顺序访问的设备遇到空介质或</td></tr><tr><td>0x0a</td><td>COPY_ABORTED</td><td>表示COPY、COMPARE或COPY AND VERIFY命令取消，原因是源设备或目标设备或两者有一个错误条件。</td></tr><tr><td>0x0b</td><td>ABORTED_COMMAND</td><td>表示Target取消了命令，SCSI initiator可以重试这个命令来修复。</td></tr><tr><td>0x0d</td><td>VOLUME_OVERFLOW</td><td>带缓冲的设备中，访问量分区的末尾，但数据仍在Buffer中，没有写入介质。 RECOVER BUFFERED DATA命令来从缓冲区中读取数据。</td></tr><tr><td>0x0e</td><td>MISCOMPARE</td><td>表示源数据和从介质中读取的数据不一致。</td></tr></tbody></table><p><a href="http://ilinuxkernel.com/?p=760">hostbyte、driverbyte</a> 和 <a href="http://ilinuxkernel.com/?p=764">Sense Key</a> 含义摘自 <a href="http://ilinuxkernel.com/">http://ilinuxkernel.com/</a> 。 </p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Error</tag>
      
      <tag>SCSI</tag>
      
      <tag>Mass Storage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xhci trace 开机启动设置</title>
    <link href="/xxx/2020/01/xhci-trace-%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%AE%BE%E7%BD%AE/"/>
    <url>/xxx/2020/01/xhci-trace-%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近遇到一个客户问题，工厂抽检每次都出现，不解决就要停产了，但在客户研发环境无法复现，在工厂环境才能一天复现一次。这是一个老大难问题了，涉及到一些逻辑上的风险，需要联合解决。逻辑需要了解 xhci 控制器的行为和相关的数据包，这就要抓取出问题时候的 trace 和 USB 协议包了。环境在工厂能抓的只有 trace 了，不过也是能进行初步分析的。</p><h4 id="关于-trace"><a href="#关于-trace" class="headerlink" title="关于 trace"></a>关于 trace</h4><p>trace 是 linux 调试方法之一，可以理解为一种高级打印机制，实现追踪 kernel 中函数事件的框架，源码位于 /kernel/trace/trace.c 。关于 xhci 的 trace 大部分已经在 linux 4.14 版本集成了，linux 4.9 等之前的版本则需要自行移植。</p><p>1、开启 trace，make menuconfig 进入配置选项</p><p>​        在 kernel hacking –&gt; trace 中</p><p>2、trace 依赖 debugfs，所以挂载 debugfs 到 /sys/kernel/debug/ 。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mount -t debugfs none /sys/kernel/debug<br></code></pre></td></tr></table></figure><p>3、设置缓存大小，trace 初始的缓存很小，抓 USB 根本不够用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> 20480 &gt; /sys/kernel/debug/tracing/buffer_size_kb<br></code></pre></td></tr></table></figure><p>4、使能 xhci event trace</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/xhci-hcd/enable<br></code></pre></td></tr></table></figure><p>5、使能 trace （总开关）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/tracing_on<br></code></pre></td></tr></table></figure><p>6、导出 trace</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /sys/kernel/debug/tracing/trace &gt; /data/trace.log<br></code></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>问题来了，工厂那边不能做过于复杂的操作，不能敲太多条指令才开启 trace，要求开机就自启动。</p><p>开机启动，第一时间是想到 init.rc，海思平台是 init.bigfish.rc 。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">write</span> <span class="hljs-regexp">/sys/</span>kernel<span class="hljs-regexp">/debug/</span>tracing/buffer_size_kb <span class="hljs-number">20480</span><br><span class="hljs-keyword">write</span> <span class="hljs-regexp">/sys/</span>kernel<span class="hljs-regexp">/debug/</span>tracing/trace <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">write</span> <span class="hljs-regexp">/sys/</span>kernel<span class="hljs-regexp">/debug/</span>tracing<span class="hljs-regexp">/events/</span>xhci-hcd/enable <span class="hljs-number">1</span><br><span class="hljs-keyword">write</span> <span class="hljs-regexp">/sys/</span>kernel<span class="hljs-regexp">/debug/</span>tracing/tracing_on <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>修改 –&gt; 编译 –&gt; 烧入 –&gt; 开机 –&gt; 插入U盘 –&gt; cat trace ，发现并没有内容。于是 cat 每个配置项，发现 /sys/kernel/debug/tracing/events/xhci-hcd/enable 值是 0 。查看 log，报错误，提示没权限。于是 chmod 644 /sys/kernel/debug/tracing/events/xhci-hcd/enable，错误消失了，但还是失败了。仔细一想 init 应该是 root 用户，怎么会没权限呢？难道是 enable 还没生成？还是别的进程把它又改成 0 了？</p><p>后续尝试用脚本的形式，在系统启动完后再执行，又遇到了 SELinux 权限的问题，咨询相关同事后也放弃了，同事表示， SELinux 加强权限之后就放弃开启跑脚本了，权限设置不过来，让我另谋出路。</p><p>经过多次挣扎，终于在 kernel 文档 <a href="https://www.kernel.org/doc/html/latest/trace/events.html#boot-option">Event Tracing</a> 2.3 Boot option 中看到了曙光！只要在 bootargs 中增加 trace_event 就可以开机启动了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">trace_event=xhci-hcd<br></code></pre></td></tr></table></figure><p>本文部分内容摘自 <a href="http://blog.csdn.net/jscese">【jscese】</a> 的博客！</p><p>封面来自 <a href="https://huaban.com/pins/283552019/">windtrace</a> 的花瓣</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>XHCI</tag>
      
      <tag>Linux</tag>
      
      <tag>trace</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 错误码与含义</title>
    <link href="/xxx/2019/12/Linux-%E9%94%99%E8%AF%AF%E7%A0%81%E4%B8%8E%E5%90%AB%E4%B9%89/"/>
    <url>/xxx/2019/12/Linux-%E9%94%99%E8%AF%AF%E7%A0%81%E4%B8%8E%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>Linux错误码表，帮助快速定位问题，用过的都说好！</p><table><thead><tr><th>C Name</th><th>Value</th><th>Description</th><th>含义</th></tr></thead><tbody><tr><td>Success</td><td>0</td><td>Success</td><td>成功</td></tr><tr><td>EPERM</td><td>1</td><td>Operation not permitted</td><td>操作不允许</td></tr><tr><td>ENOENT</td><td>2</td><td>No such file or directory</td><td>没有这样的文件或目录</td></tr><tr><td>ESRCH</td><td>3</td><td>No such process</td><td>没有这样的过程</td></tr><tr><td>EINTR</td><td>4</td><td>Interrupted system call</td><td>系统调用被中断</td></tr><tr><td>EIO</td><td>5</td><td>I/O error</td><td>I/O错误</td></tr><tr><td>ENXIO</td><td>6</td><td>No such device or address</td><td>没有这样的设备或地址</td></tr><tr><td>E2BIG</td><td>7</td><td>Arg list too long</td><td>参数列表太长</td></tr><tr><td>ENOEXEC</td><td>8</td><td>Exec format error</td><td>执行格式错误</td></tr><tr><td>EBADF</td><td>9</td><td>Bad file number</td><td>坏的文件描述符</td></tr><tr><td>ECHILD</td><td>10</td><td>No child processes</td><td>没有子进程</td></tr><tr><td>EAGAIN</td><td>11</td><td>Try again</td><td>资源暂时不可用</td></tr><tr><td>ENOMEM</td><td>12</td><td>Out of memory</td><td>内存溢出</td></tr><tr><td>EACCES</td><td>13</td><td>Permission denied</td><td>拒绝许可</td></tr><tr><td>EFAULT</td><td>14</td><td>Bad address</td><td>错误的地址</td></tr><tr><td>ENOTBLK</td><td>15</td><td>Block device required</td><td>块设备请求</td></tr><tr><td>EBUSY</td><td>16</td><td>Device or resource busy</td><td>设备或资源忙</td></tr><tr><td>EEXIST</td><td>17</td><td>File exists</td><td>文件存在</td></tr><tr><td>EXDEV</td><td>18</td><td>Cross-device link</td><td>无效的交叉链接</td></tr><tr><td>ENODEV</td><td>19</td><td>No such device</td><td>设备不存在</td></tr><tr><td>ENOTDIR</td><td>20</td><td>Not a directory</td><td>不是一个目录</td></tr><tr><td>EISDIR</td><td>21</td><td>Is a directory</td><td>是一个目录</td></tr><tr><td>EINVAL</td><td>22</td><td>Invalid argument</td><td>无效的参数</td></tr><tr><td>ENFILE*</td><td>23</td><td>File table overflow</td><td>打开太多的文件系统</td></tr><tr><td>EMFILE</td><td>24</td><td>Too many open files</td><td>打开的文件过多</td></tr><tr><td>ENOTTY</td><td>25</td><td>Not a tty device</td><td>不是tty设备</td></tr><tr><td>ETXTBSY</td><td>26</td><td>Text file busy</td><td>文本文件忙</td></tr><tr><td>EFBIG</td><td>27</td><td>File too large</td><td>文件太大</td></tr><tr><td>ENOSPC</td><td>28</td><td>No space left on device</td><td>设备上没有空间</td></tr><tr><td>ESPIPE</td><td>29</td><td>Illegal seek</td><td>非法移位</td></tr><tr><td>EROFS</td><td>30</td><td>Read-only file system</td><td>只读文件系统</td></tr><tr><td>EMLINK</td><td>31</td><td>Too many links</td><td>太多的链接</td></tr><tr><td>EPIPE</td><td>32</td><td>Broken pipe</td><td>管道破裂</td></tr><tr><td>EDOM</td><td>33</td><td>Math argument out of domain</td><td>数值结果超出范围</td></tr><tr><td>ERANGE</td><td>34</td><td>Math result not representable</td><td>数值结果不具代表性</td></tr><tr><td>EDEADLK</td><td>35</td><td>Resource deadlock would occur</td><td>资源死锁错误</td></tr><tr><td>ENAMETOOLONG</td><td>36</td><td>Filename too long</td><td>文件名太长</td></tr><tr><td>ENOLCK</td><td>37</td><td>No record locks available</td><td>没有可用锁</td></tr><tr><td>ENOSYS</td><td>38</td><td>Function not implemented</td><td>功能没有实现</td></tr><tr><td>ENOTEMPTY</td><td>39</td><td>Directory not empty</td><td>目录不空</td></tr><tr><td>ELOOP</td><td>40</td><td>Too many symbolic links encountered</td><td>符号链接层次太多</td></tr><tr><td>EWOULDBLOCK</td><td>41</td><td>Same as EAGAIN</td><td>和EAGAIN一样</td></tr><tr><td>ENOMSG</td><td>42</td><td>No message of desired type</td><td>没有期望类型的消息</td></tr><tr><td>EIDRM</td><td>43</td><td>Identifier removed</td><td>标识符删除</td></tr><tr><td>ECHRNG</td><td>44</td><td>Channel number out of range</td><td>频道数目超出范围</td></tr><tr><td>EL2NSYNC</td><td>45</td><td>Level 2 not synchronized</td><td>2级不同步</td></tr><tr><td>EL3HLT</td><td>46</td><td>Level 3 halted</td><td>3级中断</td></tr><tr><td>EL3RST</td><td>47</td><td>Level 3 reset</td><td>3级复位</td></tr><tr><td>ELNRNG</td><td>48</td><td>Link number out of range</td><td>链接数超出范围</td></tr><tr><td>EUNATCH</td><td>49</td><td>Protocol driver not attached</td><td>协议驱动程序没有连接</td></tr><tr><td>ENOCSI</td><td>50</td><td>No CSI structure available</td><td>没有可用CSI结构</td></tr><tr><td>EL2HLT</td><td>51</td><td>Level 2 halted</td><td>2级中断</td></tr><tr><td>EBADE</td><td>52</td><td>Invalid exchange</td><td>无效的交换</td></tr><tr><td>EBADR</td><td>53</td><td>Invalid request descriptor</td><td>请求描述符无效</td></tr><tr><td>EXFULL</td><td>54</td><td>Exchange full</td><td>交换全</td></tr><tr><td>ENOANO</td><td>55</td><td>No anode</td><td>没有阳极</td></tr><tr><td>EBADRQC</td><td>56</td><td>Invalid request code</td><td>无效的请求代码</td></tr><tr><td>EBADSLT</td><td>57</td><td>Invalid slot</td><td>无效的槽</td></tr><tr><td>EDEADLOCK</td><td>58</td><td>Same as EDEADLK</td><td>和EDEADLK一样</td></tr><tr><td>EBFONT</td><td>59</td><td>Bad font file format</td><td>错误的字体文件格式</td></tr><tr><td>ENOSTR</td><td>60</td><td>Device not a stream</td><td>设备不是字符流</td></tr><tr><td>ENODATA</td><td>61</td><td>No data available</td><td>无可用数据</td></tr><tr><td>ETIME</td><td>62</td><td>Timer expired</td><td>计时器过期</td></tr><tr><td>ENOSR</td><td>63</td><td>Out of streams resources</td><td>流资源溢出</td></tr><tr><td>ENONET</td><td>64</td><td>Machine is not on the network</td><td>机器不上网</td></tr><tr><td>ENOPKG</td><td>65</td><td>Package not installed</td><td>没有安装软件包</td></tr><tr><td>EREMOTE</td><td>66</td><td>Object is remote</td><td>对象是远程的</td></tr><tr><td>ENOLINK</td><td>67</td><td>Link has been severed</td><td>联系被切断</td></tr><tr><td>EADV</td><td>68</td><td>Advertise error</td><td>广告的错误</td></tr><tr><td>ESRMNT</td><td>69</td><td>Srmount error</td><td>srmount错误</td></tr><tr><td>ECOMM</td><td>70</td><td>Communication error on send</td><td>发送时的通讯错误</td></tr><tr><td>EPROTO</td><td>71</td><td>Protocol error</td><td>协议错误</td></tr><tr><td>EMULTIHOP</td><td>72</td><td>Multihop attempted</td><td>多跳尝试</td></tr><tr><td>EDOTDOT</td><td>73</td><td>RFS specific error</td><td>RFS特定的错误</td></tr><tr><td>EBADMSG</td><td>74</td><td>Not a data message</td><td>非数据消息</td></tr><tr><td>EOVERFLOW</td><td>75</td><td>Value too large for defined data type</td><td>值太大,对于定义数据类型</td></tr><tr><td>ENOTUNIQ</td><td>76</td><td>Name not unique on network</td><td>名不是唯一的网络</td></tr><tr><td>EBADFD</td><td>77</td><td>File descriptor in bad state</td><td>文件描述符在坏状态</td></tr><tr><td>EREMCHG</td><td>78</td><td>Remote address changed</td><td>远程地址改变了</td></tr><tr><td>ELIBACC</td><td>79</td><td>Cannot access a needed shared library</td><td>无法访问必要的共享库</td></tr><tr><td>ELIBBAD</td><td>80</td><td>Accessing a corrupted shared library</td><td>访问损坏的共享库</td></tr><tr><td>ELIBSCN</td><td>81</td><td>A .lib section in an .out is corrupted</td><td>.lib在. out中已经是损坏的</td></tr><tr><td>ELIBMAX</td><td>82</td><td>Linking in too many shared libraries</td><td>试图链接太多的共享库</td></tr><tr><td>ELIBEXEC</td><td>83</td><td>Cannot exec a shared library directly</td><td>不能直接执行一个共享库</td></tr><tr><td>EILSEQ</td><td>84</td><td>Illegal byte sequence</td><td>无效的或不完整的多字节或宽字符</td></tr><tr><td>ERESTART</td><td>85</td><td>Interrupted system call should be restarted</td><td>应该重新启动中断的系统调用</td></tr><tr><td>ESTRPIPE</td><td>86</td><td>Streams pipe error</td><td>流管错误</td></tr><tr><td>EUSERS</td><td>87</td><td>Too many users</td><td>用户太多</td></tr><tr><td>ENOTSOCK</td><td>88</td><td>Socket operation on non-socket</td><td>套接字操作在非套接字上</td></tr><tr><td>EDESTADDRREQ</td><td>89</td><td>Destination address required</td><td>需要目标地址</td></tr><tr><td>EMSGSIZE</td><td>90</td><td>Message too long</td><td>消息太长</td></tr><tr><td>EPROTOTYPE</td><td>91</td><td>Protocol wrong type for socket</td><td>socket协议类型错误</td></tr><tr><td>ENOPROTOOPT</td><td>92</td><td>Protocol not available</td><td>协议不可用</td></tr><tr><td>EPROTONOSUPPORT</td><td>93</td><td>Protocol not supported</td><td>不支持的协议</td></tr><tr><td>ESOCKTNOSUPPORT</td><td>94</td><td>Socket type not supported</td><td>套接字类型不受支持</td></tr><tr><td>EOPNOTSUPP</td><td>95</td><td>Operation not supported on transport</td><td>不支持的操作</td></tr><tr><td>EPFNOSUPPORT</td><td>96</td><td>Protocol family not supported</td><td>不支持的协议族</td></tr><tr><td>EAFNOSUPPORT</td><td>97</td><td>Address family not supported by protocol</td><td>协议不支持的地址</td></tr><tr><td>EADDRINUSE</td><td>98</td><td>Address already in use</td><td>地址已在使用</td></tr><tr><td>EADDRNOTAVAIL</td><td>99</td><td>Cannot assign requested address</td><td>无法分配请求的地址</td></tr><tr><td>ENETDOWN</td><td>100</td><td>Network is down</td><td>网络瘫痪</td></tr><tr><td>ENETUNREACH</td><td>101</td><td>Network is unreachable</td><td>网络不可达</td></tr><tr><td>ENETRESET</td><td>102</td><td>Network dropped</td><td>网络连接丢失</td></tr><tr><td>ECONNABORTED</td><td>103</td><td>Software caused connection</td><td>软件导致连接中断</td></tr><tr><td>ECONNRESET</td><td>104</td><td>Connection reset by</td><td>连接被重置</td></tr><tr><td>ENOBUFS</td><td>105</td><td>No buffer space available</td><td>没有可用的缓冲空间</td></tr><tr><td>EISCONN</td><td>106</td><td>Transport endpoint</td><td>传输端点已经连接</td></tr><tr><td>ENOTCONN</td><td>107</td><td>Transport endpoint</td><td>传输终点没有连接</td></tr><tr><td>ESHUTDOWN</td><td>108</td><td>Cannot send after transport</td><td>传输后无法发送</td></tr><tr><td>ETOOMANYREFS</td><td>109</td><td>Too many references</td><td>太多的参考</td></tr><tr><td>ETIMEDOUT</td><td>110</td><td>Connection timed</td><td>连接超时</td></tr><tr><td>ECONNREFUSED</td><td>111</td><td>Connection refused</td><td>拒绝连接</td></tr><tr><td>EHOSTDOWN</td><td>112</td><td>Host is down</td><td>主机已关闭</td></tr><tr><td>EHOSTUNREACH</td><td>113</td><td>No route to host</td><td>没有主机的路由</td></tr><tr><td>EALREADY</td><td>114</td><td>Operation already</td><td>已运行</td></tr><tr><td>EINPROGRESS</td><td>115</td><td>Operation now in</td><td>正在运行</td></tr><tr><td>ESTALE</td><td>116</td><td>Stale NFS file handle</td><td>陈旧的NFS文件句柄</td></tr><tr><td>EUCLEAN</td><td>117</td><td>Structure needs cleaning</td><td>结构体需要清除</td></tr><tr><td>ENOTNAM</td><td>118</td><td>Not a XENIX-named</td><td>不是XENIX命名的</td></tr><tr><td>ENAVAIL</td><td>119</td><td>No XENIX semaphores</td><td>没有XENIX信号量</td></tr><tr><td>EISNAM</td><td>120</td><td>Is a named type file</td><td>是一个命名的文件类型</td></tr><tr><td>EREMOTEIO</td><td>121</td><td>Remote I/O error</td><td>远程输入/输出错误</td></tr><tr><td>EDQUOT</td><td>122</td><td>Quota exceeded</td><td>超出磁盘配额</td></tr><tr><td>ENOMEDIUM</td><td>123</td><td>No medium found</td><td>没有磁盘被发现</td></tr><tr><td>EMEDIUMTYPE</td><td>124</td><td>Wrong medium type</td><td>错误的媒体类型</td></tr><tr><td>ECANCELED</td><td>125</td><td>Operation Canceled</td><td>取消操作</td></tr><tr><td>ENOKEY</td><td>126</td><td>Required key not available</td><td>所需Key不可用</td></tr><tr><td>EKEYEXPIRED</td><td>127</td><td>Key has expired</td><td>Key已过期</td></tr><tr><td>EKEYREVOKED</td><td>128</td><td>Key has been revoked</td><td>Key被撤销</td></tr><tr><td>EKEYREJECTED</td><td>129</td><td>Key was rejected by service</td><td>Key被拒绝服务</td></tr><tr><td>EOWNERDEAD</td><td>130</td><td>Owner died</td><td>所有者死亡</td></tr><tr><td>ENOTRECOVERABLE</td><td>131</td><td>State not recoverable</td><td>状态不可恢复</td></tr><tr><td>ERFKILL</td><td>132</td><td>Operation not possible due to RF-kill</td><td>由于RF-kill而无法操作</td></tr></tbody></table><p>好用的表格转换网站：tableconvert.com</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Error</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USB xHCI err -71 略解</title>
    <link href="/xxx/2019/11/USB-xHCI-err-71-%E7%95%A5%E8%A7%A3/"/>
    <url>/xxx/2019/11/USB-xHCI-err-71-%E7%95%A5%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs">kernel：linux 4.9.1USB host controler：xHCI</code></pre><p>最近遇到两个报 err -71 错误的问题，同一个device (PL2303)，分别在USB枚举阶段与数据传输阶段出错。一开始我是心累的，毕竟手里已经积攒了6个测试单，4个客户单，4个内部群在拉我对问题。对于这两个问题在我做完三件事后，心中的大石总算落下了一半，真是守得云开见月明。</p><pre><code class="hljs">1、对以往报 err -71 的问题进行梳理、总结。  2、与同事进行沟通，借助他们的经验。  3、针对性的梳理 xHCI 上报 err -71 的流程。  </code></pre><p><strong>问题梳理</strong><br>场景是环境不断的reboot压测，即在device不掉电的情况下，host间断地与其握手、枚举、数据传输。  </p><pre><code class="hljs">usb1-2: device not accepting address2, error -71  </code></pre><p>log分析，-71 在内核的标准错误表里面是 -EPROTO /**  Protocol error  **/，即协议错误，对于USB场景，为USB协议传输错误。出问题的环境有两个，只复现了一次，还要做别的测试，比较紧缺，协调不到。而且device模组PL2303焊在单板上，没有USB口可以抓取协议包。在问题不复现，log较少，无法抓包的情况下，到底是host发包错了，还是device回复错了呢，或是外部因素影响了，真是没啥头绪啊！</p><p><strong>回溯以往问题</strong><br>我在问题单系统里搜索了一番，搜索出来的问题单很多，我有权限看的问题单就二张。不过有，总好过没。<br>问题单①，USB host control是ehci，U盘插进单板，开始能识别，几分钟过后不识别，输出以下log，低概率发生。</p><pre><code class="hljs">usb1-2: device not accepting address8, error -71  usb1-2: reset high-speed USB device number8 using ehci-platform  usb1-2: usb-storage timed out onep0out len=0/0  usb1-2: device not accepting address8, error -71  usb1-2: reset high-speed USB device number8 using ehci-platform  usb1-2: device descriptor read/64, error -71  usb1-2: device descriptor read/64, error -71usb1-2: USB disconnect, device number8sd1:0:0:0:[sdb] tag#0 UNKNOWN(0x2003) Result: hostbyte=0x03 driverbyte=0x00sd1:0:0:0:[sdb] tag#0 CDB: opcode=0x28 28 00 00 00 0a27 00 00 01 00blk_update_request: I/O error, dev sdb, sector2599</code></pre><p>从log分析，先是reset，后报I/O error，指向了第2599个sector 。一开始觉得很纳闷，都枚举识别完了，怎么又reset，重新识别一次呢？还有操作相关sector失败的I/O error。后面想起与Android 储存同事沟通时获取到的一个信息，Android会在U盘插入后，进行一次fsck扫描，判断该盘的健康状态。从这个思路出发，我对U盘进行了一次坏块扫描。发现U盘处于亚健康状态，存在662个严重块，而严重块的响应时间在2~6s，同时U盘的分区较多，存在分区表恰好落在严重块上的情况。在上层读取分区参数或者进行fsck扫描时，存在读取超时的情况，包括底层USB通信超时。USB通信超时，就会与设备重新握手识别，log输出 “reset high-speed USB device number2 using ehci-platform” 。</p><p>问题单②，USB host control是ehci，U盘插进单板，上电识别 (device先插入host，host再上电启动) 报 err -71 ，必现。</p><pre><code class="hljs">usb1-2: device not accepting address2, error -71  usb1-2: reset high-speed USB device number2 using ehci-platform  usb1-2: device not accepting address3, error -71  </code></pre><p>通过USB夹具先给U盘供电，再插入已启动完全的环境中，问题也能复现。出现这个问题的设备也不少。其中部分设备如果先供电时间小于3s，不复现该问题。这个与U盘响应host枚举的时间窗口有关，原因直接定位为设备问题。<br>虽然是设备问题，但也与方案整体的兼容性有关。可能存在因兼容性不够，而导致软件需要二次识别设备并在过程中报 -71 错误。<br>解决方案：在不考虑成本的情况下 (GPIO可是珍稀资源)，通过GPIO控制vbus，在识别过程中让设备重新上电，避开设备存在的识别窗口时间问题；低成本的方法就是让软件多次去retry，握手识别，留下 err -71 的error log。</p><p>从上面两个案例来看都是设备自身问题，和同事沟通后，了解到也有因硬件导致信号质量不好报 -71 的问题。</p><p><strong>xHCI 代码流程</strong><br>因为两个err -71问题的环境使用的都是xHCI，所以我们只关心xHCI。usb软件层面的错误码我们已经清楚是error -71，下面我们就要去找逻辑层面的错误码了，即xHCI的 TRB Completion Code。我们主要关注 xhci.c、xhci.h 和 xhci-ring.c这三个文件。根据error是 -71，我们直接搜索 -EPROTO，结合问题点发生在枚举和数据传输阶段，确定了两个函数。  </p><pre><code class="hljs">xhci.c --&gt; static int xhci_setup_device(struct usb_hcd *hcd, struct usb_device *udev,                                 enum xhci_setup_dev setup)&#123;    ......    case COMP_TX_ERR:        dev_warn(&amp;udev-&gt;dev, &quot;Device not responding to setup %s.\n&quot;, act);        ret = -EPROTO;        break;    case COMP_DEV_ERR:    ......&#125;</code></pre><p>在上述函数中，我们看到进入 COMP_TX_ERR 分支会引起 -EPROTO。</p><pre><code class="hljs">xhci-ring.c --&gt; static int handle_tx_event(struct xhci_hcd *xhci,                                struct xhci_transfer_event *event)                            __releases(&amp;xhci-&gt;lock)                            __acquires(&amp;xhci-&gt;lock)&#123;    ......    case COMP_SPLIT_ERR:    case COMP_TX_ERR:        xhci_dbg(xhci, &quot;Transfer error on endpoint\n&quot;);        status = -EPROTO;        break;    case COMP_BABBLE:        xhci_dbg(xhci, &quot;Babble error on endpoint\n&quot;);        status = -EOVERFLOW;        break;    ......        goto cleanup;       case COMP_DEV_ERR:        xhci_warn(xhci, &quot;WARN: detect an incompatible device&quot;);        status = -EPROTO;        break;    ......&#125;</code></pre><p>在上述函数中，我们看到进入 COMP_TX_ERR 或者 COMP_DEV_ERR 分支都会引起 -EPROTO，为方便后续定位问题，我们把 COMP_TX_ERR分支里面的 xhci_dbg 修改为 xhci_warn。  </p><p>我们把加了打印的版本拿去复现问题，在复现log中，有 “Transfer error on endpoint” 而没有 “WARN: detect an incompatible device”，即我们可以确定 TRB Completion Code 是 COMP_TX_ERR。  </p><pre><code class="hljs">xhci.h --&gt;/* USB Transaction Error */#define COMP_TX_ERR    4</code></pre><p>在 xhci.h 里面我们找到了 COMP_TX_ERR，usb的事务错误，值为 4 。既然拿到了逻辑层面的错误码的值，我们就可以去看xhci的手册了。<br>这个是手册的下载链接：<br><a href="https://www.intel.com/content/www/us/en/products/docs/io/universal-serial-bus/extensible-host-controler-interface-usb-xhci.html">https://www.intel.com/content/www/us/en/products/docs/io/universal-serial-bus/extensible-host-controler-interface-usb-xhci.html</a></p><p>在手册 <strong>6.4.5 TRB Completion Code</strong> 中详细说明了每个错误码的意思。我们看到 value 4 ，USB Transaction Error的描述：“Asserted in the case where the host did not receive a vaild response from the device (Timeout, CRC, Bad PID, unexpected NYET, etc).“ 大意是 “主机未从设备收到有效响应例如超时，CRC错误，错误的PID，意外的NYET等。” 结合上述步骤，我们大概可以确定，两个err -71问题都是设备问题，如果要明确，那就需要抓协议包了。  </p><p><strong>尾声</strong><br>后续沟通，了解到一个情况，PL2303在高波特率的情况下会工作不稳定，而两个问题单的PL2303波特率都是4M，我们平时接触的115200，也就0.1M而已。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>USB</tag>
      
      <tag>XHCI</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 识别 Camera 报 -110 错误</title>
    <link href="/xxx/2019/10/Android-%E8%AF%86%E5%88%AB-Camera-%E6%8A%A5-110-%E9%94%99%E8%AF%AF/"/>
    <url>/xxx/2019/10/Android-%E8%AF%86%E5%88%AB-Camera-%E6%8A%A5-110-%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">版本：Android O、<span class="hljs-selector-tag">P</span><br>Linux <span class="hljs-number">4.9</span><br></code></pre></td></tr></table></figure><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>罗技 C270 摄像头插入 Android 单板后报 uvcvideo: Failed to query( GET_ DEF) UVC control2 on unit2:-110 异常错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">usb1<span class="hljs-number">-3</span>: new high-speed USB device number <span class="hljs-number">9</span> using ehci-platform<br>uvcvideo: Found UVC <span class="hljs-number">1.00</span> device &lt;unnamed&gt; (<span class="hljs-number">046</span>d:<span class="hljs-number">0825</span>)<br>input: UVC Camera (<span class="hljs-number">046</span>d:<span class="hljs-number">0825</span>) as /devices/platform/soc/f9890000.ehci/usb1/<span class="hljs-number">1</span><span class="hljs-number">-3</span>/<span class="hljs-number">1</span><span class="hljs-number">-3</span>:<span class="hljs-number">1.0</span>/input/input8<br>usb1<span class="hljs-number">-3</span>: HotpLugThread timed out on ep0in len=<span class="hljs-number">0</span>/<span class="hljs-number">2</span><br>uvcvideo: Failed to query (GET_DEF) UVC control2 on unit2:<span class="hljs-number">-110</span> (<span class="hljs-built_in">exp</span><span class="hljs-number">.2</span>).<br>usb1<span class="hljs-number">-3</span>: HotpLugThread timed<br>uvcvideo: Failed to query (GET_DEF) UVC control5 on unit2:<span class="hljs-number">-110</span> (<span class="hljs-built_in">exp</span><span class="hljs-number">.1</span>).<br>usb1<span class="hljs-number">-3</span>: HotpLugThread timed out onep0in len=<span class="hljs-number">0</span>/<span class="hljs-number">1</span><br>uvcvideo: Failed to query (GET_CUR) UVC control2 on unit1:<span class="hljs-number">-110</span> (<span class="hljs-built_in">exp</span><span class="hljs-number">.1</span>).<br>usb1<span class="hljs-number">-3</span>: <span class="hljs-built_in">set</span> resolution quirk: cval-&gt;res = <span class="hljs-number">384</span><br></code></pre></td></tr></table></figure><h4 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h4><p>1、从  log 分析，Camera 插入单板， USB 枚举完成后，上层开始获取 Camera 支持的功能。如 “GET_ DEF UVC control2 on unit2”，”GET_ DEF UVC control5 on unit2”，就是在获取 video 相关的功能。但获取上述功能描述都失败了，上报 了-110 的错误码，即 timeout / 超时。</p><p>2、跟踪代码</p><p>log 打印位置在 “../drivers/media/usb/uvc/uvc_video.c +85” 的 uvc_query_ctrl() 函数内。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">uvc_query_ctrl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> uvc_device *dev, u8 query, u8 unit,</span><br><span class="hljs-params">                        u8 intfnum, u8 cs, <span class="hljs-type">void</span> *data, u16 size)</span><br>&#123;<br>        <span class="hljs-type">int</span> ret;<br>        u8 error;<br>        u8 tmp;<br><br>        ret = __uvc_query_ctrl(dev, query, unit, intfnum, cs, data, size,<br>                                UVC_CTRL_CONTROL_TIMEOUT);<br>        <span class="hljs-keyword">if</span> (likely(ret == size))<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        uvc_printk(KERN_ERR,<br>                   <span class="hljs-string">&quot;Failed to query (%s) UVC control %u on unit %u: %d (exp. %u).\n&quot;</span>,<br>                   uvc_query_name(query), cs, unit, ret, size);<br><br>        <span class="hljs-keyword">if</span> (ret != -EPIPE)<br>                <span class="hljs-keyword">return</span> ret;<br><br></code></pre></td></tr></table></figure><p>-110 是 __uvc_query_ctrl() 函数的返回值，ret 。</p><p>追踪 __uvc_query_ctrl() 函数，位于 “../drivers/media/usb/uvc/uvc_video.c +33”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __uvc_query_ctrl(<span class="hljs-keyword">struct</span> uvc_device *dev, u8 query, u8 unit,<br>                        u8 intfnum, u8 cs, <span class="hljs-type">void</span> *data, u16 size,<br>                        <span class="hljs-type">int</span> timeout)<br>&#123;<br>        u8 type = USB_TYPE_CLASS | USB_RECIP_INTERFACE;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pipe;<br><br>        pipe = (query &amp; <span class="hljs-number">0x80</span>) ? usb_rcvctrlpipe(dev-&gt;udev, <span class="hljs-number">0</span>)<br>                              : usb_sndctrlpipe(dev-&gt;udev, <span class="hljs-number">0</span>);<br>        type |= (query &amp; <span class="hljs-number">0x80</span>) ? USB_DIR_IN : USB_DIR_OUT;<br><br>        <span class="hljs-keyword">return</span> usb_control_msg(dev-&gt;udev, pipe, query, type, cs &lt;&lt; <span class="hljs-number">8</span>,<br>                        unit &lt;&lt; <span class="hljs-number">8</span> | intfnum, data, size, timeout);<br>&#125;<br></code></pre></td></tr></table></figure><p>返回值则来自 usb_control_msg() 函数，追踪 __uvc_query_ctrl() 函数，位于 “../drivers/usb/core/message.c +135”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">dr-&gt;wIndex = cpu_to_le16(index);<br>dr-&gt;wLength = cpu_to_le16(size);<br><br>ret = usb_internal_control_msg(dev, pipe, dr, data, size, timeout);<br><br><span class="hljs-comment">/* Linger a bit, prior to the next control message. */</span><br><span class="hljs-keyword">if</span> (dev-&gt;quirks &amp; USB_QUIRK_DELAY_CTRL_MSG)<br>        msleep(<span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure><p>返回值则来自 usb_internal_control_msg() 函数，追踪 usb_internal_control_msg() 函数，位于 “../drivers/usb/core/message.c +85”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">usb_fill_control_urb(urb, usb_dev, pipe, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)cmd, data,<br>                     len, usb_api_blocking_completion, <span class="hljs-literal">NULL</span>);<br><br>retv = usb_start_wait_urb(urb, timeout, &amp;length);<br><span class="hljs-keyword">if</span> (retv &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> retv;<br><span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> length;<br></code></pre></td></tr></table></figure><p>返回值则来自 usb_start_wait_urb() 函数，追踪 usb_start_wait_urb() 函数，位于 “../drivers/usb/core/message.c +48”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">retval = usb_submit_urb(urb, GFP_NOIO);<br><span class="hljs-keyword">if</span> (unlikely(retval))<br>        <span class="hljs-keyword">goto</span> out;<br><br>expire = timeout ? msecs_to_jiffies(timeout) : MAX_SCHEDULE_TIMEOUT;<br><span class="hljs-keyword">if</span> (!wait_for_completion_timeout(&amp;ctx.done, expire)) &#123;<br>        usb_kill_urb(urb);<br>        retval = (ctx.status == -ENOENT ? -ETIMEDOUT : ctx.status);<br></code></pre></td></tr></table></figure><p>到这里，我们终于找到了 -110 的真身了，就是 wait_for_completion_timeout(&amp;ctx.done, expire) 的状态  ctx.status 如果是 -ENOENT ，则上报 -ETIMEDOUT 即 -110 。具体意思就是系统等待 usb_submit_urb() （urb，USB 协议对传输数据封装的结构体）的完成，但是等待超时了。</p><p>一般 USB timeout 会设置为 5000ms，所以我倒追 timeout 值，它就是 __uvc_query_ctrl 函数的 </p><p>UVC_CTRL_CONTROL_TIMEOUT，定义在 “../drivers/media/usb/uvc/uvcvideo.h +179”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> UVC_CTRL_CONTROL_TIMEOUT        500</span><br></code></pre></td></tr></table></figure><p>发现只有短短的 500ms，真的少。</p><p>3、USB 协议分析仪抓包</p><p>因不方便贴出 USB 协议分析仪抓取的协议包图片，所以用文字描述代替。</p><p>​                             |  类型  |           |     命令     |                      内容                      |    时间</p><p>SET_INTERFAEC | audio | class | SET_CUR | SAMPLING_FREQ_CONTROL | 1.310sec </p><p>SET_INTERFAEC | video | class | GET_DEF | PU_BRIGHTNESS_CONTROL  | 1.752ms</p><p>类型指该 packet 是谁发出的，命令与内容就类似 JSON 的 key:value，设置当前的某个选项，时间就是花费的时间。具体如 audio 的 packet，设置当前的采样率，花费1.3秒。</p><p>4、上层对 Camera 的 audio 和 video 设置都要使用控制传输（Control Transaction），即使用 ep0 端点获取或设置 device 的 descriptor、interface。在上层， audio 和 video 是并行的，但 USB 管道（ep0）只有一条，数据传输都是要排着队的。从协议包来看，Camera 对 audio packet 一直回 NAK，堵塞控制传输管道1.3秒，导致 video 上层超时，进而报 -110 timeout。</p><p>5、虽然目前该问题没影响到 Camera 的功能，但也不是不可能的。在特殊情况下，存在 get descriptor 或 set interface 失败，而导致 host 不知道获取失败的 descriptor 对应的能力，例如丢失了 mjpeg 1280*720 30fps 的 descriptor，那 host 就默认device 不支持 mjpeg 1280*720 30fps。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>1、参考 kernel urb transaction 的超时一般设置是 5000ms。</p><p>2、考虑对其他设备的兼容性。</p><p>3、对 kernel v4l2 代码的信任。</p><p>决定将 UVC_CTRL_CONTROL_TIMEOUT 由 500 改为 1500。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> UVC_CTRL_CONTROL_TIMEOUT        1500</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>USB</tag>
      
      <tag>Error</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>澳门游记</title>
    <link href="/xxx/2019/10/%E6%BE%B3%E9%97%A8%E6%B8%B8%E8%AE%B0/"/>
    <url>/xxx/2019/10/%E6%BE%B3%E9%97%A8%E6%B8%B8%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>澳门在印象中除了赌场就是大三巴了吧，每年政府都会派红包。小时候觉得这红包就是一笔巨款，现在也是觉得蛮多的。这次趁着国庆节，天气也很好，就去澳门来个一天游。</p><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p><strong>广州南站 –&gt; 珠海站 –&gt; A出口 –&gt; 拱北口岸</strong></p><p>广州南去珠海，坐城轨还是很快的，刚好一个小时。从珠海站A出口出来，跟着人流就可以走到口岸了。最近香港事情多，去香港的人都来澳门了，过关的时间超过了一个小时。排队的时候，签证窗口突然多开了几个，见缝插针，切换队伍提前了好多个身位。</p><p><strong>–&gt; 关闸广场</strong></p><p>一开始是打算坐金沙的发财车去渔人码头的，转了一圈就没看到有任何一辆发财车，只好坐巴士去了。关闸广场下面就是巴士站了，可以搭扶梯下去。澳门巴士多数是环线，不分段收费，统一是 6澳门元。澳门通用港元，不过汇率差就没人和你算了。没有零钱坐巴士的我们，只好去万宁买点东西，换零钱。尴尬的是关闸广场的这家万宁，眼药水的品类真的是非常单一，还没国内的丰富。最后买了一瓶益达，剩下的让柜台小姐姐换成合适坐巴士的零钱了。</p><p>**–&gt;渔人码头 **</p><p>去渔人码头的巴士具体坐了哪路已经忘记了，是到友谊马路行车天桥站下车的，下车后（市政施工，没有明确指向）往右边的天桥柱子绕一下，直接走过马路去就到了。渔人码头对海望去是友谊大桥，里面有罗马斗兽场、布达拉宫，风景很不错，有一条美食街，人流一般，整体氛围合适拍照、出图。离澳门科学馆也比较近，可以后续步行前往。</p><p>友谊大桥</p><img src="http://pic.xxxdk.xyz/澳门游记-01.jpg" alt="友谊大桥" style="zoom: 67%;" /><p>美食街内</p><img src="http://pic.xxxdk.xyz/澳门游记-21.jpg" alt="美食街内" style="zoom: 67%;" /><p>怡景餐厅</p><img src="http://pic.xxxdk.xyz/澳门游记-18.jpg" alt="美食街内" style="zoom: 67%;" /><p><strong>–&gt; 新八佰伴</strong></p><p>新八佰伴是个购物中心，每层一个品类的商品，一楼主要是护肤、化妆以及香水为主，折扣还行吧，往上走还有服装和玩具之类的。从渔人码头到新八佰伴可以在澳门励庭海景酒店站坐10A到中区殷皇子马路站，当然也可以先看完澳门艺术博物馆、澳门科学馆再坐车过去。</p><p>巴士下车后先去了附近的奥特莱斯转了转，后去了附近的二层超市。超市生活品类的商品还是很丰富的，但来超市的人很少。逛超市的目的有两个，第一是了解澳门的生活，第二是买水。但是偌大的超市居然没什么水觉得新奇或者可以下手买的，两手空空的就离开了。离开超市已经中午， 就去新八佰伴后面的麦当劳吃午饭了。买单来说，这边的麦当劳已经可以用微信、支付宝了。品类的话，比国内的丰富，有一款特饮是非常的好喝，酸酸甜甜的，国内并没有。</p><p><strong>–&gt; 南湾湖</strong></p><p>吃完麦当劳出来就是南湾湖了，南湾湖是个人工湖，近处可以看到澳门特别行政区政府总部，远处可以望到澳门塔 。区别于香港政府总部是摩天大楼，澳门政府总部是小洋楼。</p><p>南湾湖-澳门塔</p><img src="http://pic.xxxdk.xyz/澳门游记-14.jpg" alt="美食街内" style="zoom: 67%;" /><p>澳门特别行政区政府总部</p><img src="http://pic.xxxdk.xyz/澳门游记-02.jpg" alt="美食街内" style="zoom: 67%;" /><p>政府总部周边-1</p><img src="http://pic.xxxdk.xyz/澳门游记-03.jpg" alt="美食街内" style="zoom: 67%;" /><p>政府总部周边-2</p><img src="http://pic.xxxdk.xyz/澳门游记-13.jpg" alt="美食街内" style="zoom: 67%;" /><p>政府总部周边-3</p><img src="http://pic.xxxdk.xyz/澳门游记-15.jpg" alt="美食街内" style="zoom: 67%;" /><p><strong>–&gt; 大三巴</strong></p><p>大三巴也在新八佰伴附近，可以直接步行过去。路上的景点蛮多的，玫瑰圣母堂、大炮台、哪吒庙、澳门民政总署、议事亭前地等。大三巴前面是它的形象，后面就是它的历史。在前面台阶拍完照后，可以去后面看看的它的历史介绍，天主教博物馆，在大三巴左侧就是哪吒庙。</p><p>玫瑰圣母堂</p><img src="http://pic.xxxdk.xyz/澳门游记-04.jpg" alt="美食街内" style="zoom: 67%;" /><p>大三巴附近-1</p><img src="http://pic.xxxdk.xyz/澳门游记-16.jpg" alt="美食街内" style="zoom: 67%;" /><p>大三巴附近-2</p><img src="http://pic.xxxdk.xyz/澳门游记-19.jpg" alt="美食街内" style="zoom: 67%;" /><p>大三巴附近-3</p><img src="http://pic.xxxdk.xyz/澳门游记-20.jpg" alt="美食街内" style="zoom: 67%;" /><p>大三巴-1</p><img src="http://pic.xxxdk.xyz/澳门游记-05.jpg" alt="美食街内" style="zoom: 67%;" /><p>大三巴-2</p><img src="http://pic.xxxdk.xyz/澳门游记-08.jpg" alt="美食街内" style="zoom: 67%;" /><p>大三巴-3</p><img src="http://pic.xxxdk.xyz/澳门游记-06.jpg" alt="美食街内" style="zoom: 67%;" /><p>大三巴-4</p><img src="http://pic.xxxdk.xyz/澳门游记-07.jpg" alt="美食街内" style="zoom: 67%;" /><p>大三巴-5</p><img src="http://pic.xxxdk.xyz/澳门游记-17.jpg" alt="美食街内" style="zoom: 67%;" /><p>哪吒庙前小巷</p><img src="http://pic.xxxdk.xyz/澳门游记-09.jpg" alt="美食街内" style="zoom: 67%;" /><p><strong>–&gt; 新葡京</strong></p><p>原本是要去威尼斯人的，毕竟威尼斯人看的东西比较多，但是时间不够只能选择新葡京了。新葡京看起来台面以猜大小、百家乐为主，也有电子的百家乐吧，不过现场是没有性感荷官，在线发牌，哈哈。</p><p>新葡京周边-1</p><img src="http://pic.xxxdk.xyz/澳门游记-10.jpg" alt="美食街内" style="zoom: 67%;" /><p>新葡京周边-2</p><img src="http://pic.xxxdk.xyz/澳门游记-11.jpg" alt="美食街内" style="zoom: 67%;" /><p>新葡京</p><img src="http://pic.xxxdk.xyz/澳门游记-12.jpg" alt="美食街内" style="zoom: 67%;" /><p><strong>–&gt; 回程</strong></p><p>新葡京回关闸的发财车这次终于见到了，长长的人龙，提示牌描述队尾已经要排一个半小时了，但加入队伍的人还是有增无减。新葡京出大门过街就有个巴士站，仙德丽街站。在这里有不停站，直达关闸广场的巴士，回去十分的简单与快捷。直达巴士的路线基本在澳门生活区，可以观察澳门人民的生活，还会路过金莲花广场，可以留意。</p><p>回到关闸广场又去麦当劳买了杯特饮、内地没有得苹果派，就坐高铁回程了。</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>澳门人民给我感觉比香港市民更亲切，在市政署内有新中国成立70周年的活动，也有给游客耐心讲解澳门历史的热心市民。澳门粤语口音也是偏向于珠江西岸，但没有顺德、番禺那么圆润。</p><p>这次行程主要是买水难，瓶装纯净水特别的贵，有部分地方还不能使用移动支付。有个遗憾，没有看到当晚的烟花大赛，10月5号是最后一场，可惜晚上8点才开始，对当晚就要回到广州的我们来说，太晚了。</p><p>行程太紧只在澳门半岛转了转，氹仔岛、路环岛都没去到，黑沙海滩也没有去成，还有澳门数量众多的博物馆也就看了下可口可乐博物馆，希望下次还有时间去看看。</p><hr><p><em>下面是前期做攻略的路线。</em></p><p><em>–&gt; 渔人码头</em></p><p><em>1、金沙发财车</em></p><p><em>2、关闸总站坐 AP1/10 到友谊马路行车天桥站（14分钟）。</em></p><p><em>3、关闸广场坐 3A 到渔人码头会展中心站（17分钟）。</em></p><p><em>4、关闸马路三角花园站坐 1A/29/28B 到友谊马路行车天桥站（13分钟）。</em></p><p><em>–&gt; 新八佰伴</em><br><em>步行</em></p><p><em>–&gt; 新葡京</em><br><em>步行</em></p><p><em>–&gt; 威尼斯人</em><br><em>交通：</em><br><em>1、亚马喇前地站坐 50B 到澳门土木工程实验室站（19分钟）</em><br><em>2、亚马喇前地站坐 50B 到连贯公路,新濠天地站（19分钟）</em></p><p><em>附近目的点：</em><br><em>三楼有购物</em></p><p><em>–&gt; 回口岸</em><br><em>交通：</em><br><em>1、发财车</em><br><em>2、伟龙科技大学站坐 AP1X 到关闸广场站（27分钟）</em><br><em>3、望德圣母湾马路连贯公路坐 AP1X 到关闸总站（48分钟）</em></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游记</tag>
      
      <tag>澳门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《中国问题》</title>
    <link href="/xxx/2019/08/%E8%AF%BB%E3%80%8A%E4%B8%AD%E5%9B%BD%E9%97%AE%E9%A2%98%E3%80%8B/"/>
    <url>/xxx/2019/08/%E8%AF%BB%E3%80%8A%E4%B8%AD%E5%9B%BD%E9%97%AE%E9%A2%98%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<p>前言：《中国问题(英文版)》内容简介：1920年10月，罗索怀着对东方智慧国度的敬仰之情抵达上海。他不满于在苏联见到的革命后的种种情形，是到中国来“寻找新的希望”的。罗素在中国讲学、访问一年，悉心研讨中国文化，尤其着眼于中西文化的异同，于1922年发表了《中国问题(英文版)》。时隔近一个世纪，罗素在书中预言的种种情形皆在美国、苏联、中国和日本的发展进程中一一应验了，我们不禁深深为这位睿智的老人所折服。——豆瓣 <a href="https://book.douban.com/subject/6558623/">https://book.douban.com/subject/6558623/</a>  </p><p>8月12-13日<br>第一章，中国的种种问题<br>感受最深的莫过于这句，“至于人生的乐趣，是我们活在工业文明的时代，受生活环境重压而失去的最重要、最普通的东西。”，现在城市生活的真实描述！老先生将大国分为经济、政治、文化三部分，文化是他最重视的方面。</p><p>8月13-14日<br>第二章，19世纪以前的中国<br>China，源自秦朝的发音“Chin”，秦的一统虽然时间短暂，但始皇帝开拓的疆土已有中国的大致轮廓。中国东有海疆、南部小国不好战，西部的青藏高原、戈壁荒漠阻挡了诸多强敌，历史上也只有蒙古和女真做到了一统。中华文化从周到清，起起伏伏，中原凭借着先进的生产力和文明，不断的同化着周边。<br>中国文化普遍特征作者归纳为了三点，或许正是这三点让我们的文明源远流长。<br>1、文字由表意符号构成，而不是字母。<br>2、在受教育阶层中孔子的伦理学取代了宗教。<br>3、政府掌握在由科举制度选拔出来的文人学士而非世袭贵族手中。</p><p>8月16日<br>孔子代表的儒家是一种政治思想而不是宗教，对中国的影响莫过于宗教极少时候成为主流。<br>左传，晋侯问师旷：“卫人出其君，不亦甚乎？”师旷回答说：“或者其君实甚，……夫君，神之主，民之望也。若困民之主，匮神乏祀，百姓绝望，社稷无主，将安用之，弗去何为？”<br>长期以来，中国的读书人都是儒家的弟子，至于其他老百姓，则对儒佛道三者都信奉。我们西方人沿袭了犹太人的思想，若认定一种宗教，其余的都为异端，然而中国人没有这种观念。</p><p>第三章，中国与西方各国<br>谈到庚子赔款，有一件事值得提一下。美国人得到的赔款，除了补偿损失外还有富余，就退还中国作为高等教育经费。其中一部分在中国开设由美国人管理的大学，一部分资助出类拔萃的中国学生留美求学。中国由此受益匪浅，而美国则得到了中国人（尤其是受过高等教育者）的友谊，美国由此取得的利益更是无法计算。大家都清楚这种做法对双方都有益，但英国没有半点仿效的迹象。</p><p>8月17日<br>第四章，现代中国<br>我们可以教中国人的并不是我们的道德，也不是治国箴言，而是科学与技术。中国的知识分子所真正面临的问题是学习西方人的知识而不要染上西方人机械的人生观。<br>也许我所谓的“机械的人生观”含义还不十分清楚，我指的是一种同等地存在于帝国主义、布尔什维主义和基督教青年会的观点。机械的人生观把人看作一堆原料，可以用科学方法加工处理，塑造成任何合我们心意的模式。这种观点使得上述主义的观点有别于中国人的人生观，而机械的人生观在我看来是十分有害的。在有这种想法的人看来，当务之急是培植个人的意愿，哪怕牺牲感觉也无所谓。中国的知识分子虽然并不为帝国主义所困扰，但却容易成为布尔什维主义与基督教青年会争取的对象。由于布尔什维主义而信仰阶级斗争和共产党的专政，由于青年会而信仰冷水浴和哑铃。但西方的共产党和青年会只有在把其他人视为潜在的皈依者时才不轻视他们，认为只有待他们所传播的主义盛行之后人类才会有进步。他们都信任政府而反对自然。我虽然称这种眼光为机械的，但它实际上和宗教一样古老，只不过近代的机器给予了它一种更具毒性的新形式。中国古代的哲学家老子在著作中抗议这种观点，他的徒弟庄子则用寓言来描绘。<br>*中国现在已经基于布尔什维主义走出了自己的道路。</p><p>8月25日<br>第五章，明治维新前的日本；第六章，现代日本。<br>日本要解决的问题颇为棘手。要供养新增人口，必须发展工业；要发展工业，必须得到中国的原料；要得到中国的原料，不得不触犯欧美的经济利益；要触犯欧美的经济利益，必须要维持强大的海陆军，而这反过来势必使得依靠薪金糊口的工人遭受困苦。以工人的穷困为代价发展工业，这意味着民众的日益不满、社会主义的得势、穷人对于天皇渐失敬意，因此更大的威胁是国家的基础就要为之动摇。对于日本来说，外面有日美交战和中国复兴的危险，内部有平民革命的危险。<br>要免除这种种的危险，只有降低人口出生率这个方法。但枪炮下的牺牲品也因之减少，这种想法不仅为军国主义分子所痛恨，而且与日本的宗教道德里忠君爱国的基础势不两立。所以，日本要使自己立于不败之地，必须增强对西方的学习。不仅是制造方法，所有的知识都应该学习；甚至宗教、人生观也应当西化；此外还应推行思想自由，采用怀疑主义，削弱部落观念。如果不采取这些做法，人口问题就无法解决。而人口问题不解决，则迟早会有大难临头。<br>*作者是否看清了日本的文化传统还是觉得日本人的学习能力很强，连文化传统都可以改变？人口方面，日本已经不担心过度增长了，9102年，老龄化困扰着他们。</p><p>N/A<br>第七章，1914年之前的日本与中国<br>日本，藩族的分立与相互争战，除了朝鲜、偶尔与中国有些接触。在势均力敌的争斗中，“忠”自然是备受推崇的美德。中国国势巩固，版图广袤，历史悠久，在这样的国家，“忠”就并非必需。国泰民安的中国就产生了谦恭、谨慎、圆滑等美德。</p><p>第八章，“大战”中的日本与中国<br>布尔什维克得到了中国年轻学生的热烈响应。如果它能渡过现在的难关，那它就大有希望成为使亚洲脱离列强摆布的进步人士众望所归的解放者。苏俄没有被华盛顿会议邀请，所以他们没有签署任何条约，有可能不偏不倚地破坏日、美、英的野心。美国对于他国的野心从来就没有减弱过，只不过他的野心不在于土地而在于经济。如果美国在远东取得胜利，那么，中国必将美国化，虽然政治上的自由可保无虞，然而经济上、文化上的束缚将来就难以摆脱了。俄国的势力可能就没有这么强大，然而他将来或许能为中国争得一些真正的自由。但这一切只不过是一种可能。这一点不能忘记，因为如果大家都不愿意记住这一点，而且如果世界仍然将俄国视作败类，那么，远东问题无论怎样解决都不可能长久。至于苏俄对于中国将产生怎样的影响，目前尚难以预料。<br>*20世纪初的日本真的是小人，二战后被美国爸爸安排得明明白白，可惜最近这几年不给力。一战后，美国参议院就有讨论山东的去向，美国成为世界警察(我更觉得是盟主)应该也是这段时间开始的吧。</p><p>第九章，华盛顿会议。<br>除非美国人忘记历史，不然必定长期压制日本。华盛顿会议、日内瓦会议已经埋下了将来战争的种子。日本想将中国列入保护国，控制苏俄的远东共和国(大清被沙俄吞并的领土)，与美国角力太平洋。<br>*日本的野心从明治维新后就无法压制了吧，而现在呢？俄罗斯占领了日本北方四岛，美国驻军日本。</p><p>第十章，远东当前的各种势力与发展趋势<br>美国政策不会给旧中国这样的弱国带来自由，恐怕只有国际社会主义才能保证自由与和平兼得。</p><p>第十一章，中西文明的对比<br>老子曰：“生而不有，为而不恃，长而不宰。”<br>中华文明比西方更宽厚、慈善。无休止的好勇斗狠不仅产生了明显的恶果，还使我们不知足，不能享受美，使我们失去思考的美德。<br>*当代中国人在西方科学的冲击下正慢慢丢失传统美德，在教育中更是缺少相关的思想的培养，弘扬中华传统这话让人感到无力。对于在高压的社会里拼搏的年轻人，社会的残酷使大家失去思考宽厚、平和、知足以及享受美。</p><p>第十二章，中国人的性格<br>中国人，从上层社会到底层百姓，都有一种他们坐等不幸自行消退，像汽水的泡沫一样自行消失。冷静安详的尊严，即使接受了欧洲的教育也不会毁掉。无论个人还是国家，他们都不自我肯定；他们的骄傲过于深厚，无需自我肯定。<br>典型的西方人希望自己可以尽可能多地改变所处环境；典型的中国人则希望尽可能多地享受自然环境之美。<br>中国人的性格中最让欧洲人惊讶的莫过于他们的忍耐了。<br>中国人的实力在于四万万人口，在于民族习惯的坚韧不拔，在于强大的消极抵制力，以及无可比拟的民族凝聚力。<br>中国著名作家请教作者国人的主要弱点，作者推辞不过，说了三点。他听后，不但不生气，还认为批评恰当，进而探讨补救的方法。这是中国知识分子正直的一例，正直是中国的最大优点。<br>中国人主要的弱点/缺点:贪婪、怯懦、冷漠。<br>中国人对知识抱有主动和怀疑的态度，但感情上未免有些迟缓。同时相反的一面，中国人易于激动而致群情激愤。<br>*民族的坚韧不拔、消极抵制力最好的表现莫过于勤奋。</p><p>第十三章，中国的高等教育<br>中国的教育模式，包括旧时的经书教育和传教士所首创的新式教育，即现在几乎都把持在美国人手中的大学教育。旧时的经书教育当然不仅仅局限在初等教育的范围内，中国古典文学卷页浩瀚，且古代的文章十分艰深难懂。即便是勤奋研读的饱学之士也大有研究的空间，中国对这种学问历来很重视。新式教育又分为清华、协和医科、北大与国立北大两种，前者是由外国人所办，有意无意中为资本家渗入中国，培训为现成的工具。后者是纯粹由中国人所办，中国的莘莘学子渴求西方的学问，同时也深知西方的缺点。他们要变得科学一些，而不是机械一些；要学习工业的知识，而不是资本的知识。他们是社会主义者，他们许多优秀的中国教师也是如此。他们尊重西方的知识，但却把西方人的骄傲悄然搁在一边。  </p><p>第十四章，中国的工业<br>只不过工业的发展一定要由中国人而不是外国人来主持，这是至关重要的。<br>*不止是工业，舆论、通信业、电力等支撑社会基础的行业都应这样。湾湾和bi港的舆论就是一个好例子，美帝不允许使用华为设备也是一样。</p><p>第十五章，中国的前途<br>世界列强的利益与中国的幸福和中国文化的昌盛是无法相容的，因此中国人一定要自强自立，千万不能依靠外国人发善心。中国首先应当注重的是爱国主义思想。这种思想当然不是像义和团那样盲目地排外，而是秉着开明的态度，向他国学习但又不受其支配。中国在变得富强以保持自身独立的过程中，应当大力弘扬爱国主义，以保家卫国，而不是入侵异族。中国要想政治独立，必须做到以下三点：(1) 建立一个有秩序的政府；(2) 在中国人支配下发展工业；(3) 普及教育。<br>*打扫干净屋子再请客、和平共处五项原则、改革开放就是最好的写照。  </p><p>附言<br>上述文字在出版社等待出版之时，吴佩孚打败张作霖，重新召集国会，并与陈炯明达成一致。张作霖败退东北，宣布满洲独立。孙逸仙与陈炯明、吴佩孚内战，与张结盟。孙是真正的宪政主义者，而陈在改革者中声誉要比孙好。英国人对吴大加赞赏，对孙仇恨在心；美国人对孙大加赞赏，对吴公开谴责。无疑，孙过去的经历表明他是一个真正的爱国主义者；而广州政府是中国最好的政府。<br>*说到底还是老蒋的党政军一体才行，但忽视人民。少年中国指的是五四运动中的新青年。</p>]]></content>
    
    
    <categories>
      
      <category>提升</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Uboot下USB xHCI传输速率问题</title>
    <link href="/xxx/2019/08/Uboot%E4%B8%8BUSB-xHCI%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87%E9%97%AE%E9%A2%98/"/>
    <url>/xxx/2019/08/Uboot%E4%B8%8BUSB-xHCI%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs">uboot：uboot 2016.07kernel：linux 4.9.1</code></pre><p>　　最近遇到uboot下U盘传输速率过低的问题，速度大概只有2MB/S，USB控制器是XHCI。借助USB分析仪抓包，对比kernel和uboot的数据包差异，发现kernel下每个transfer packet大小是120KB，uboot则十分的小（具体数值忘记）。针对这个现象去定位代码，确定问题点在”common/usb_storage.c”的宏定义”USB_MAX_XFER_BLK”。</p><pre><code class="hljs">#ifdef CONFIG_USB_EHCI/* * The U-Boot EHCI driver can handle any transfer length as long as there is * enough free heap space left, but the SCSI READ(10) and WRITE(10) commands are * limited to 65535 blocks. */#define USB_MAX_XFER_BLK    65535#else#define USB_MAX_XFER_BLK    20#endif#ifndef CONFIG_BLKstatic struct us_data usb_stor[USB_MAX_STOR_DEV];#endif</code></pre><p>　　由上面代码可以知道USB_MAX_XFER_BLK的值只有20，那么transfer packet size为 20*512/1024=10，即只有10KB，跟kernel的120KB比起来真的小气啊！我们跟随kernel的值，将uboot的值修改为240，但考虑后到兼容OHCI等问题，增加XHCI分支。</p><pre><code class="hljs">#define USB_MAX_XFER_BLK    65535#elif define CONFIG_USB_XHCI_HCD#define USB_MAX_XFER_BLK    240#else#define USB_MAX_XFER_BLK    20#endif</code></pre><p>　　编译，烧入，测试，U盘的传输速度即可上到13MB/S了。</p><p>　　USB 125μs一个微帧，传输的数据量是不变的，为什么增大USB_MAX_XFER_BLK就可以增大传输速率呢？因为性价比啊！USB Storage设备在USB协议上面走的是SCSI协议，在每个transfer packet之间都会有CBW和CSW。在一定数据量的情况下，transfer packet size越小，CBW和CSW的数量就越多，这个开销不容小觑了，所以速度就慢了。</p><p>　　uboot 2018怎么改呢？还是在”common/usb_storage.c”，只不过这次我们关注宏定义”USHRT_MAX”。</p><pre><code class="hljs">#if !CONFIG_IS_ENABLED(DM_USB)#ifdef CONFIG_USB_EHCI_HCD    /*     * The U-Boot EHCI driver can handle any transfer length as long as     * there is enough free heap space left, but the SCSI READ(10) and     * WRITE(10) commands are limited to 65535 blocks.     */    blk = USHRT_MAX;#else    blk = 20;#endif</code></pre><p>　　通过查询USHRT_MAX的值为0xf0，即240，我们直接使用该宏定义，还避免了魔鬼数字。修改如下：</p><pre><code class="hljs">#if !CONFIG_IS_ENABLED(DM_USB)#ifdef CONFIG_USB_EHCI_HCD    /*     * The U-Boot EHCI driver can handle any transfer length as long as     * there is enough free heap space left, but the SCSI READ(10) and     * WRITE(10) commands are limited to 65535 blocks.     */    blk = USHRT_MAX; #elif define CONFIG_USB_XHCI_HCD    blk = USHRT_MAX; #else    blk = 20;#endif</code></pre><p>　　如果觉得240的13MB/S太慢了？那就把这个值改成4096吧！这个速度可以通过基于SSD的U盘测试，具体多少我也忘记了。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>USB</tag>
      
      <tag>uboot</tag>
      
      <tag>XHCI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Uboot 下识别带 CD-ROM 的 U盘报 *irq: data 错误</title>
    <link href="/xxx/2019/07/Uboot%E4%B8%8B%E8%AF%86%E5%88%AB%E5%B8%A6CD-ROM-U%E7%9B%98%E6%8A%A5-irq-data%E9%94%99%E8%AF%AF/"/>
    <url>/xxx/2019/07/Uboot%E4%B8%8B%E8%AF%86%E5%88%AB%E5%B8%A6CD-ROM-U%E7%9B%98%E6%8A%A5-irq-data%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">版本<br>uboot：u-boot <span class="hljs-number">2018.07</span><br></code></pre></td></tr></table></figure><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>带 CD-ROM 的U盘、硬盘在 uboot 下执行 usb star t报 *irq: data 刷屏打印。</p><h4 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h4><p>1、通过与 uboot 2010、u-boot 2016 对比发现并没有该问题。</p><p>2、加打印追踪函数，发现问题点在 disk/part_dos.c 下的 static int part_test_dos(struct blk_desc *dev_desc) 函数。</p><p>3、考虑到以往版本没问题，于是查看该文件的修改记录，发现了这笔提交。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">@@ <span class="hljs-number">-90</span>,<span class="hljs-number">7</span> +<span class="hljs-number">90</span>,<span class="hljs-number">7</span> @@ <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test_block_type</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buffer)</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">part_test_dos</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_desc *dev_desc)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SPL_BUILD</span><br>-ALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, dev_desc-&gt;blksz);<br>+ALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">if</span> (blk_dread(dev_desc, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (ulong *)mbr) != <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br></code></pre></td></tr></table></figure><p>这笔修改是觉得为 mbr 申请一个 legacy_mbr * dev_desc-&gt;blksz的内存空间太浪费了，申请一个  legacy_mbr 大小就够了。</p><p>4、checkout 这个修改，发现问题解决。</p><p>5、该笔提交与内存相关，继续追踪使用 mbr 的函数。</p><p>blk_dread(dev_desc, 0, 1, (ulong *)mbr) –&gt; blkcache_read(block_dev-&gt;if_type, block_dev-&gt;devnum, start, blkcnt, block_dev-&gt;blksz, buffer)  –&gt; memcpy(buffer, src, blksz * blkcnt);</p><p>最后确定问题是因为 blkcache_read 内的 memcpy 越界了。</p><p>6、结合问题是发生在usb start 识别U盘阶段，在函数 part_test_dos 内部。我们认为识别存储类设备时，需要读取并解析其分区表，而分区表大小与设备的 sector 相关。sector即是block size，普通U盘 sector 大小是 512 byte，移动硬盘可能存在 4096 byte，对于 CD-ROM设备则是 2048 byte。</p><p>7、对结构体 legacy_mbr 大小的计算为 512 byte。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/* based on linux/include/genhd.h */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition</span> &#123;</span><br>u8 boot_ind;<span class="hljs-comment">/* 0x80 - active */</span><br>u8 head;<span class="hljs-comment">/* starting head */</span><br>u8 sector;<span class="hljs-comment">/* starting sector */</span><br>__le16 unknown;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition</span> <span class="hljs-title">partition_record</span>[4];</span><br>__le16 signature;<br>&#125; __packed legacy_mbr;<br></code></pre></td></tr></table></figure><p>8、综上，src 对应的是 CD-ROM 的分区表，buffer 是 mbr，blksz为 2048，memcpy 自然会拷贝越界了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">blkcache_read</span><span class="hljs-params">(<span class="hljs-type">int</span> iftype, <span class="hljs-type">int</span> devnum,</span><br><span class="hljs-params">  <span class="hljs-type">lbaint_t</span> start, <span class="hljs-type">lbaint_t</span> blkcnt,</span><br><span class="hljs-params">  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> blksz, <span class="hljs-type">void</span> *buffer)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_cache_node</span> *<span class="hljs-title">node</span> =</span> cache_find(iftype, devnum, start,<br>   blkcnt, blksz);<br><span class="hljs-keyword">if</span> (node) &#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *src = node-&gt;cache + (start - node-&gt;start) * blksz;<br><span class="hljs-built_in">memcpy</span>(buffer, src, blksz * blkcnt);<br>debug(<span class="hljs-string">&quot;hit: start &quot;</span> LBAF <span class="hljs-string">&quot;, count &quot;</span> LBAFU <span class="hljs-string">&quot;\n&quot;</span>,<br>      start, blkcnt);<br></code></pre></td></tr></table></figure><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>1、使用设备的 sector 大小确定函数 part_test_dos() 中 mbr 的大小，防止内存拷贝越界。</p><p>2、为了不浪费内存资源，我们决定这样修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">part_test_dos</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_desc *dev_desc)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SPL_BUILD</span><br>-ALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, <span class="hljs-number">1</span>);<br>+ALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, (dev_desc-&gt;blksz / <span class="hljs-keyword">sizeof</span>(legacy_mbr)));<br><br><span class="hljs-keyword">if</span> (blk_dread(dev_desc, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (ulong *)mbr) != <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure><p>3、后续通过 sector 大小为 512 byte  到 8192 byte  的虚拟U盘及 4096 byte 的移动硬盘验证，均正常识别，无 *irq: data 的刷屏打印了。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>USB</tag>
      
      <tag>uboot</tag>
      
      <tag>Error</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回不去了</title>
    <link href="/xxx/2019/06/%E5%9B%9E%E4%B8%8D%E5%8E%BB%E4%BA%86/"/>
    <url>/xxx/2019/06/%E5%9B%9E%E4%B8%8D%E5%8E%BB%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="503e984df948795a5eafcbe1c1b71b10889f46026514dd22e606cacdfb205421">16c4a5cd16abe2138be58f52f480a7856f44752bc0b5e4d630842d59989c2d0ee9f922f31730715c0d3c12d4db6aaad6752c0559a15b0650d4805d1e4af12775f86f5c18bf828cb06c658eb4c05f468f40bac2485cc95634ff437c94f56bbb2e3005257e8791625431651a6cc62d49c137f29776b875efb0a87d47047c8774a8a895e82ce5bfb55a78b6a2c29e63fb1f7a8c13cf0b0b13066054ee5a57700a7a44dbb5e1054b45854fc977f9c88735db9be09ec8b7db06dc0c35eca302f84b8a0b605851fe57068419338be679e7cbe08c2423725d1168627e5c225b8e58518af05d4269e4372fb94701205847e31335729d20e422cc70dda545c70c47bed986e42cb24a54361b58eec719a4e49d0fc4fe04795e22561bc357193da87804998ff36c3ebbeafcb8308975961ce4a92dd5555b32a2df26c12b55f790a0355ebeff71d8af708600f69465422d3642d9eb64861ab508db77578d5c57122d2fcd922744772230f44f68993e47dead307bece4ea21fe0ac33f42fe3d17beb43dec82e8534636da2bf364229910ec061d82ec7909af1b13106627631c6ff1bce7a38208a2c647007b7338a0fa168dfd695bd41bdef0056b4c1b838ac5fcf939a007e80b076eb33d7b2c3f140cc3c6d2006a7c7fd8470d42095a74bd0258ec98eb111a3ecdcc705b355475f5a4d7e22e48a414db939592e515059e3ead6e3c2d445d233790c1a7bc3d3b9002971d1f14f29d597c622c53bc71de438c416f94aa9fb1fc9c2930642d92963ca3339d8bc25c492d3d8b0a524dc23290161e77587bafcc53f5c5734edb20823c85c673be49eb4d0c0182822524f7fb91f0385fce7e9d1d407f4c461be13b8b1a7a37d980a38ff05944451d642f926e5abb6aa076762cb968758f484ed5cabb935ed89f2840416e748de323836fa8455f5956a25eeb287918e0905d6361967de7a9ce40381de1ee81fb4d2fbf414c4b684c52b20d09020b6c91439e60cee8517ec93c61c5711f3035ef1d9dbaa0b066a6be7556dd633266b3a8b42b266bff1c594e1f15572c67edec97d98daff67810a9b7a4ea8d6510839102f235f50fe8965d58acf94f2db5899e59418e2712a96113812a7312ad06dc7dffb285d395994eb0679d9d420f96b8abc742af5f429d8a6477939590372fa0b481fcb4b7b392fa36c6734f65345c89f0d347604ab69ed47243192babfd4aa39d5c25151e75e8102f059ae127c662bd69a925666fd44146202085ca0f74f491d38ac560e41137b0819e43009059746c87be28b60d01aad497d3782fb015a007609e7f0da898976e55a4f6172d56f70578f079328ff53b703512bb488902ca35b73f853f68c0326494642160261b1586588881dcb94957769df8e3bf68f8989785f86d57afe6822d4f79cefd36b1e83be05774837e7a6739298796caa1cd6510fab0d5e4949d981d982931d2a6b11f060cfb61adfd165dcdd28b7d749045d6c6727e7b68d180cb9628555dbdff20d88e1a90fedd869bd29f0ce240fb9098a91f756044c30c44a2e7926fe4334a3458ccb276226c0d1d63bf7f935dac99d31f7d802856c7ee3c944595f43db40a4baae89de215b3a9af9a624bc64379991f160921f2fbe41bdf2cee8c46315329856b2e3239577a24439f2d6e7a3636d9ca2f6d347c1f1dd22f9ae1d245b72f9b9fd32d886573d99c8ffc1aa891b046c7e579fe4f7229895bb633b0ce68c28191af92d2ecd1e6b1f3b9714cf71e0d2c1c48fdfb8c4895c1337a5513351e4ec652ff9c0075c67b7518a337724c7012381f35e2b87862e1d32b51ccc12ed66a2334aeb94493d061c306079654d2587d5b01e2b2f9288edbf7411fcc621c1f8f7827ed1a29650524474565988f1061566bf4678ed46917bb6d3293818a0f80193f616a09eeafa453368c0967685af25d14b9f251d9441bce79a8b301c61113e9a2a6bb6309b5944a7228ce63e769469c8415ba52c39c335b3e6a99aafd96817462c4c33433d30573944d40251a0325b49e26447b3b57009100338128fed7de451dde073a73a84badbce9afe2a7b0592cb253af8395540c5d19555754568272adfcfc053fdc453c4be0d022146f9d24cf2b63a51eebd8e6702a7146efe339126ff5c4f7668a2e4b944ae092a6c75817627142d9c4d20eff80d99f0b1dc8c452b84a6953464d1d32cf2f3920106faf41c6128b426eb38a8515122bed12e083bfdb7d8f3874f99b20619595b31748ff483c6f2fb0a3833564a113716c940cf82d87115fbfdd84d70c52f1c35c218fd27040686844e27af8b6956d6c69ebe3b0e883bdf18b8caec596f3b869e8adf14067ae9f0ad26573fb4627f9451da98405e836c3cd1f287b1a5a5fa11dc64d0eb84ec17e47cf04616eb662340d623ba53d55700b9370b1d8a363fef93b6fb2c29112c0d35a98d4df00bcafdd7bc89fe60e5019b95c1b6156a00a92e44e422bd2373f94afc2f7d9da4146202ceeef9e64b5ebbbe8ce80ce27840f802ba19504383597be48326270016a2264db918f2c3581f0082f98f3393805161c95a83211f2927ca530f94ce3b891684748bca130f8b6d318067fe9097e9dd2e8eed9664c835995f39239ded5cf2902d7611a15d58594070b635a278ff20c0d10b909d9745a8fddd0165b295444f53a3974ccf57e515329a07da7c8a8d238dcadddd7bccceda51ed1133f2dc1e3cae28383a06c11a812c52531f8cca8252983a14a700c69ad27c09fd9d3b32a6039b7aeba047e72e39b46d150eff3e091a60808a700b5613569dd72a354ad35ff53b2bd6c4e3f7a506f1d3f9eaf37a802dacd388f2c475bd7e154f8e2282488b7207225a4488e39c2bb6141b7860a7a99bd7d724941a877251f63d0bbb705c9ea1eac5eeb875bc2ec540ed45a4ce5de7789819d762b37a3d0465f92544cfe222e7a6277cdc9e88adf8eec0e77f5fb08b56dbec78bdcb78728085de4a8171f18f659d81d063b49e73db064d808d29d0a416a9fd6fbff3b0fcd866b48307968a7890dd742281d66eb7c76e621788d9651462a41ed2d10e64d376b20c088bcae590d41168014793f6f370e58b9c58ccbf7f72a4bf7756ab3cf0ff06a6bfd22f28439c097f7c4c608df46d11033f6aa57ea6b88e79df500bcad725995e7ea8bb4a47258281ae5c369d4ddfa626598ffaa0cd9b6c582895c83f148bb364f8e578600891b9ad40776aec38ba2e28a7810cd1c0f2e94dacf5ebbda2c41c88c4655c117590f73f157bb3a93ae5d5942d4ae651686458245102558d17fe30e9120c7d55ed8847e1635a5a6c969c8c2e6481b7aba38454bf30272be0661e6ba8cd78b65d697b6cdc21ef92abf76a2c20e5d08dc61c0595e8a8afcbc28751671e6a6995eac0e064e6bb53fd737a7fef92de8398f7866aad038d9c565d9c436bdcd0c9296fb377f29f26b012466dbb5b8e54ed2fdca5720d8e9152e0e042aaf84eeb143135d57d5a365e24e056e4129f9294167854328ac8b92614256a63c741dc943b0303bbc5e9edbd92af4ee67bcecf5142252d94dc072fdbef8830c749e763711f50bd50c47e9b32299d6b60050d4e7397a5d4d5d0b8cbe78d578475d9a735edc0cf24d898759a964fc408e5c3887d96d07644971504b45d7804ddd1b0b3249260e26b6f27b93511da1c763311e2f35597fb2e5ae10c75fce4c45b22d3069adb00f55546bd6466ae32542d1e452353cf5d24a0d4a0406a98975e48f899cde5b6f8136d9a7e3bc428701cc72a75f164845f38ea3006f8d542cd2795ed095db6a60d496d8a0e597604c48e9918c2183fd70c3c95611fc284fd8675f1c2c68f8ab979c513f7db1207048877e92939a0a568fac391f456d3fc39fc216b51a19e6ea4df5a4763a377d66ac56b8eff9724fa061ee1be9ffa8414bbd84bc76f8f7cce875a4433370402ece06a7805ab33e173a788c75c77a7c455ac7271c9f5ae0f2b172975b1306723d52aa3aca1409fa8ddaa9681322bfafcc6321b2ffe10fecc532396f91967a5720dc06212725a131b113e377422a40ffab3b6f73d6e306fcbc5f4d4a180f8b39ef9838126bce8ad9b2e04dc52af8962542d21b7186c8790a14f323e80a77020a5bc9d4ad69da433d2cb0a38d405fd71b9a6b3801dcf41306c9252bc0b39358b077d7a906b3d076b60124c6c9e3879311996461219a761945966418afb61be3e69ff1390bed76e60dca5c3c4f5421aa99f2b1050a372590fff0d8bf1d9f587370162f8798071a08442bf5a362147ea66dbc6629a6c6d5d43e87b13d848089821ac3bb09b43b86982b4e2b32c4356be09651172f7b40db62255f8ae109d1b61b3d1e0d8f65115501a85ba01829f61c361fdc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9:57</title>
    <link href="/xxx/2018/08/9-57/"/>
    <url>/xxx/2018/08/9-57/</url>
    
    <content type="html"><![CDATA[<p>8月末<br>8月都快接近尾声了，感觉整个8月都是下雨中度过的，感谢台风带来丰沛的雨量啊。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>七夕快乐！！！</title>
    <link href="/xxx/2018/08/%E4%B8%83%E5%A4%95%E5%BF%AB%E4%B9%90%EF%BC%81/"/>
    <url>/xxx/2018/08/%E4%B8%83%E5%A4%95%E5%BF%AB%E4%B9%90%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>七夕快乐<br><img src="http://pic.xxxdk.xyz/%E4%B8%83%E5%A4%95%E5%BF%AB%E4%B9%90.jpg" alt="paste image"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
